---
title: Core Principles and Architecture for Building Agentic AI
description: What is "minimal core + tool bootstrapping"? Why is the coding agent the core form of Agentic AI? And how to build a Claude Code-like product with the A3S Code TypeScript SDK.
date: "2026-02-27"
author: A3S Lab
tags: [a3s-code, coding-agent, architecture, typescript, sdk]
---

Software development is the highest-density test of AI Agent capability. Reading an unfamiliar codebase, tracking down a subtle bug, adding new functionality without breaking existing logic — these tasks require an Agent to simultaneously perceive, reason, act, and verify. Miss any one of them and the Agent fails.

That's why the coding agent isn't just a vertical application of AI — it's the core form of the entire Agentic AI field. This post explains the core principles of building Agentic AI from an architectural perspective, introduces the "minimal core + tool bootstrapping" design pattern, compares the positioning of three mainstream tools, and then demonstrates how to build a Claude Code-like product from scratch using the A3S Code TypeScript SDK.

---

## I. The Essence of an Agent: The Perceive–Decide–Act Loop

Strip away the outer shell of any AI Agent and you're left with three layers:

**Perception** — reading environment state. File contents, command output, API responses, database records — all are the Agent's perception targets.

**Decision** — reasoning about the next step based on state. This is the LLM's core job: given the current context, decide which tool to call and with what arguments.

**Action** — executing tool calls to produce side effects. Writing files, running commands, calling APIs — changing the state of the external world.

These three layers form a loop. Each iteration is called a "turn." An Agent's capability is fundamentally the quality of this loop: how accurate the perception, how sound the reasoning, how reliable the action, how timely the feedback.

A codebase is the best training ground for this loop, because it provides **objective feedback signals**. The compiler either passes or errors. Tests are either green or red. No ambiguity. This objectivity lets the Agent self-correct without depending on human judgment.

An Agent that can work autonomously in a codebase already has the foundational capabilities to work in any other structured environment.

---

## II. Minimal Core + Tool Bootstrapping

This is the most important architectural principle for building Agentic AI systems, and the design foundation of A3S Code.

### What is a minimal core?

A minimal core means: **the non-replaceable parts of the system should be as small as possible.**

The true core of a coding Agent is only five components:

```
Agent          ← Configuration loading, session lifecycle management
AgentSession   ← Workspace-bound execution context
AgentLoop      ← Execution engine driving LLM turns
ToolExecutor   ← Tool registration, dispatch, execution
LlmClient      ← Unified abstraction over LLM providers
```

These five components are the skeleton of the system. Their relationships are fixed: `Agent` creates `AgentSession`, `AgentSession` holds `AgentLoop`, `AgentLoop` calls `LlmClient` for decisions each turn, then executes tools through `ToolExecutor`.

This skeleton should not change with business requirements. It is stable, testable, and independently reasoned about.

### What is tool bootstrapping?

Tool bootstrapping means: **all of the Agent's extended capabilities are implemented through tools, not by modifying the core.**

This principle has two layers:

**Layer one: built-in tools cover foundational capabilities.** File read/write, code search, command execution, network requests — these are the basic actions of a coding Agent, available as built-in tools, ready out of the box.

**Layer two: external tools extend specialized capabilities.** Database operations, code review, deployment pipelines, third-party APIs — these are integrated via MCP (Model Context Protocol) or custom tools, without touching core code.

The key insight of tool bootstrapping is: **the LLM itself is the best tool router.** You don't need to write complex intent-recognition logic. Just give the LLM clear enough tool descriptions, and it will decide when to use which tool.

The result of this design: the system's capability boundary is determined by the tool set, and the tool set can be dynamically extended at runtime, while core code stays unchanged.

### Why does this principle matter?

Consider the opposite: what happens if you bake permission control, memory management, skills systems, and MCP integration into the core?

The core becomes bloated. Every new requirement requires modifying the core. Different features become coupled. Testing becomes difficult. Maintenance cost grows exponentially.

Minimal core + tool bootstrapping dissolves all of these problems: the core does one thing (drive LLM turns), everything else is a pluggable extension.

In A3S Code, this principle manifests as 19 trait extension points, each with a default implementation:

```typescript
// Not happy with the default permission system? Implement your own.
class MyPermissionChecker implements PermissionChecker {
  async check(tool: string, args: unknown): Promise<Permission> {
    // your logic
  }
}

const session = agent.session('.', {
  permissionChecker: new MyPermissionChecker(),
});
```

Works out of the box. Any part is replaceable. Core stays stable.

---

## III. Three Positions, Three Design Philosophies

Three tools deserve serious comparison: Claude Code, OpenCode, and A3S Code. All carry the "coding Agent" label, but their underlying design philosophies are completely different.

### Claude Code: Developer Experience First

Claude Code is an interactive CLI tool built by Anthropic, designed to **give developers the best AI-assisted programming experience in the terminal**.

Its design philosophy is "human-machine collaboration": the Agent proposes a plan, the human approves, the Agent executes, the human observes. The entire interaction flow is designed around this rhythm — permission prompts, plan mode, HITL confirmation — all to keep the human in control.

This positioning determines its architectural choices: it's a CLI tool, not a library. You use it through the terminal; you can't call it through code. It's bound to Anthropic's models, because Anthropic can do deep optimization for its own models (context compression, tool call format, system prompt design).

**The boundary of this positioning**: when you need to embed coding Agent capability into your own product, Claude Code can't help. It has no programming API, no multi-tenancy support, and wasn't designed for programmatic invocation.

### OpenCode: Open Ecosystem First

OpenCode is an open-source terminal coding Agent, designed to **provide a model-agnostic, self-hostable alternative to Claude Code**.

Its design philosophy is "openness first": supports any OpenAI-compatible model endpoint, fully open-source, community can contribute features and integrations.

This positioning determines its architectural choices: it's also a CLI tool, with interactive terminal experience at its core. Its advantage is flexibility — you can connect local models, privately deployed models, any compatible API.

**The boundary of this positioning**: like Claude Code, its architecture centers on "human-machine interaction" and wasn't designed for programmatic embedding. If you want to call it from your application, you're dealing with a CLI tool, not an SDK.

### A3S Code: Embeddability First

A3S Code solves a completely different problem: **when you need to embed coding Agent capability as infrastructure into your product, what do you use?**

Its design philosophy is "library first": Rust core library + Node.js/Python native bindings — not a service, not a CLI, but a library your code can call directly.

This positioning determines its architectural choices: minimal core + tool bootstrapping, 19 trait extension points, lane priority queue, multi-machine task dispatch, MCP runtime dynamic registration. Every design decision answers the same question: how do we make this library run reliably in production?

**The boundary of this positioning**: it's not an out-of-the-box terminal tool. You need to write code to integrate it. If you just want AI-assisted programming in the terminal, Claude Code is the better choice.

### Positioning Comparison

| | Claude Code | OpenCode | A3S Code |
|---|---|---|---|
| **Core positioning** | Developer terminal tool | Open ecosystem terminal tool | Embeddable coding Agent library |
| **Usage** | CLI interaction | CLI interaction | Code invocation |
| **Model support** | Anthropic (+ Bedrock/Vertex) | Any OpenAI-compatible | Any OpenAI-compatible |
| **Embeddability** | No programming API | No programming API | Core design goal |
| **Extension** | MCP + Skills + Hooks | MCP + plugins | Trait extension points + MCP |
| **Multi-tenancy** | Not supported | Not supported | Supported |
| **Parallel tasks** | Sub-agent parallelism | Limited | Lane queue + multi-machine dispatch |
| **Open source** | No | Yes | Yes |

This isn't a comparison of feature quality — it's a comparison of design goals. All three tools do well within their own positioning.

---

## IV. Building a Claude Code-Like Product with the TypeScript SDK

With the architectural principles understood, let's put them into practice. We'll use the A3S Code TypeScript SDK to build a terminal coding assistant with Claude Code's core capabilities.

Target product features:
- Multi-turn conversation with codebase context understanding
- Streaming output showing the Agent's thinking in real time
- Tool execution (read files, write files, run commands)
- Permission control requiring user confirmation for sensitive operations
- MCP server support for dynamically extending the tool set
- Session persistence supporting resumption of previous conversations

### 4.1 Installation and Configuration

```bash
npm install @a3s-lab/code
```

Create an `agent.hcl` config file:

```hcl
# Supports any OpenAI-compatible endpoint
default_model = "anthropic/claude-sonnet-4-20250514"

providers {
  name    = "anthropic"
  api_key = env("ANTHROPIC_API_KEY")
}

# Optional: connect MCP servers
mcp_servers {
  name    = "filesystem"
  command = "npx"
  args    = ["-y", "@modelcontextprotocol/server-filesystem", "."]
}
```

### 4.2 Core Session Loop

This is the skeleton of the entire product — a loop that reads user input and streams Agent responses:

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';

const agent = await Agent.create('agent.hcl');
const session = agent.session(process.cwd());

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function prompt(): Promise<string> {
  return new Promise((resolve) => {
    rl.question('\n> ', resolve);
  });
}

console.log('A3S Code — type your question, Ctrl+C to exit\n');

while (true) {
  const input = await prompt();
  if (!input.trim()) continue;

  // Streaming output: show every character the Agent produces in real time
  const events = await session.stream(input);

  for await (const event of events) {
    switch (event.type) {
      case 'text_delta':
        process.stdout.write(event.text);
        break;

      case 'tool_use':
        // Show tool calls so the user knows what the Agent is doing
        console.log(`\n[tool] ${event.tool}(${JSON.stringify(event.args)})`);
        break;

      case 'tool_result':
        // Tool execution complete; optionally show a result summary
        break;

      case 'end':
        console.log('\n');
        break;
    }
  }
}
```

### 4.3 Adding Permission Control

A core design of Claude Code is that dangerous operations require user confirmation. We implement the same effect with A3S Code's permission system:

```typescript
import { Agent, PermissionChecker, Permission } from '@a3s-lab/code';
import * as readline from 'readline';

// High-risk tools that require confirmation
const DANGEROUS_TOOLS = new Set(['bash', 'write', 'edit', 'patch']);

class InteractivePermissionChecker implements PermissionChecker {
  private rl: readline.Interface;

  constructor(rl: readline.Interface) {
    this.rl = rl;
  }

  async check(tool: string, args: unknown): Promise<Permission> {
    // Read-only tools pass through immediately
    if (!DANGEROUS_TOOLS.has(tool)) {
      return Permission.Allow;
    }

    // Show the operation about to be executed
    const preview = this.formatPreview(tool, args);
    console.log(`\n⚠️  Agent wants to execute:\n${preview}`);

    const answer = await new Promise<string>((resolve) => {
      this.rl.question('Allow? [y/N] ', resolve);
    });

    return answer.toLowerCase() === 'y' ? Permission.Allow : Permission.Deny;
  }

  private formatPreview(tool: string, args: unknown): string {
    const a = args as Record<string, unknown>;
    switch (tool) {
      case 'bash':
        return `  $ ${a.command}`;
      case 'write':
        return `  Write file: ${a.file_path}`;
      case 'edit':
        return `  Edit file: ${a.file_path}`;
      default:
        return `  ${tool}: ${JSON.stringify(args, null, 2)}`;
    }
  }
}

// Integrate into session
const session = agent.session(process.cwd(), {
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.4 Dynamic MCP Server Registration

Claude Code supports declaring MCP servers in config files. A3S Code also supports runtime dynamic registration, letting you load tools on demand based on the user's project type:

```typescript
// Detect project type and load MCP servers on demand
async function loadProjectMcpServers(session: AgentSession, projectPath: string) {
  const fs = await import('fs/promises');

  // Detected package.json → load Node.js-related tools
  try {
    await fs.access(`${projectPath}/package.json`);
    const count = await session.addMcpServer(
      'nodejs-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] Loaded Node.js toolset, ${count} tools available`);
  } catch {}

  // Detected Cargo.toml → load Rust-related tools
  try {
    await fs.access(`${projectPath}/Cargo.toml`);
    const count = await session.addMcpServer(
      'rust-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] Loaded Rust toolset, ${count} tools available`);
  } catch {}
}
```

### 4.5 Session Persistence

Claude Code supports resuming previous sessions. A3S Code implements the same capability through the `SessionStore` trait:

```typescript
import { SessionStore, SessionData } from '@a3s-lab/code';
import * as fs from 'fs/promises';
import * as path from 'path';

class FileSessionStore implements SessionStore {
  private storePath: string;

  constructor(storePath: string) {
    this.storePath = storePath;
  }

  async save(sessionId: string, data: SessionData): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.mkdir(this.storePath, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
  }

  async load(sessionId: string): Promise<SessionData | null> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  async delete(sessionId: string): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.unlink(filePath).catch(() => {});
  }
}

// Use the project directory as session ID for "one session per project"
const projectId = Buffer.from(process.cwd()).toString('base64url');
const session = agent.session(process.cwd(), {
  sessionId: projectId,
  sessionStore: new FileSessionStore(path.join(process.env.HOME!, '.a3s/sessions')),
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.6 Slash Commands

Claude Code has built-in commands like `/help`, `/clear`, `/cost`. A3S Code's `SlashCommand` interface lets you implement the same:

```typescript
import { SlashCommand, CommandContext, CommandOutput } from '@a3s-lab/code';

// /cost command: show token usage for this session
class CostCommand implements SlashCommand {
  name = 'cost';
  description = 'Show token usage and estimated cost for this session';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    const usage = ctx.tokenUsage;
    // Claude Sonnet 4 pricing (for reference)
    const inputCost = (usage.promptTokens / 1_000_000) * 3.0;
    const outputCost = (usage.completionTokens / 1_000_000) * 15.0;
    const total = inputCost + outputCost;

    return CommandOutput.text(
      `Token usage:\n` +
      `  Input:  ${usage.promptTokens.toLocaleString()} tokens ($${inputCost.toFixed(4)})\n` +
      `  Output: ${usage.completionTokens.toLocaleString()} tokens ($${outputCost.toFixed(4)})\n` +
      `  Total:  $${total.toFixed(4)}`
    );
  }
}

// /clear command: clear conversation history
class ClearCommand implements SlashCommand {
  name = 'clear';
  description = 'Clear conversation history and start a new session';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    ctx.clearHistory();
    return CommandOutput.text('Conversation history cleared');
  }
}

session.registerCommand(new CostCommand());
session.registerCommand(new ClearCommand());
```

### 4.7 Full Product Assembly

Putting it all together:

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';
import * as path from 'path';

async function main() {
  const agent = await Agent.create('agent.hcl');

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
  });

  // Handle Ctrl+C
  rl.on('close', () => {
    console.log('\nGoodbye!');
    process.exit(0);
  });

  const projectId = Buffer.from(process.cwd()).toString('base64url');

  const session = agent.session(process.cwd(), {
    sessionId: projectId,
    sessionStore: new FileSessionStore(
      path.join(process.env.HOME!, '.a3s/sessions')
    ),
    permissionChecker: new InteractivePermissionChecker(rl),
  });

  // Register commands
  session.registerCommand(new CostCommand());
  session.registerCommand(new ClearCommand());

  // Load MCP servers on demand
  await loadProjectMcpServers(session, process.cwd());

  // Show welcome message
  const isResumed = await session.hasHistory();
  if (isResumed) {
    console.log('✓ Previous session resumed. Type /clear to start fresh.\n');
  } else {
    console.log('A3S Code — type your question, /help for commands, Ctrl+C to exit\n');
  }

  // Main loop
  while (true) {
    const input = await new Promise<string>((resolve) => {
      rl.question('> ', resolve);
    });

    if (!input.trim()) continue;

    // Slash commands
    if (input.startsWith('/')) {
      const output = await session.executeCommand(input);
      console.log(output.text);
      continue;
    }

    // Agent streaming response
    try {
      const events = await session.stream(input);
      for await (const event of events) {
        if (event.type === 'text_delta') {
          process.stdout.write(event.text);
        } else if (event.type === 'tool_use') {
          process.stdout.write(`\n[${event.tool}] `);
        } else if (event.type === 'end') {
          console.log('\n');
        }
      }
    } catch (err) {
      console.error(`\nError: ${err instanceof Error ? err.message : err}\n`);
    }
  }
}

main().catch(console.error);
```

This product already has Claude Code's core capabilities: multi-turn conversation, streaming output, tool execution, permission control, MCP support, session persistence, and slash commands. Under 200 lines of code.

---

## V. From Single Machine to Multi-Machine: The Value of Lane Queues

The above builds a single-machine version. When your product needs to handle more complex scenarios — serving multiple users simultaneously, or distributing compute-intensive tasks to remote machines — the lane queue provides the solution.

The lane queue divides tool calls into four priority channels:

```
Control (P0) ← Control instructions, highest priority, sequential execution
Query   (P1) ← Read files, search, parallel execution
Execute (P2) ← Write files, run commands, sequential execution
Generate(P3) ← LLM calls, lowest priority
```

Parallel execution in the Query channel is the key optimization: when the LLM returns multiple file-read requests in a single turn, they execute in parallel rather than waiting serially.

```typescript
import { SessionQueueConfig } from '@a3s-lab/code';

const session = agent.session(process.cwd(), {
  queueConfig: {
    enableAllFeatures: true,
    queryMaxConcurrency: 8,  // up to 8 read operations in parallel
  },
});
```

When you need to dispatch execution tasks to remote machines:

```typescript
// Switch Execute channel to external mode
await session.setLaneHandler('execute', {
  mode: 'external',
  timeoutMs: 120_000,
});

// Listen for external tasks and dispatch to Workers
const events = await session.stream('Run the full test suite and fix all failures');
for await (const event of events) {
  if (event.type === 'external_task_pending') {
    const tasks = await session.pendingExternalTasks();
    for (const task of tasks) {
      // Send to remote Worker (your transport layer: gRPC, HTTP, message queue, etc.)
      const result = await dispatchToWorker(task);
      await session.completeExternalTask(task.task_id, result);
    }
  }
}
```

This pattern lets you transparently distribute compute-intensive tasks to any number of remote machines without modifying Agent logic.

---

## VI. Conclusion

The core of Agentic AI is the perceive–decide–act loop, and coding tasks are the highest-density test of this loop.

Building reliable Agentic AI systems requires two core principles:

**Minimal core** — the non-replaceable parts of the system should be as small as possible, containing only the components necessary to drive LLM turns.

**Tool bootstrapping** — all extended capabilities are implemented through tools. The LLM is the best tool router. Core code stays unchanged.

On product positioning: Claude Code and OpenCode center on terminal interaction experience, designed for developers. A3S Code centers on embeddability, designed for product builders. This isn't competition — it's division of labor.

If you're **using** a coding Agent, Claude Code is the most mature choice.

If you're **building** a product that includes coding Agent capability, A3S Code provides the infrastructure you need — from a single-machine interactive assistant to a multi-machine distributed execution system, all on the same API.

---

*A3S Code is an open-source Rust coding Agent framework with Rust, Node.js, and Python SDKs. [View Docs](/docs/code) · [GitHub](https://github.com/A3S-Lab/Code)*
