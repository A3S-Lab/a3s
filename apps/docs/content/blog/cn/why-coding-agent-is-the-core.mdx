---
title: 构建 Agentic AI 的核心原理和基础架构
description: 什么是极简核心+工具自举？编码智能体为何是 Agentic AI 的核心形态？以及如何用 A3S Code TypeScript SDK 从零构建一个类 Claude Code 的产品。
date: "2026-02-27"
author: A3S Lab
tags: [a3s-code, coding-agent, architecture, typescript, sdk]
---

软件开发者每天面对的问题，是 AI Agent 能力的最高密度测试场。读懂一个陌生代码库、定位一个隐蔽的 bug、在不破坏现有逻辑的前提下添加新功能——这些任务要求 Agent 同时具备感知、推理、行动、验证四种能力，缺一不可。

这就是为什么编码智能体不只是 AI 的一个垂直应用，而是整个 Agentic AI 领域的核心形态。本文从架构设计出发，解释构建 Agentic AI 的核心原理，介绍"极简核心 + 工具自举"这一关键设计模式，对比三种主流工具的定位差异，最后用 A3S Code TypeScript SDK 演示如何从零构建一个类 Claude Code 的产品。

---

## 一、Agent 的本质：感知—决策—行动的闭环

把所有 AI Agent 的外壳剥掉，剩下的结构只有三层：

**感知层**——读取环境状态。文件内容、命令输出、API 响应、数据库记录，都是 Agent 的感知对象。

**决策层**——基于状态推理下一步。这是 LLM 的核心职责：给定当前上下文，决定调用哪个工具、传入什么参数。

**行动层**——执行工具调用，产生副作用。写文件、运行命令、调用 API，改变外部世界的状态。

这三层构成一个循环，每次循环称为一个"轮次"（turn）。Agent 的能力，本质上是这个循环的质量：感知是否准确、决策是否合理、行动是否可靠、反馈是否及时。

代码库是这个循环的最佳训练场，原因是它提供了**客观的反馈信号**。编译器要么通过要么报错，测试要么绿要么红，没有模糊地带。这种客观性让 Agent 能够自我校正，而不依赖人类的主观判断。

一个能在代码库里自主工作的 Agent，已经具备了在任何其他结构化环境里工作的基础能力。

---

## 二、极简核心 + 工具自举

这是构建 Agentic AI 系统最重要的架构原则，也是 A3S Code 的设计基础。

### 什么是极简核心？

极简核心的意思是：**系统的不可替换部分应该尽可能小。**

一个编码 Agent 的真正核心，只有五个组件：

```
Agent          ← 配置加载、会话生命周期管理
AgentSession   ← 工作区绑定的执行上下文
AgentLoop      ← 驱动 LLM 轮次的执行引擎
ToolExecutor   ← 工具注册、调度、执行
LlmClient      ← LLM 提供商的统一抽象
```

这五个组件是系统的骨架。它们之间的关系是固定的：`Agent` 创建 `AgentSession`，`AgentSession` 持有 `AgentLoop`，`AgentLoop` 在每个轮次里调用 `LlmClient` 获取决策，再通过 `ToolExecutor` 执行工具。

这个骨架不应该随业务需求变化。它是稳定的、可测试的、可独立推理的。

### 什么是工具自举？

工具自举的意思是：**Agent 的所有扩展能力，都通过工具来实现，而不是通过修改核心。**

这个原则有两层含义：

**第一层：内置工具覆盖基础能力。** 文件读写、代码搜索、命令执行、网络请求——这些是编码 Agent 的基础动作，以内置工具的形式存在，开箱即用。

**第二层：外部工具扩展专业能力。** 数据库操作、代码审查、部署流水线、第三方 API——这些通过 MCP（Model Context Protocol）或自定义工具接入，不需要修改核心代码。

工具自举的关键洞察是：**LLM 本身就是最好的工具路由器。** 你不需要写复杂的意图识别逻辑，只需要给 LLM 提供足够清晰的工具描述，它会自己决定什么时候用什么工具。

这个设计的结果是：系统的能力边界由工具集决定，而工具集可以在运行时动态扩展，核心代码保持不变。

### 为什么这个原则重要？

考虑反面：如果你把权限控制、记忆管理、技能系统、MCP 集成都写进核心，会发生什么？

核心变得臃肿，每个新需求都需要修改核心，不同功能之间产生耦合，测试变得困难，维护成本指数级上升。

极简核心 + 工具自举把这些问题全部消解：核心只做一件事（驱动 LLM 轮次），其他一切都是可插拔的扩展。

在 A3S Code 里，这个原则体现为 19 个 trait 扩展点，每个都有默认实现：

```typescript
// 不满意默认的权限系统？实现自己的
class MyPermissionChecker implements PermissionChecker {
  async check(tool: string, args: unknown): Promise<Permission> {
    // 你的逻辑
  }
}

const session = agent.session('.', {
  permissionChecker: new MyPermissionChecker(),
});
```

系统开箱即用，任何部分都可以替换，核心保持稳定。

---

## 三、三种定位，三种设计哲学

市场上有三个值得认真对比的工具：Claude Code、OpenCode、A3S Code。它们都在"编码 Agent"这个标签下，但背后的设计哲学完全不同。

### Claude Code：以开发者体验为中心

Claude Code 是 Anthropic 构建的交互式 CLI 工具，设计目标是**让开发者在终端里获得最好的 AI 辅助编程体验**。

它的设计哲学是"人机协作"：Agent 提出方案，人类审批，Agent 执行，人类观察。整个交互流程围绕这个节奏设计——权限提示、计划模式、HITL 确认，都是为了让人类保持控制感。

这个定位决定了它的架构选择：它是一个 CLI 工具，不是一个库。你通过终端使用它，不能通过代码调用它。它绑定 Anthropic 的模型，因为 Anthropic 可以对自己的模型做深度优化（上下文压缩、工具调用格式、系统提示设计）。

**这个定位的边界**：当你需要把编码 Agent 能力嵌入自己的产品时，Claude Code 帮不了你。它没有编程 API，没有多租户支持，没有为程序化调用设计。

### OpenCode：以开放生态为中心

OpenCode 是开源的终端编码 Agent，设计目标是**提供一个模型无关、可自托管的 Claude Code 替代品**。

它的设计哲学是"开放优先"：支持任何 OpenAI 兼容的模型端点，代码完全开源，社区可以贡献功能和集成。

这个定位决定了它的架构选择：它同样是一个 CLI 工具，以交互式终端体验为核心。它的优势在于灵活性——你可以接入本地模型、私有部署的模型、任何兼容 API。

**这个定位的边界**：和 Claude Code 一样，它的架构以"人机交互"为中心，没有为程序化嵌入设计。如果你想在自己的应用里调用它，你面对的是一个 CLI 工具，而不是一个 SDK。

### OpenClaw：以个人助理体验为中心

OpenClaw 是面向消息平台（WhatsApp、Telegram、Slack）的个人 AI 助理 Agent，设计目标是**让用户在日常使用的聊天工具里获得智能任务自动化能力**。

它的设计哲学是\"对话即操作\"：用户通过自然语言发出指令，Agent 理解意图并执行——查询信息、管理日程、处理文件、调用外部服务。整个体验围绕消息平台的交互范式设计，而不是终端或 IDE。

这个定位决定了它的架构选择：它是一个部署在消息平台上的服务，不是一个本地工具或可嵌入的库。它的优势在于触达——用户不需要安装任何东西，在已有的聊天工具里就能使用 AI 能力。

**这个定位的边界**：它的核心是\"个人助理\"，不是\"编码智能体\"。当你需要在自己的产品里嵌入 Agent 能力，或者需要处理代码库级别的复杂任务时，它的架构不是为这个场景设计的。

### A3S Code：以可嵌入性为中心

A3S Code 解决的是一个完全不同的问题：**当你需要把编码 Agent 能力作为基础设施嵌入你的产品时，你用什么？**

它的设计哲学是"库优先"：Rust 核心库 + Node.js/Python 原生绑定，不是服务，不是 CLI，是可以被你的代码直接调用的库。

这个定位决定了它的架构选择：极简核心 + 工具自举，19 个 trait 扩展点，Lane 优先级队列，多机器任务分发，MCP 运行时动态注册。每一个设计决策都在回答同一个问题：如何让这个库在生产环境里可靠运行？

**这个定位的边界**：它不是开箱即用的终端工具。你需要写代码来集成它。如果你只是想在终端里用 AI 辅助编程，Claude Code 是更好的选择。

### 定位对比

| | Claude Code | OpenCode | OpenClaw | A3S Code |
|---|---|---|---|---|
| **核心定位** | 开发者终端工具 | 开放生态终端工具 | 消息平台个人助理 | 可嵌入 Agent 基础设施 |
| **使用方式** | CLI 交互 | CLI 交互 | 消息平台对话 | 代码调用 |
| **模型支持** | Anthropic（+ Bedrock/Vertex） | 任意 OpenAI 兼容 | 多模型 | 任意 OpenAI 兼容 |
| **可嵌入性** | 无编程 API | 无编程 API | 无编程 API | 核心设计目标 |
| **扩展方式** | MCP + Skills + Hooks | MCP + 插件 | 插件 | Trait 扩展点 + MCP |
| **多租户** | 不支持 | 不支持 | 不支持 | 支持 |
| **并行任务** | 子 Agent 并行 | 有限支持 | 不支持 | Lane 队列 + 多机器分发 |
| **开源** | 否 | 是 | 否 | 是 |

这不是功能优劣的对比，是设计目标的对比。四个工具在各自的定位上都有其价值。

---

## 四、用 TypeScript SDK 构建类 Claude Code 的产品

理解了架构原则，现在来实践。我们用 A3S Code 的 TypeScript SDK 构建一个具备 Claude Code 核心能力的终端编码助手。

目标产品具备：
- 多轮对话，理解代码库上下文
- 流式输出，实时显示 Agent 思考过程
- 工具执行（读文件、写文件、运行命令）
- 权限控制，敏感操作需要用户确认
- MCP 服务器支持，动态扩展工具集
- 会话持久化，支持恢复上次对话

### 4.1 安装和配置

```bash
npm install @a3s-lab/code
```

创建 `agent.hcl` 配置文件：

```hcl
# 支持任何 OpenAI 兼容端点
default_model = "anthropic/claude-sonnet-4-20250514"

providers {
  name    = "anthropic"
  api_key = env("ANTHROPIC_API_KEY")
}

# 可选：接入 MCP 服务器
mcp_servers {
  name    = "filesystem"
  command = "npx"
  args    = ["-y", "@modelcontextprotocol/server-filesystem", "."]
}
```

### 4.2 核心会话循环

这是整个产品的骨架——一个读取用户输入、流式输出 Agent 响应的循环：

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';

const agent = await Agent.create('agent.hcl');
const session = agent.session(process.cwd());

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function prompt(): Promise<string> {
  return new Promise((resolve) => {
    rl.question('\n> ', resolve);
  });
}

console.log('A3S Code — 输入你的问题，Ctrl+C 退出\n');

while (true) {
  const input = await prompt();
  if (!input.trim()) continue;

  // 流式输出：实时显示 Agent 的每一个字
  const events = await session.stream(input);

  for await (const event of events) {
    switch (event.type) {
      case 'text_delta':
        process.stdout.write(event.text);
        break;

      case 'tool_use':
        // 显示工具调用，让用户知道 Agent 在做什么
        console.log(`\n[工具] ${event.tool}(${JSON.stringify(event.args)})`);
        break;

      case 'tool_result':
        // 工具执行完成，可以选择显示结果摘要
        break;

      case 'end':
        console.log('\n');
        break;
    }
  }
}
```

### 4.3 添加权限控制

Claude Code 的一个核心设计是：危险操作需要用户确认。我们用 A3S Code 的权限系统实现同样的效果：

```typescript
import { Agent, PermissionChecker, Permission } from '@a3s-lab/code';
import * as readline from 'readline';

// 需要确认的高风险工具
const DANGEROUS_TOOLS = new Set(['bash', 'write', 'edit', 'patch']);

class InteractivePermissionChecker implements PermissionChecker {
  private rl: readline.Interface;

  constructor(rl: readline.Interface) {
    this.rl = rl;
  }

  async check(tool: string, args: unknown): Promise<Permission> {
    // 只读工具直接放行
    if (!DANGEROUS_TOOLS.has(tool)) {
      return Permission.Allow;
    }

    // 显示将要执行的操作
    const preview = this.formatPreview(tool, args);
    console.log(`\n⚠️  Agent 想要执行：\n${preview}`);

    const answer = await new Promise<string>((resolve) => {
      this.rl.question('允许？[y/N] ', resolve);
    });

    return answer.toLowerCase() === 'y' ? Permission.Allow : Permission.Deny;
  }

  private formatPreview(tool: string, args: unknown): string {
    const a = args as Record<string, unknown>;
    switch (tool) {
      case 'bash':
        return `  $ ${a.command}`;
      case 'write':
        return `  写入文件: ${a.file_path}`;
      case 'edit':
        return `  编辑文件: ${a.file_path}`;
      default:
        return `  ${tool}: ${JSON.stringify(args, null, 2)}`;
    }
  }
}

// 集成到 session
const session = agent.session(process.cwd(), {
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.4 添加 MCP 服务器动态注册

Claude Code 支持在配置文件里声明 MCP 服务器。A3S Code 还支持在运行时动态注册，这让你可以根据用户的项目类型按需加载工具：

```typescript
// 检测项目类型，按需加载 MCP 服务器
async function loadProjectMcpServers(session: AgentSession, projectPath: string) {
  const fs = await import('fs/promises');

  // 检测到 package.json → 加载 Node.js 相关工具
  try {
    await fs.access(`${projectPath}/package.json`);
    const count = await session.addMcpServer(
      'nodejs-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] 加载 Node.js 工具集，${count} 个工具可用`);
  } catch {}

  // 检测到 Cargo.toml → 加载 Rust 相关工具
  try {
    await fs.access(`${projectPath}/Cargo.toml`);
    const count = await session.addMcpServer(
      'rust-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] 加载 Rust 工具集，${count} 个工具可用`);
  } catch {}
}
```

### 4.5 添加会话持久化

Claude Code 支持恢复上次会话。A3S Code 通过 `SessionStore` trait 实现同样的能力：

```typescript
import { SessionStore, SessionData } from '@a3s-lab/code';
import * as fs from 'fs/promises';
import * as path from 'path';

class FileSessionStore implements SessionStore {
  private storePath: string;

  constructor(storePath: string) {
    this.storePath = storePath;
  }

  async save(sessionId: string, data: SessionData): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.mkdir(this.storePath, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
  }

  async load(sessionId: string): Promise<SessionData | null> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  async delete(sessionId: string): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.unlink(filePath).catch(() => {});
  }
}

// 使用项目目录作为会话 ID，实现"每个项目一个会话"
const projectId = Buffer.from(process.cwd()).toString('base64url');
const session = agent.session(process.cwd(), {
  sessionId: projectId,
  sessionStore: new FileSessionStore(path.join(process.env.HOME!, '.a3s/sessions')),
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.6 添加斜杠命令

Claude Code 有 `/help`、`/clear`、`/cost` 等内置命令。A3S Code 的 `SlashCommand` 接口让你实现同样的功能：

```typescript
import { SlashCommand, CommandContext, CommandOutput } from '@a3s-lab/code';

// /cost 命令：显示本次会话的 token 消耗
class CostCommand implements SlashCommand {
  name = 'cost';
  description = '显示本次会话的 token 消耗和估算费用';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    const usage = ctx.tokenUsage;
    // Claude Sonnet 4 定价（仅供参考）
    const inputCost = (usage.promptTokens / 1_000_000) * 3.0;
    const outputCost = (usage.completionTokens / 1_000_000) * 15.0;
    const total = inputCost + outputCost;

    return CommandOutput.text(
      `Token 消耗：\n` +
      `  输入：${usage.promptTokens.toLocaleString()} tokens ($${inputCost.toFixed(4)})\n` +
      `  输出：${usage.completionTokens.toLocaleString()} tokens ($${outputCost.toFixed(4)})\n` +
      `  合计：$${total.toFixed(4)}`
    );
  }
}

// /clear 命令：清空对话历史
class ClearCommand implements SlashCommand {
  name = 'clear';
  description = '清空对话历史，开始新会话';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    ctx.clearHistory();
    return CommandOutput.text('对话历史已清空');
  }
}

session.registerCommand(new CostCommand());
session.registerCommand(new ClearCommand());
```

### 4.7 完整产品组装

把所有部分组合起来：

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';
import * as path from 'path';

async function main() {
  const agent = await Agent.create('agent.hcl');

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
  });

  // 处理 Ctrl+C
  rl.on('close', () => {
    console.log('\n再见！');
    process.exit(0);
  });

  const projectId = Buffer.from(process.cwd()).toString('base64url');

  const session = agent.session(process.cwd(), {
    sessionId: projectId,
    sessionStore: new FileSessionStore(
      path.join(process.env.HOME!, '.a3s/sessions')
    ),
    permissionChecker: new InteractivePermissionChecker(rl),
  });

  // 注册命令
  session.registerCommand(new CostCommand());
  session.registerCommand(new ClearCommand());

  // 按需加载 MCP 服务器
  await loadProjectMcpServers(session, process.cwd());

  // 显示欢迎信息
  const isResumed = await session.hasHistory();
  if (isResumed) {
    console.log('✓ 已恢复上次会话。输入 /clear 开始新对话。\n');
  } else {
    console.log('A3S Code — 输入你的问题，/help 查看命令，Ctrl+C 退出\n');
  }

  // 主循环
  while (true) {
    const input = await new Promise<string>((resolve) => {
      rl.question('> ', resolve);
    });

    if (!input.trim()) continue;

    // 斜杠命令
    if (input.startsWith('/')) {
      const output = await session.executeCommand(input);
      console.log(output.text);
      continue;
    }

    // Agent 流式响应
    try {
      const events = await session.stream(input);
      for await (const event of events) {
        if (event.type === 'text_delta') {
          process.stdout.write(event.text);
        } else if (event.type === 'tool_use') {
          process.stdout.write(`\n[${event.tool}] `);
        } else if (event.type === 'end') {
          console.log('\n');
        }
      }
    } catch (err) {
      console.error(`\n错误：${err instanceof Error ? err.message : err}\n`);
    }
  }
}

main().catch(console.error);
```

这个产品已经具备了 Claude Code 的核心能力：多轮对话、流式输出、工具执行、权限控制、MCP 支持、会话持久化、斜杠命令。代码量不到 200 行。

---

## 五、用编码智能体构建 Agentic 金融应用

编码智能体不只是为开发者服务的工具——它是构建任何领域 Agentic 应用的基础设施。金融场景是一个很好的例子：数据查询、风险计算、报告生成、交易执行，这些任务都可以通过自定义工具交给 Agent 来驱动。

下面用 A3S Code TypeScript SDK 构建一个终端金融助理，具备股票查询、投资组合分析、风险评估和交易模拟能力。

### 5.1 定义金融工具集

```typescript
import { Agent, Tool, ToolResult } from '@a3s-lab/code';

// 模拟市场数据
const marketData: Record<string, { price: number; change: number; volume: number }> = {
  AAPL: { price: 189.5, change: 1.2, volume: 52_000_000 },
  MSFT: { price: 415.3, change: -0.8, volume: 21_000_000 },
  NVDA: { price: 875.4, change: 3.5, volume: 38_000_000 },
  TSLA: { price: 248.7, change: -2.1, volume: 95_000_000 },
};

// 模拟持仓数据
const portfolio: Record<string, { shares: number; avgCost: number }> = {
  AAPL: { shares: 100, avgCost: 165.0 },
  MSFT: { shares: 50, avgCost: 380.0 },
};

const financeTools: Tool[] = [
  {
    name: 'get_quote',
    description: '获取股票实时报价，包括价格、涨跌幅、成交量',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: '股票代码列表，如 ["AAPL", "MSFT"]',
        },
      },
      required: ['symbols'],
    },
    execute: async (args): Promise<ToolResult> => {
      const { symbols } = args as { symbols: string[] };
      const quotes = symbols.map((sym) => {
        const data = marketData[sym.toUpperCase()];
        if (!data) return { symbol: sym, error: 'Not found' };
        return {
          symbol: sym.toUpperCase(),
          price: data.price,
          change: data.change,
          changePct: ((data.change / (data.price - data.change)) * 100).toFixed(2) + '%',
          volume: data.volume.toLocaleString(),
        };
      });
      return { content: JSON.stringify(quotes, null, 2) };
    },
  },
  {
    name: 'get_portfolio',
    description: '查看当前持仓，计算盈亏和市值',
    parameters: { type: 'object', properties: {} },
    execute: async (): Promise<ToolResult> => {
      const positions = Object.entries(portfolio).map(([sym, pos]) => {
        const market = marketData[sym];
        const marketValue = market ? market.price * pos.shares : 0;
        const costBasis = pos.avgCost * pos.shares;
        const pnl = marketValue - costBasis;
        const pnlPct = ((pnl / costBasis) * 100).toFixed(2);
        return {
          symbol: sym,
          shares: pos.shares,
          avgCost: pos.avgCost,
          currentPrice: market?.price ?? 'N/A',
          marketValue: marketValue.toFixed(2),
          pnl: pnl.toFixed(2),
          pnlPct: pnlPct + '%',
        };
      });
      const totalValue = positions.reduce((s, p) => s + parseFloat(p.marketValue as string), 0);
      const totalPnl = positions.reduce((s, p) => s + parseFloat(p.pnl as string), 0);
      return {
        content: JSON.stringify(
          { positions, summary: { totalValue: totalValue.toFixed(2), totalPnl: totalPnl.toFixed(2) } },
          null,
          2,
        ),
      };
    },
  },
  {
    name: 'risk_assessment',
    description: '对指定股票或投资组合进行风险评估，输出波动率和风险等级',
    parameters: {
      type: 'object',
      properties: {
        symbols: { type: 'array', items: { type: 'string' } },
      },
      required: ['symbols'],
    },
    execute: async (args): Promise<ToolResult> => {
      const { symbols } = args as { symbols: string[] };
      // 简化的风险模型：基于成交量和涨跌幅估算波动率
      const assessments = symbols.map((sym) => {
        const data = marketData[sym.toUpperCase()];
        if (!data) return { symbol: sym, error: 'Not found' };
        const volatility = Math.abs(data.change / data.price) * 100;
        const risk = volatility > 2 ? 'HIGH' : volatility > 1 ? 'MEDIUM' : 'LOW';
        return { symbol: sym.toUpperCase(), volatility: volatility.toFixed(3) + '%', risk };
      });
      return { content: JSON.stringify(assessments, null, 2) };
    },
  },
  {
    name: 'simulate_trade',
    description: '模拟买入或卖出操作，计算交易成本和预期影响',
    parameters: {
      type: 'object',
      properties: {
        symbol: { type: 'string' },
        action: { type: 'string', enum: ['buy', 'sell'] },
        shares: { type: 'number' },
      },
      required: ['symbol', 'action', 'shares'],
    },
    execute: async (args): Promise<ToolResult> => {
      const { symbol, action, shares } = args as {
        symbol: string;
        action: 'buy' | 'sell';
        shares: number;
      };
      const data = marketData[symbol.toUpperCase()];
      if (!data) return { content: `Symbol ${symbol} not found`, isError: true };

      const commission = Math.max(1.0, shares * data.price * 0.001); // 0.1% 佣金
      const total = shares * data.price + (action === 'buy' ? commission : -commission);

      return {
        content: JSON.stringify(
          {
            symbol: symbol.toUpperCase(),
            action,
            shares,
            price: data.price,
            commission: commission.toFixed(2),
            total: total.toFixed(2),
            note: '这是模拟交易，不会实际执行',
          },
          null,
          2,
        ),
      };
    },
  },
];
```

### 5.2 组装金融 Agent

```typescript
import * as readline from 'readline';

async function main() {
  const agent = await Agent.create('agent.hcl');

  const session = agent.session('.', {
    tools: financeTools,
    systemPrompt: `你是一位专业的金融助理，帮助用户分析市场行情、管理投资组合、评估风险。
你可以：
- 查询股票实时报价（get_quote）
- 查看持仓和盈亏（get_portfolio）
- 评估投资风险（risk_assessment）
- 模拟交易操作（simulate_trade）

始终基于数据给出客观分析，在涉及风险时主动提示。`,
  });

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  rl.on('close', () => process.exit(0));

  console.log('金融助理已就绪。输入你的问题，例如：\n');
  console.log('  > 查一下 AAPL 和 NVDA 的报价');
  console.log('  > 分析我的持仓风险');
  console.log('  > 如果我买入 50 股 TSLA 需要多少钱？\n');

  while (true) {
    const input = await new Promise<string>((resolve) => rl.question('> ', resolve));
    if (!input.trim()) continue;

    const events = await session.stream(input);
    for await (const event of events) {
      if (event.type === 'text_delta') {
        process.stdout.write(event.text);
      } else if (event.type === 'tool_use') {
        process.stdout.write(`\n[${event.tool}] `);
      } else if (event.type === 'end') {
        console.log('\n');
      }
    }
  }
}

main().catch(console.error);
```

这个金融 Agent 的核心逻辑不到 150 行。A3S Code 处理了所有的 LLM 交互、工具路由、流式输出——你只需要定义业务工具和系统提示。

同样的模式可以直接迁移到其他领域：把金融工具换成医疗数据查询工具，就是医疗助理；换成法律文档检索工具，就是法律助理。**极简核心 + 工具自举**的价值在这里体现得最清楚。

---

## 六、从单机到多机：Lane 队列的价值

上面构建的是单机版本。当你的产品需要处理更复杂的场景时——比如同时服务多个用户、或者把计算密集型任务分发到远程机器——Lane 队列提供了解决方案。

Lane 队列把工具调用按优先级分为四个通道：

```
Control (P0) ← 控制指令，最高优先级，顺序执行
Query   (P1) ← 读文件、搜索，并行执行
Execute (P2) ← 写文件、运行命令，顺序执行
Generate(P3) ← LLM 调用，最低优先级
```

Query 通道的并行执行是关键优化：当 LLM 在一个轮次里返回多个读文件请求时，它们会并行执行，而不是串行等待。

```typescript
import { SessionQueueConfig } from '@a3s-lab/code';

const session = agent.session(process.cwd(), {
  queueConfig: {
    enableAllFeatures: true,
    queryMaxConcurrency: 8,  // 最多 8 个读操作并行
  },
});
```

当你需要把执行任务分发到远程机器时：

```typescript
// 把 Execute 通道切换为外部模式
await session.setLaneHandler('execute', {
  mode: 'external',
  timeoutMs: 120_000,
});

// 监听外部任务，分发给 Worker
const events = await session.stream('运行完整的测试套件并修复所有失败');
for await (const event of events) {
  if (event.type === 'external_task_pending') {
    const tasks = await session.pendingExternalTasks();
    for (const task of tasks) {
      // 发送给远程 Worker（你的传输层：gRPC、HTTP、消息队列等）
      const result = await dispatchToWorker(task);
      await session.completeExternalTask(task.task_id, result);
    }
  }
}
```

这个模式让你可以在不修改 Agent 逻辑的前提下，把计算密集型任务透明地分发到任意数量的远程机器。

---

## 七、结论

Agentic AI 的核心是感知—决策—行动的闭环，编码任务是这个闭环的最高密度测试场。

构建可靠的 Agentic AI 系统，需要遵循两个核心原则：

**极简核心**——系统的不可替换部分应该尽可能小，只包含驱动 LLM 轮次所必需的组件。

**工具自举**——所有扩展能力通过工具实现，LLM 是最好的工具路由器，核心代码保持不变。

在产品定位上，Claude Code 和 OpenCode 以终端交互体验为中心，为开发者设计。A3S Code 以可嵌入性为中心，为产品构建者设计。这不是竞争，是分工。

如果你在**使用**编码 Agent，Claude Code 是最成熟的选择。

如果你在**构建**包含编码 Agent 能力的产品，A3S Code 提供了你需要的基础设施——从单机的交互式助手，到多机器的分布式执行系统，都在同一套 API 之上。

---

*A3S Code 是开源的 Rust 编码 Agent 框架，提供 Rust、Node.js、Python SDK。[查看文档](/docs/code) · [GitHub](https://github.com/A3S-Lab/Code)*
