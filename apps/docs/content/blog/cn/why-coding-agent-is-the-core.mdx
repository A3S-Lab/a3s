---
title: 构建 Agentic AI 的核心原理和基础架构
description: 什么是极简核心+工具自举？编码智能体为何是 Agentic AI 的核心形态？以及如何用 A3S Code TypeScript SDK 从零构建一个类 Claude Code 的产品。
date: "2026-02-27"
author: A3S Lab
tags: [a3s-code, coding-agent, architecture, typescript, sdk]
---

软件开发者每天面对的问题，是 AI Agent 能力的最高密度测试场。读懂一个陌生代码库、定位一个隐蔽的 bug、在不破坏现有逻辑的前提下添加新功能——这些任务要求 Agent 同时具备感知、推理、行动、验证四种能力，缺一不可。

这就是为什么编码智能体不只是 AI 的一个垂直应用，而是整个 Agentic AI 领域的核心形态。本文从架构设计出发，解释构建 Agentic AI 的核心原理，介绍"极简核心 + 工具自举"这一关键设计模式，对比三种主流工具的定位差异，最后用 A3S Code TypeScript SDK 演示如何从零构建一个类 Claude Code 的产品。

---

## 一、Agent 的本质：感知—决策—行动的闭环

把所有 AI Agent 的外壳剥掉，剩下的结构只有三层：

**感知层**——读取环境状态。文件内容、命令输出、API 响应、数据库记录，都是 Agent 的感知对象。

**决策层**——基于状态推理下一步。这是 LLM 的核心职责：给定当前上下文，决定调用哪个工具、传入什么参数。

**行动层**——执行工具调用，产生副作用。写文件、运行命令、调用 API，改变外部世界的状态。

这三层构成一个循环，每次循环称为一个"轮次"（turn）。Agent 的能力，本质上是这个循环的质量：感知是否准确、决策是否合理、行动是否可靠、反馈是否及时。

代码库是这个循环的最佳训练场，原因是它提供了**客观的反馈信号**。编译器要么通过要么报错，测试要么绿要么红，没有模糊地带。这种客观性让 Agent 能够自我校正，而不依赖人类的主观判断。

一个能在代码库里自主工作的 Agent，已经具备了在任何其他结构化环境里工作的基础能力。

---

## 二、极简核心 + 工具自举

这是构建 Agentic AI 系统最重要的架构原则，也是 A3S Code 的设计基础。

### 什么是极简核心？

极简核心的意思是：**系统的不可替换部分应该尽可能小。**

一个编码 Agent 的真正核心，只有五个组件：

```
Agent          ← 配置加载、会话生命周期管理
AgentSession   ← 工作区绑定的执行上下文
AgentLoop      ← 驱动 LLM 轮次的执行引擎
ToolExecutor   ← 工具注册、调度、执行
LlmClient      ← LLM 提供商的统一抽象
```

这五个组件是系统的骨架。它们之间的关系是固定的：`Agent` 创建 `AgentSession`，`AgentSession` 持有 `AgentLoop`，`AgentLoop` 在每个轮次里调用 `LlmClient` 获取决策，再通过 `ToolExecutor` 执行工具。

这个骨架不应该随业务需求变化。它是稳定的、可测试的、可独立推理的。

### 什么是工具自举？

工具自举的意思是：**Agent 的所有扩展能力，都通过工具来实现，而不是通过修改核心。**

这个原则有两层含义：

**第一层：内置工具覆盖基础能力。** 文件读写、代码搜索、命令执行、网络请求——这些是编码 Agent 的基础动作，以内置工具的形式存在，开箱即用。

**第二层：外部工具扩展专业能力。** 数据库操作、代码审查、部署流水线、第三方 API——这些通过 MCP（Model Context Protocol）或自定义工具接入，不需要修改核心代码。

工具自举的关键洞察是：**LLM 本身就是最好的工具路由器。** 你不需要写复杂的意图识别逻辑，只需要给 LLM 提供足够清晰的工具描述，它会自己决定什么时候用什么工具。

这个设计的结果是：系统的能力边界由工具集决定，而工具集可以在运行时动态扩展，核心代码保持不变。

### 为什么这个原则重要？

考虑反面：如果你把权限控制、记忆管理、技能系统、MCP 集成都写进核心，会发生什么？

核心变得臃肿，每个新需求都需要修改核心，不同功能之间产生耦合，测试变得困难，维护成本指数级上升。

极简核心 + 工具自举把这些问题全部消解：核心只做一件事（驱动 LLM 轮次），其他一切都是可插拔的扩展。

在 A3S Code 里，这个原则体现为 19 个 trait 扩展点，每个都有默认实现：

```typescript
// 不满意默认的权限系统？实现自己的
class MyPermissionChecker implements PermissionChecker {
  async check(tool: string, args: unknown): Promise<Permission> {
    // 你的逻辑
  }
}

const session = agent.session('.', {
  permissionChecker: new MyPermissionChecker(),
});
```

系统开箱即用，任何部分都可以替换，核心保持稳定。

---

## 三、A3S Code 的完整能力边界

极简核心 + 工具自举是架构原则，但 A3S Code 的实际能力边界远不止于此。下面系统介绍所有核心特性，包括记忆系统、上下文检索、Hooks、安全层、规划器等。

### 3.1 记忆系统：跨会话的长期记忆

`MemoryStore` 让 Agent 在多次会话之间保留关键信息。不同于 `SessionStore`（保存对话历史），`MemoryStore` 存储的是**提炼后的知识**——用户偏好、项目上下文、重要决策。

```typescript
import { MemoryStore, Memory } from '@a3s-lab/code';

class VectorMemoryStore implements MemoryStore {
  async save(memory: Memory): Promise<void> {
    // 存储到向量数据库（如 Pinecone、Qdrant）
    await vectorDB.upsert({
      id: memory.id,
      vector: await embed(memory.content),
      metadata: { timestamp: memory.timestamp, tags: memory.tags },
    });
  }

  async search(query: string, limit: number): Promise<Memory[]> {
    // 语义搜索相关记忆
    const results = await vectorDB.query(await embed(query), limit);
    return results.map((r) => ({
      id: r.id,
      content: r.metadata.content,
      timestamp: r.metadata.timestamp,
      tags: r.metadata.tags,
    }));
  }
}

const session = agent.session('.', {
  memoryStore: new VectorMemoryStore(),
});

// Agent 自动从记忆中检索相关上下文
await session.stream('继续上次的重构任务');
// → Agent 检索到「上次重构目标：auth 模块改用 JWT」
```

### 3.2 上下文检索（RAG）：动态注入外部知识

`ContextProvider` 在每个轮次前自动检索相关文档，注入到 LLM 上下文。这是 RAG（Retrieval-Augmented Generation）的标准实现。

```typescript
import { ContextProvider, ContextChunk } from '@a3s-lab/code';

class CodebaseContextProvider implements ContextProvider {
  async retrieve(query: string, maxChunks: number): Promise<ContextChunk[]> {
    // 从代码库索引中检索相关代码片段
    const results = await codeSearch.search(query, maxChunks);
    return results.map((r) => ({
      content: r.code,
      source: r.filePath,
      score: r.relevance,
    }));
  }
}

const session = agent.session('.', {
  contextProvider: new CodebaseContextProvider(),
});

// 用户问题触发自动检索
await session.stream('auth 模块的 JWT 验证逻辑在哪里？');
// → ContextProvider 检索到 src/auth/jwt.ts 的相关代码
// → LLM 基于检索到的代码回答
```

### 3.3 Hooks 系统：事件驱动的自动化

Hooks 在工具调用前后自动执行，用于日志记录、审计、自动化流程。

```typescript
import { HookHandler, ToolCallEvent, ToolResultEvent } from '@a3s-lab/code';

class AuditHookHandler implements HookHandler {
  async onToolCall(event: ToolCallEvent): Promise<void> {
    // 工具调用前：记录审计日志
    await auditLog.write({
      timestamp: Date.now(),
      tool: event.tool,
      args: event.args,
      sessionId: event.sessionId,
    });

    // 高风险操作：发送通知
    if (['bash', 'write', 'delete'].includes(event.tool)) {
      await slack.notify(`⚠️ Agent 正在执行 ${event.tool}`);
    }
  }

  async onToolResult(event: ToolResultEvent): Promise<void> {
    // 工具执行后：记录结果
    await auditLog.write({
      timestamp: Date.now(),
      tool: event.tool,
      success: !event.result.isError,
      duration: event.duration,
    });
  }
}

const session = agent.session('.', {
  hookHandler: new AuditHookHandler(),
});
```

### 3.4 安全层：输入污点分析和输出净化

`SecurityProvider` 在工具执行前检测输入是否包含恶意内容，在输出前净化敏感信息。

```typescript
import { SecurityProvider, TaintAnalysis, SanitizeResult } from '@a3s-lab/code';

class ProductionSecurityProvider implements SecurityProvider {
  async analyzeTaint(input: string): Promise<TaintAnalysis> {
    // 检测命令注入、路径遍历、SQL 注入
    const threats = [];
    if (/;\s*(rm|curl|wget|nc)\s/.test(input)) threats.push('command_injection');
    if (/\.\.[\/\\]/.test(input)) threats.push('path_traversal');
    if (/(union|select|drop|insert)\s+/i.test(input)) threats.push('sql_injection');

    return {
      isTainted: threats.length > 0,
      threats,
      riskLevel: threats.length > 0 ? 'high' : 'low',
    };
  }

  async sanitizeOutput(output: string): Promise<SanitizeResult> {
    // 移除敏感信息：API key、密码、token
    let sanitized = output;
    sanitized = sanitized.replace(/sk-[a-zA-Z0-9]{48}/g, '[REDACTED_API_KEY]');
    sanitized = sanitized.replace(/password["\s:=]+[^\s"]+/gi, 'password=[REDACTED]');
    sanitized = sanitized.replace(/Bearer\s+[^\s]+/g, 'Bearer [REDACTED]');

    return { sanitized, redacted: sanitized !== output };
  }
}

const session = agent.session('.', {
  securityProvider: new ProductionSecurityProvider(),
});
```

### 3.5 规划器：复杂任务的自动分解

`Planner` 把复杂任务分解为子任务序列，Agent 按计划逐步执行。

```typescript
import { Planner, Task, Plan } from '@a3s-lab/code';

class HierarchicalPlanner implements Planner {
  async plan(goal: string, context: string): Promise<Plan> {
    // 调用 LLM 生成任务分解
    const response = await llm.complete({
      prompt: `目标：${goal}\n上下文：${context}\n\n请分解为可执行的子任务序列。`,
    });

    const tasks: Task[] = parseTasksFromResponse(response);
    return {
      goal,
      tasks,
      estimatedSteps: tasks.length,
    };
  }
}

const session = agent.session('.', {
  planner: new HierarchicalPlanner(),
});

// 复杂任务自动分解
await session.stream('重构整个 auth 模块，改用 JWT，添加 refresh token 机制，更新所有测试');
// → Planner 分解为：
//   1. 阅读现有 auth 代码
//   2. 设计 JWT + refresh token 方案
//   3. 实现新的 auth 逻辑
//   4. 更新测试
//   5. 验证所有测试通过
```

### 3.6 上下文压缩：自动管理 Token 预算

当对话历史超过阈值时，`ContextCompactor` 自动压缩旧轮次，保留关键信息。

```typescript
// 在 agent.hcl 中配置
context_compaction {
  enabled           = true
  trigger_threshold = 100000  # 超过 10 万 token 触发压缩
  target_size       = 50000   # 压缩到 5 万 token
  strategy          = "semantic"  # 语义压缩（保留关键信息）
}
```

压缩策略：
- **Truncate**：直接删除最早的轮次
- **Summarize**：用 LLM 总结旧轮次，保留摘要
- **Semantic**：基于语义相似度保留最相关的轮次

### 3.7 多语言 SDK：Rust / Node.js / Python

A3S Code 是 Rust 核心库，通过 FFI 提供 Node.js 和 Python 原生绑定。

**Rust API**（零开销，最高性能）：

```rust
use a3s_code::{Agent, AgentSession};

#[tokio::main]
async fn main() -> Result<()> {
    let agent = Agent::new("agent.hcl").await?;
    let session = agent.session("/project", None)?;

    let mut stream = session.stream("重构 auth 模块").await?;
    while let Some(event) = stream.next().await {
        match event {
            Event::TextDelta(text) => print!("{}", text),
            Event::ToolUse(tool) => println!("\n[{}]", tool.name),
            Event::End => println!(),
            _ => {}
        }
    }
    Ok(())
}
```

**Python SDK**（异步优先，类型提示）：

```python
from a3s_code import Agent, SessionLane
import asyncio

async def main():
    agent = await Agent.create("agent.hcl")
    session = agent.session(".", tools=finance_tools)

    # 并行研究
    tasks = [
        {"prompt": f"分析 {sym}", "lane": SessionLane.GENERATE}
        for sym in ["AAPL", "MSFT", "NVDA"]
    ]
    results = await session.submit_batch(tasks)
    print(results)

asyncio.run(main())
```

### 3.8 特性总结

| 特性 | 用途 | 扩展点 |
|------|------|--------|
| **记忆系统** | 跨会话长期记忆 | `MemoryStore` |
| **上下文检索** | RAG 动态注入知识 | `ContextProvider` |
| **Hooks** | 事件驱动自动化 | `HookHandler` |
| **安全层** | 输入污点分析、输出净化 | `SecurityProvider` |
| **规划器** | 复杂任务分解 | `Planner` |
| **上下文压缩** | 自动管理 token 预算 | 配置驱动 |
| **多语言 SDK** | Rust/Node.js/Python | 原生绑定 |

这些特性全部是**可选扩展**——系统有默认实现，开箱即用；如果需要定制，实现对应的 trait 即可。核心代码保持不变。

---

## 四、三种定位，三种设计哲学

市场上有三个值得认真对比的工具：Claude Code、OpenCode、A3S Code。它们都在"编码 Agent"这个标签下，但背后的设计哲学完全不同。

### Claude Code：以开发者体验为中心

Claude Code 是 Anthropic 构建的交互式 CLI 工具，设计目标是**让开发者在终端里获得最好的 AI 辅助编程体验**。

它的设计哲学是"人机协作"：Agent 提出方案，人类审批，Agent 执行，人类观察。整个交互流程围绕这个节奏设计——权限提示、计划模式、HITL 确认，都是为了让人类保持控制感。

这个定位决定了它的架构选择：它是一个 CLI 工具，不是一个库。你通过终端使用它，不能通过代码调用它。它绑定 Anthropic 的模型，因为 Anthropic 可以对自己的模型做深度优化（上下文压缩、工具调用格式、系统提示设计）。

**这个定位的边界**：当你需要把编码 Agent 能力嵌入自己的产品时，Claude Code 帮不了你。它没有编程 API，没有多租户支持，没有为程序化调用设计。

### OpenCode：以开放生态为中心

OpenCode 是开源的终端编码 Agent，设计目标是**提供一个模型无关、可自托管的 Claude Code 替代品**。

它的设计哲学是"开放优先"：支持任何 OpenAI 兼容的模型端点，代码完全开源，社区可以贡献功能和集成。

这个定位决定了它的架构选择：它同样是一个 CLI 工具，以交互式终端体验为核心。它的优势在于灵活性——你可以接入本地模型、私有部署的模型、任何兼容 API。

**这个定位的边界**：和 Claude Code 一样，它的架构以"人机交互"为中心，没有为程序化嵌入设计。如果你想在自己的应用里调用它，你面对的是一个 CLI 工具，而不是一个 SDK。

### OpenClaw：以个人助理体验为中心

OpenClaw 是面向消息平台（WhatsApp、Telegram、Slack）的个人 AI 助理 Agent，设计目标是**让用户在日常使用的聊天工具里获得智能任务自动化能力**。

它的设计哲学是\"对话即操作\"：用户通过自然语言发出指令，Agent 理解意图并执行——查询信息、管理日程、处理文件、调用外部服务。整个体验围绕消息平台的交互范式设计，而不是终端或 IDE。

这个定位决定了它的架构选择：它是一个部署在消息平台上的服务，不是一个本地工具或可嵌入的库。它的优势在于触达——用户不需要安装任何东西，在已有的聊天工具里就能使用 AI 能力。

**这个定位的边界**：它的核心是\"个人助理\"，不是\"编码智能体\"。当你需要在自己的产品里嵌入 Agent 能力，或者需要处理代码库级别的复杂任务时，它的架构不是为这个场景设计的。

### A3S Code：以可嵌入性为中心

A3S Code 解决的是一个完全不同的问题：**当你需要把编码 Agent 能力作为基础设施嵌入你的产品时，你用什么？**

它的设计哲学是"库优先"：Rust 核心库 + Node.js/Python 原生绑定，不是服务，不是 CLI，是可以被你的代码直接调用的库。

这个定位决定了它的架构选择：极简核心 + 工具自举，19 个 trait 扩展点，Lane 优先级队列，多机器任务分发，MCP 运行时动态注册。每一个设计决策都在回答同一个问题：如何让这个库在生产环境里可靠运行？

**这个定位的边界**：它不是开箱即用的终端工具。你需要写代码来集成它。如果你只是想在终端里用 AI 辅助编程，Claude Code 是更好的选择。

### 定位对比

| | Claude Code | OpenCode | OpenClaw | A3S Code |
|---|---|---|---|---|
| **核心定位** | 开发者终端工具 | 开放生态终端工具 | 消息平台个人助理 | 可嵌入 Agent 基础设施 |
| **使用方式** | CLI 交互 | CLI 交互 | 消息平台对话 | 代码调用 |
| **模型支持** | Anthropic（+ Bedrock/Vertex） | 任意 OpenAI 兼容 | 多模型 | 任意 OpenAI 兼容 |
| **可嵌入性** | 无编程 API | 无编程 API | 无编程 API | 核心设计目标 |
| **扩展方式** | MCP + Skills + Hooks | MCP + 插件 | 插件 | Trait 扩展点 + MCP |
| **多租户** | 不支持 | 不支持 | 不支持 | 支持 |
| **并行任务** | 子 Agent 并行 | 有限支持 | 不支持 | Lane 队列 + 多机器分发 |
| **开源** | 否 | 是 | 否 | 是 |

这不是功能优劣的对比，是设计目标的对比。四个工具在各自的定位上都有其价值。

---

## 五、用 TypeScript SDK 构建类 Claude Code 的产品

理解了架构原则，现在来实践。我们用 A3S Code 的 TypeScript SDK 构建一个具备 Claude Code 核心能力的终端编码助手。

目标产品具备：
- 多轮对话，理解代码库上下文
- 流式输出，实时显示 Agent 思考过程
- 工具执行（读文件、写文件、运行命令）
- 权限控制，敏感操作需要用户确认
- MCP 服务器支持，动态扩展工具集
- 会话持久化，支持恢复上次对话

### 4.1 安装和配置

```bash
npm install @a3s-lab/code
```

创建 `agent.hcl` 配置文件：

```hcl
# 支持任何 OpenAI 兼容端点
default_model = "anthropic/claude-sonnet-4-20250514"

providers {
  name    = "anthropic"
  api_key = env("ANTHROPIC_API_KEY")
}

# 可选：接入 MCP 服务器
mcp_servers {
  name    = "filesystem"
  command = "npx"
  args    = ["-y", "@modelcontextprotocol/server-filesystem", "."]
}
```

### 4.2 核心会话循环

这是整个产品的骨架——一个读取用户输入、流式输出 Agent 响应的循环：

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';

const agent = await Agent.create('agent.hcl');
const session = agent.session(process.cwd());

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function prompt(): Promise<string> {
  return new Promise((resolve) => {
    rl.question('\n> ', resolve);
  });
}

console.log('A3S Code — 输入你的问题，Ctrl+C 退出\n');

while (true) {
  const input = await prompt();
  if (!input.trim()) continue;

  // 流式输出：实时显示 Agent 的每一个字
  const events = await session.stream(input);

  for await (const event of events) {
    switch (event.type) {
      case 'text_delta':
        process.stdout.write(event.text);
        break;

      case 'tool_use':
        // 显示工具调用，让用户知道 Agent 在做什么
        console.log(`\n[工具] ${event.tool}(${JSON.stringify(event.args)})`);
        break;

      case 'tool_result':
        // 工具执行完成，可以选择显示结果摘要
        break;

      case 'end':
        console.log('\n');
        break;
    }
  }
}
```

### 4.3 添加权限控制

Claude Code 的一个核心设计是：危险操作需要用户确认。我们用 A3S Code 的权限系统实现同样的效果：

```typescript
import { Agent, PermissionChecker, Permission } from '@a3s-lab/code';
import * as readline from 'readline';

// 需要确认的高风险工具
const DANGEROUS_TOOLS = new Set(['bash', 'write', 'edit', 'patch']);

class InteractivePermissionChecker implements PermissionChecker {
  private rl: readline.Interface;

  constructor(rl: readline.Interface) {
    this.rl = rl;
  }

  async check(tool: string, args: unknown): Promise<Permission> {
    // 只读工具直接放行
    if (!DANGEROUS_TOOLS.has(tool)) {
      return Permission.Allow;
    }

    // 显示将要执行的操作
    const preview = this.formatPreview(tool, args);
    console.log(`\n⚠️  Agent 想要执行：\n${preview}`);

    const answer = await new Promise<string>((resolve) => {
      this.rl.question('允许？[y/N] ', resolve);
    });

    return answer.toLowerCase() === 'y' ? Permission.Allow : Permission.Deny;
  }

  private formatPreview(tool: string, args: unknown): string {
    const a = args as Record<string, unknown>;
    switch (tool) {
      case 'bash':
        return `  $ ${a.command}`;
      case 'write':
        return `  写入文件: ${a.file_path}`;
      case 'edit':
        return `  编辑文件: ${a.file_path}`;
      default:
        return `  ${tool}: ${JSON.stringify(args, null, 2)}`;
    }
  }
}

// 集成到 session
const session = agent.session(process.cwd(), {
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.4 添加 MCP 服务器动态注册

Claude Code 支持在配置文件里声明 MCP 服务器。A3S Code 还支持在运行时动态注册，这让你可以根据用户的项目类型按需加载工具：

```typescript
// 检测项目类型，按需加载 MCP 服务器
async function loadProjectMcpServers(session: AgentSession, projectPath: string) {
  const fs = await import('fs/promises');

  // 检测到 package.json → 加载 Node.js 相关工具
  try {
    await fs.access(`${projectPath}/package.json`);
    const count = await session.addMcpServer(
      'nodejs-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] 加载 Node.js 工具集，${count} 个工具可用`);
  } catch {}

  // 检测到 Cargo.toml → 加载 Rust 相关工具
  try {
    await fs.access(`${projectPath}/Cargo.toml`);
    const count = await session.addMcpServer(
      'rust-tools',
      'npx',
      ['-y', '@modelcontextprotocol/server-filesystem', projectPath],
    );
    console.log(`[MCP] 加载 Rust 工具集，${count} 个工具可用`);
  } catch {}
}
```

### 4.5 添加会话持久化

Claude Code 支持恢复上次会话。A3S Code 通过 `SessionStore` trait 实现同样的能力：

```typescript
import { SessionStore, SessionData } from '@a3s-lab/code';
import * as fs from 'fs/promises';
import * as path from 'path';

class FileSessionStore implements SessionStore {
  private storePath: string;

  constructor(storePath: string) {
    this.storePath = storePath;
  }

  async save(sessionId: string, data: SessionData): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.mkdir(this.storePath, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
  }

  async load(sessionId: string): Promise<SessionData | null> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  async delete(sessionId: string): Promise<void> {
    const filePath = path.join(this.storePath, `${sessionId}.json`);
    await fs.unlink(filePath).catch(() => {});
  }
}

// 使用项目目录作为会话 ID，实现"每个项目一个会话"
const projectId = Buffer.from(process.cwd()).toString('base64url');
const session = agent.session(process.cwd(), {
  sessionId: projectId,
  sessionStore: new FileSessionStore(path.join(process.env.HOME!, '.a3s/sessions')),
  permissionChecker: new InteractivePermissionChecker(rl),
});
```

### 4.6 添加斜杠命令

Claude Code 有 `/help`、`/clear`、`/cost` 等内置命令。A3S Code 的 `SlashCommand` 接口让你实现同样的功能：

```typescript
import { SlashCommand, CommandContext, CommandOutput } from '@a3s-lab/code';

// /cost 命令：显示本次会话的 token 消耗
class CostCommand implements SlashCommand {
  name = 'cost';
  description = '显示本次会话的 token 消耗和估算费用';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    const usage = ctx.tokenUsage;
    // Claude Sonnet 4 定价（仅供参考）
    const inputCost = (usage.promptTokens / 1_000_000) * 3.0;
    const outputCost = (usage.completionTokens / 1_000_000) * 15.0;
    const total = inputCost + outputCost;

    return CommandOutput.text(
      `Token 消耗：\n` +
      `  输入：${usage.promptTokens.toLocaleString()} tokens ($${inputCost.toFixed(4)})\n` +
      `  输出：${usage.completionTokens.toLocaleString()} tokens ($${outputCost.toFixed(4)})\n` +
      `  合计：$${total.toFixed(4)}`
    );
  }
}

// /clear 命令：清空对话历史
class ClearCommand implements SlashCommand {
  name = 'clear';
  description = '清空对话历史，开始新会话';

  execute(_args: string, ctx: CommandContext): CommandOutput {
    ctx.clearHistory();
    return CommandOutput.text('对话历史已清空');
  }
}

session.registerCommand(new CostCommand());
session.registerCommand(new ClearCommand());
```

### 4.7 完整产品组装

把所有部分组合起来：

```typescript
import { Agent } from '@a3s-lab/code';
import * as readline from 'readline';
import * as path from 'path';

async function main() {
  const agent = await Agent.create('agent.hcl');

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
  });

  // 处理 Ctrl+C
  rl.on('close', () => {
    console.log('\n再见！');
    process.exit(0);
  });

  const projectId = Buffer.from(process.cwd()).toString('base64url');

  const session = agent.session(process.cwd(), {
    sessionId: projectId,
    sessionStore: new FileSessionStore(
      path.join(process.env.HOME!, '.a3s/sessions')
    ),
    permissionChecker: new InteractivePermissionChecker(rl),
  });

  // 注册命令
  session.registerCommand(new CostCommand());
  session.registerCommand(new ClearCommand());

  // 按需加载 MCP 服务器
  await loadProjectMcpServers(session, process.cwd());

  // 显示欢迎信息
  const isResumed = await session.hasHistory();
  if (isResumed) {
    console.log('✓ 已恢复上次会话。输入 /clear 开始新对话。\n');
  } else {
    console.log('A3S Code — 输入你的问题，/help 查看命令，Ctrl+C 退出\n');
  }

  // 主循环
  while (true) {
    const input = await new Promise<string>((resolve) => {
      rl.question('> ', resolve);
    });

    if (!input.trim()) continue;

    // 斜杠命令
    if (input.startsWith('/')) {
      const output = await session.executeCommand(input);
      console.log(output.text);
      continue;
    }

    // Agent 流式响应
    try {
      const events = await session.stream(input);
      for await (const event of events) {
        if (event.type === 'text_delta') {
          process.stdout.write(event.text);
        } else if (event.type === 'tool_use') {
          process.stdout.write(`\n[${event.tool}] `);
        } else if (event.type === 'end') {
          console.log('\n');
        }
      }
    } catch (err) {
      console.error(`\n错误：${err instanceof Error ? err.message : err}\n`);
    }
  }
}

main().catch(console.error);
```

这个产品已经具备了 Claude Code 的核心能力：多轮对话、流式输出、工具执行、权限控制、MCP 支持、会话持久化、斜杠命令。代码量不到 200 行。

---

## 六、用编码智能体构建 Agentic 金融应用

编码智能体不只是为开发者服务的工具——它是构建任何领域 Agentic 应用的基础设施。真正的 Agentic 应用和普通聊天机器人的区别在于：它能自主规划、并行执行、协调多个专业 Agent 协作，而不只是被动响应单条指令。

下面用 A3S Code TypeScript SDK 构建一个金融研究系统，展示四个核心 Agentic 特性：**技能系统**、**自动规划**、**Agent Team** 和**并行研究分析**。

### 5.1 技能系统：定义专业行为规范

技能（Skill）是 Markdown 格式的行为规范文件，告诉 Agent 在特定场景下应该遵循什么流程。它不是代码，而是结构化的专业知识。

```markdown
<!-- skills/portfolio_analyst.md -->
# 投资组合分析师

## 分析流程

收到投资组合分析请求时，**必须**按以下顺序执行，不得跳过任何步骤：

1. **数据收集**：调用 get_portfolio 获取所有持仓，调用 get_quote 获取实时报价
2. **并行研究**：对每只持仓股票同时启动独立分析任务（使用 submit_batch）
3. **风险评估**：计算组合整体波动率、集中度风险、相关性
4. **生成报告**：输出结构化报告，包含持仓概览、风险评级、调仓建议

## 报告格式

\`\`\`
## 投资组合分析报告
**分析时间**: {timestamp}
**总市值**: ${total_value}  **总盈亏**: ${total_pnl} ({pnl_pct}%)

### 持仓明细
| 股票 | 持仓 | 成本 | 现价 | 盈亏 | 风险 |
...

### 风险评估
- 组合集中度: {concentration}
- 最高风险持仓: {symbol}
- 建议: {recommendation}
\`\`\`

## 注意事项
- 所有建议必须基于数据，不得主观臆断
- 高风险持仓必须在报告中明确标注
- 调仓建议需说明理由
```

在 HCL 配置中加载技能：

```hcl
# agent.hcl
default_model = "anthropic/claude-sonnet-4-20250514"

providers {
  name    = "anthropic"
  api_key = env("ANTHROPIC_API_KEY")
}

# 加载技能文件目录
skills_dir = "./skills"
```

技能系统的价值在于**可复用的专业知识**：同一套分析流程可以被不同的 Agent 实例加载，确保行为一致性，也方便团队协作维护。

### 5.2 自动规划：一句话触发完整分析流程

当用户说「帮我做一份完整的投资组合分析」时，Agent 不会直接回答——它会先**规划**，再**执行**。

```typescript
import { Agent, SessionLane } from '@a3s-lab/code';

const agent = await Agent.create('agent.hcl');

// 加载投资组合分析师技能
const session = agent.session('.', {
  tools: financeTools,
  skills: ['portfolio_analyst'],  // 注入专业行为规范
});

// 用户只需一句话，Agent 自动规划并执行完整流程：
// 1. 调用 get_portfolio 获取持仓
// 2. 调用 get_quote 批量获取报价
// 3. 启动并行研究任务（每只股票独立分析）
// 4. 汇总结果，生成结构化报告
const events = await session.stream(
  '帮我做一份完整的投资组合分析，重点关注风险敞口和调仓建议'
);

for await (const event of events) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  else if (event.type === 'tool_use') console.log(`\n→ [${event.tool}]`);
  else if (event.type === 'end') console.log('\n');
}
```

这里的关键是：**技能文件定义了规划逻辑，Agent 自主决定调用顺序和工具组合**。你不需要写任何编排代码。

### 5.3 并行研究：同时分析多只股票

对多只股票做深度研究时，串行执行会很慢。`submitBatch` 让多个分析任务并行运行，结果统一汇总。

```typescript
import { Agent, SessionLane } from '@a3s-lab/code';

async function parallelStockResearch(symbols: string[]) {
  const agent = await Agent.create('agent.hcl');
  const session = agent.session('.', { tools: financeTools });

  // 为每只股票创建独立的深度研究任务，全部并行执行
  const researchTasks = symbols.map((sym) => ({
    prompt: `对 ${sym} 进行深度分析：
      1. 获取实时报价和成交量
      2. 评估当前风险等级
      3. 基于数据给出买入/持有/卖出建议
      输出结构化 JSON 结果。`,
    lane: SessionLane.Generate,  // 路由到 Generate 通道并行执行
  }));

  console.log(`启动 ${symbols.length} 个并行研究任务...`);
  const results = await session.submitBatch(researchTasks);

  // 所有任务完成后，交给汇总 Agent 生成综合报告
  const summarySession = agent.session('.', { tools: financeTools });
  const summaryEvents = await summarySession.stream(
    `以下是对各股票的独立研究结果：\n${JSON.stringify(results, null, 2)}\n\n` +
    `请综合以上分析，生成一份投资组合优化建议报告，` +
    `包含风险分散建议和仓位调整方案。`
  );

  for await (const event of summaryEvents) {
    if (event.type === 'text_delta') process.stdout.write(event.text);
    else if (event.type === 'end') console.log('\n');
  }
}

// 并行研究 4 只股票，耗时约等于单只股票的分析时间
await parallelStockResearch(['AAPL', 'MSFT', 'NVDA', 'TSLA']);
```

### 5.4 Agent Team：专业分工协作

复杂的金融分析需要不同专业能力的协作。Agent Team 让你把任务分配给专门的 Worker Agent，由 Lead Agent 统一协调。

```typescript
import { Agent, AgentTeam } from '@a3s-lab/code';

async function buildFinanceTeam() {
  // Lead Agent：接收用户请求，规划任务，分配给 Worker，汇总结果
  const lead = await Agent.create('agent.hcl');
  const leadSession = lead.session('.', {
    tools: financeTools,
    skills: ['portfolio_analyst'],
    role: 'lead',
  });

  // Worker 1：市场分析师，专注行情数据和技术指标
  const marketAnalyst = await Agent.create('agent.hcl');
  const marketSession = marketAnalyst.session('.', {
    tools: [financeTools.find((t) => t.name === 'get_quote')!],
    systemPrompt: '你是市场分析师，专注于股票行情数据、成交量分析和价格趋势。',
    role: 'worker',
    workerId: 'market_analyst',
  });

  // Worker 2：风险分析师，专注风险评估和压力测试
  const riskAnalyst = await Agent.create('agent.hcl');
  const riskSession = riskAnalyst.session('.', {
    tools: [financeTools.find((t) => t.name === 'risk_assessment')!],
    systemPrompt: '你是风险分析师，专注于波动率计算、风险敞口评估和压力测试。',
    role: 'worker',
    workerId: 'risk_analyst',
  });

  // 组建 Team，Lead 可以把子任务委派给 Worker
  const team = AgentTeam.create({
    lead: leadSession,
    workers: [marketSession, riskSession],
  });

  // Lead 接收用户请求，自动决定哪些子任务交给哪个 Worker
  // 例如：行情数据 → market_analyst，风险计算 → risk_analyst
  // 两个 Worker 并行工作，Lead 汇总结果后回复用户
  const events = await team.stream(
    '分析我的持仓，市场分析师负责行情，风险分析师负责风险评估，最后给我综合建议'
  );

  for await (const event of events) {
    if (event.type === 'text_delta') process.stdout.write(event.text);
    else if (event.type === 'worker_started') {
      console.log(`\n[Team] ${event.workerId} 开始工作...`);
    } else if (event.type === 'worker_completed') {
      console.log(`\n[Team] ${event.workerId} 完成`);
    } else if (event.type === 'end') {
      console.log('\n');
    }
  }
}

buildFinanceTeam().catch(console.error);
```

### 5.5 完整系统：四个特性协同工作

把以上特性组合成一个完整的金融研究终端：

```typescript
import { Agent, AgentTeam, SessionLane } from '@a3s-lab/code';
import * as readline from 'readline';

async function main() {
  const agent = await Agent.create('agent.hcl');
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  rl.on('close', () => process.exit(0));

  // 主会话：加载技能，具备自动规划能力
  const session = agent.session('.', {
    tools: financeTools,
    skills: ['portfolio_analyst'],
    role: 'lead',
    queueConfig: { queryMaxConcurrency: 4 },  // Query 通道最多 4 个并行
  });

  // 注册斜杠命令
  session.registerCommand({
    name: 'research',
    description: '并行研究多只股票，用法: /research AAPL MSFT NVDA',
    execute: async (args) => {
      const symbols = args.trim().split(/\s+/).filter(Boolean);
      if (symbols.length === 0) return { text: '用法: /research AAPL MSFT NVDA' };

      console.log(`\n启动 ${symbols.length} 个并行研究任务...\n`);
      const tasks = symbols.map((sym) => ({
        prompt: `分析 ${sym}：报价、风险等级、投资建议`,
        lane: SessionLane.Generate,
      }));

      const results = await session.submitBatch(tasks);
      return { text: JSON.stringify(results, null, 2) };
    },
  });

  console.log('金融研究系统就绪。\n');
  console.log('  > 帮我做一份完整的投资组合分析        (自动规划 + 技能系统)');
  console.log('  > /research AAPL MSFT NVDA TSLA       (并行研究)');
  console.log('  > 组建分析团队，深度研究科技股板块     (Agent Team)\n');

  while (true) {
    const input = await new Promise<string>((resolve) => rl.question('> ', resolve));
    if (!input.trim()) continue;

    if (input.startsWith('/')) {
      const output = await session.executeCommand(input);
      console.log(output.text + '\n');
      continue;
    }

    const events = await session.stream(input);
    for await (const event of events) {
      if (event.type === 'text_delta') process.stdout.write(event.text);
      else if (event.type === 'tool_use') process.stdout.write(`\n→ [${event.tool}] `);
      else if (event.type === 'end') console.log('\n');
    }
  }
}

main().catch(console.error);
```

这个系统和普通聊天机器人的本质区别：用户说一句「做完整分析」，系统会**自主规划步骤**、**并行执行研究**、**协调多个专业 Agent**，最后汇总成结构化报告——整个过程不需要用户逐步指导。这才是 Agentic 应用的核心价值。

---

## 七、从单机到多机：Lane 队列的价值

上面构建的是单机版本。当你的产品需要处理更复杂的场景时——比如同时服务多个用户、或者把计算密集型任务分发到远程机器——Lane 队列提供了解决方案。

Lane 队列把工具调用按优先级分为四个通道：

```
Control (P0) ← 控制指令，最高优先级，顺序执行
Query   (P1) ← 读文件、搜索，并行执行
Execute (P2) ← 写文件、运行命令，顺序执行
Generate(P3) ← LLM 调用，最低优先级
```

Query 通道的并行执行是关键优化：当 LLM 在一个轮次里返回多个读文件请求时，它们会并行执行，而不是串行等待。

```typescript
import { SessionQueueConfig } from '@a3s-lab/code';

const session = agent.session(process.cwd(), {
  queueConfig: {
    enableAllFeatures: true,
    queryMaxConcurrency: 8,  // 最多 8 个读操作并行
  },
});
```

当你需要把执行任务分发到远程机器时：

```typescript
// 把 Execute 通道切换为外部模式
await session.setLaneHandler('execute', {
  mode: 'external',
  timeoutMs: 120_000,
});

// 监听外部任务，分发给 Worker
const events = await session.stream('运行完整的测试套件并修复所有失败');
for await (const event of events) {
  if (event.type === 'external_task_pending') {
    const tasks = await session.pendingExternalTasks();
    for (const task of tasks) {
      // 发送给远程 Worker（你的传输层：gRPC、HTTP、消息队列等）
      const result = await dispatchToWorker(task);
      await session.completeExternalTask(task.task_id, result);
    }
  }
}
```

这个模式让你可以在不修改 Agent 逻辑的前提下，把计算密集型任务透明地分发到任意数量的远程机器。

---

## 八、结论

Agentic AI 的核心是感知—决策—行动的闭环，编码任务是这个闭环的最高密度测试场。

构建可靠的 Agentic AI 系统，需要遵循两个核心原则：

**极简核心**——系统的不可替换部分应该尽可能小，只包含驱动 LLM 轮次所必需的组件。

**工具自举**——所有扩展能力通过工具实现，LLM 是最好的工具路由器，核心代码保持不变。

在产品定位上，Claude Code 和 OpenCode 以终端交互体验为中心，为开发者设计。A3S Code 以可嵌入性为中心，为产品构建者设计。这不是竞争，是分工。

如果你在**使用**编码 Agent，Claude Code 是最成熟的选择。

如果你在**构建**包含编码 Agent 能力的产品，A3S Code 提供了你需要的基础设施——从单机的交互式助手，到多机器的分布式执行系统，都在同一套 API 之上。

---

*A3S Code 是开源的 Rust 编码 Agent 框架，提供 Rust、Node.js、Python SDK。[查看文档](/docs/code) · [GitHub](https://github.com/A3S-Lab/Code)*
