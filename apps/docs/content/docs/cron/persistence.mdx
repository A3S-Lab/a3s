---
title: Persistence
description: File-based and in-memory storage backends for jobs and execution history
---

# Persistence

A3S Cron uses a pluggable `CronStore` trait for persisting jobs and execution history. Two implementations are included: `FileCronStore` for production and `MemoryCronStore` for testing.

## CronStore Trait

```rust
#[async_trait]
pub trait CronStore: Send + Sync {
    async fn save_job(&self, job: &CronJob) -> Result<()>;
    async fn load_job(&self, id: &str) -> Result<Option<CronJob>>;
    async fn delete_job(&self, id: &str) -> Result<()>;
    async fn list_jobs(&self) -> Result<Vec<CronJob>>;
    async fn job_exists(&self, id: &str) -> Result<bool>;
    async fn find_job_by_name(&self, name: &str) -> Result<Option<CronJob>>;
    async fn save_execution(&self, execution: &JobExecution) -> Result<()>;
    async fn load_executions(&self, job_id: &str, limit: usize) -> Result<Vec<JobExecution>>;
    async fn delete_executions(&self, job_id: &str) -> Result<()>;
}
```

## FileCronStore

JSON file-based storage with atomic writes. Used by default when creating a `CronManager`.

```rust
use a3s_cron::FileCronStore;

let store = FileCronStore::new("/home/user").await?;
```

### Storage Layout

```
{workspace}/.a3s/cron/
├── jobs.json                        # All job definitions (JSON array)
└── history/
    ├── {job-id-1}/
    │   ├── 1707734400000.json       # Execution at timestamp
    │   ├── 1707734460000.json
    │   └── ...
    └── {job-id-2}/
        └── ...
```

### Atomic Writes

All file writes use a temp-file-then-rename strategy to prevent corruption:

1. Write data to `{path}.tmp`
2. Call `file.sync_all()` (fsync)
3. Rename `{path}.tmp` to `{path}` (atomic on POSIX)

### Directory Auto-Creation

`FileCronStore::new()` creates the directory structure if it doesn't exist.

### Path Safety

Job IDs are sanitized before use in file paths — characters like `/`, `\`, and `..` are replaced to prevent path traversal.

### Cascade Deletion

`delete_job()` removes both the job definition and all its execution history files.

## MemoryCronStore

HashMap-based in-memory storage for testing. No persistence across restarts.

```rust
use a3s_cron::MemoryCronStore;

let store = MemoryCronStore::new();
```

## Using a Custom Store

Pass a custom store to `CronManager`:

```rust
use a3s_cron::CronManager;
use std::sync::Arc;

let store = Arc::new(MyPostgresStore::new(pool).await?);
let manager = CronManager::with_store(store, "/workspace".into());
```

### Custom Store Example

```rust
use a3s_cron::{CronStore, CronJob, JobExecution, Result};
use async_trait::async_trait;

struct PostgresStore {
    pool: sqlx::PgPool,
}

#[async_trait]
impl CronStore for PostgresStore {
    async fn save_job(&self, job: &CronJob) -> Result<()> {
        sqlx::query("INSERT INTO cron_jobs ...")
            .bind(&job.id)
            .bind(&job.name)
            .bind(&job.schedule)
            .bind(&job.command)
            .execute(&self.pool)
            .await
            .map_err(|e| CronError::Storage(e.to_string()))?;
        Ok(())
    }

    async fn load_job(&self, id: &str) -> Result<Option<CronJob>> {
        // ...
    }

    async fn delete_job(&self, id: &str) -> Result<()> {
        // ...
    }

    async fn list_jobs(&self) -> Result<Vec<CronJob>> {
        // ...
    }

    async fn job_exists(&self, id: &str) -> Result<bool> {
        // ...
    }

    async fn find_job_by_name(&self, name: &str) -> Result<Option<CronJob>> {
        // ...
    }

    async fn save_execution(&self, execution: &JobExecution) -> Result<()> {
        // ...
    }

    async fn load_executions(&self, job_id: &str, limit: usize)
        -> Result<Vec<JobExecution>> {
        // ...
    }

    async fn delete_executions(&self, job_id: &str) -> Result<()> {
        // ...
    }
}
```

## Data Durability

| Aspect | FileCronStore | MemoryCronStore |
|--------|--------------|-----------------|
| Survives restart | Yes | No |
| Atomic writes | Yes (temp + rename) | N/A |
| fsync | Yes | N/A |
| Concurrent access | File-level locking | Mutex |
| Use case | Production | Testing |
