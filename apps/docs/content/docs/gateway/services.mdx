---
title: Services
description: Load balancing strategies, health checks, sticky sessions, and backend management
---

# Services

Services define backend pools with load balancing, health checks, and sticky sessions.

## Service Configuration

```rust
pub struct ServiceConfig {
    pub load_balancer: LoadBalancerConfig,
}

pub struct LoadBalancerConfig {
    pub strategy: Strategy,
    pub servers: Vec<ServerConfig>,
    pub health_check: Option<HealthCheckConfig>,
    pub sticky: Option<StickyConfig>,
}

pub struct ServerConfig {
    pub url: String,
    pub weight: u32,
}
```

## Load Balancing Strategies

```rust
pub enum Strategy {
    RoundRobin,
    Weighted,
    LeastConnections,
    Random,
}
```

### Round Robin

Cycles through healthy backends sequentially:

```toml
[services.my-service.load_balancer]
strategy = "round-robin"
[[services.my-service.load_balancer.servers]]
url = "http://127.0.0.1:8001"
[[services.my-service.load_balancer.servers]]
url = "http://127.0.0.1:8002"
[[services.my-service.load_balancer.servers]]
url = "http://127.0.0.1:8003"
```

### Weighted

Distributes traffic proportionally by weight:

```toml
[services.my-service.load_balancer]
strategy = "weighted"
[[services.my-service.load_balancer.servers]]
url = "http://127.0.0.1:8001"
weight = 3
[[services.my-service.load_balancer.servers]]
url = "http://127.0.0.1:8002"
weight = 1
```

Server 8001 receives ~75% of traffic, server 8002 receives ~25%.

### Least Connections

Routes to the backend with the fewest active connections:

```toml
[services.my-service.load_balancer]
strategy = "least-connections"
```

### Random

Selects a random healthy backend:

```toml
[services.my-service.load_balancer]
strategy = "random"
```

## Backend

```rust
pub struct Backend {
    pub url: String,
    pub weight: u32,
    healthy: AtomicBool,
    active_connections: AtomicUsize,
}

impl Backend {
    pub fn is_healthy(&self) -> bool;
    pub fn set_healthy(&self, healthy: bool);
    pub fn inc_connections(&self);
    pub fn dec_connections(&self);
    pub fn connections(&self) -> usize;
}
```

Unhealthy backends are automatically excluded from load balancing.

## Health Checks

```rust
pub struct HealthCheckConfig {
    pub path: String,
    pub interval: String,
    pub timeout: String,
    pub unhealthy_threshold: u32,
    pub healthy_threshold: u32,
}
```

```toml
[services.my-service.load_balancer.health_check]
path = "/health"
interval = "10s"
timeout = "5s"
unhealthy_threshold = 3
healthy_threshold = 1
```

| Field | Description |
|-------|-------------|
| `path` | HTTP GET path to probe |
| `interval` | Time between checks |
| `timeout` | Max wait for response |
| `unhealthy_threshold` | Consecutive failures before marking unhealthy |
| `healthy_threshold` | Consecutive successes before marking healthy |

A backend is marked unhealthy after `unhealthy_threshold` consecutive failed checks, and healthy again after `healthy_threshold` consecutive successes.

## Sticky Sessions

Route the same client to the same backend using cookies:

```rust
pub struct StickyConfig {
    pub cookie: String,
    pub ttl: Option<String>,
}
```

```toml
[services.my-service.load_balancer.sticky]
cookie = "srv_id"
ttl = "1h"
```

On the first request, the gateway selects a backend and sets a `Set-Cookie` header. Subsequent requests with that cookie are routed to the same backend.

## Service Registry

```rust
pub struct ServiceRegistry {
    services: HashMap<String, Arc<LoadBalancer>>,
}

impl ServiceRegistry {
    pub fn from_config(services: &HashMap<String, ServiceConfig>) -> Result<Self>;
    pub async fn start_health_checks(&self, configs: &HashMap<String, ServiceConfig>);
    pub fn get(&self, name: &str) -> Option<Arc<LoadBalancer>>;
    pub fn len(&self) -> usize;
}
```

The registry is rebuilt on configuration reload. Health check tasks are spawned as background Tokio tasks.
