---
title: 可扩展性
description: 限流、优先级提升、队列分区和分布式队列
---

import { TypeTable } from 'fumadocs-ui/components/type-table';

# 可扩展性

A3S Lane 提供从单核原型扩展到多核和多机部署的功能：限流、优先级提升、队列分区和分布式队列接口。

## 限流

使用令牌桶或滑动窗口算法控制每个 lane 的命令吞吐量。

### 令牌桶

```rust
// 每秒 100 个命令
let config = LaneConfig::new(1, 10)
    .with_rate_limit(RateLimitConfig::per_second(100));

// 每分钟 1000 个命令
let config = LaneConfig::new(1, 10)
    .with_rate_limit(RateLimitConfig::per_minute(1000));

// 每小时 10000 个命令
let config = LaneConfig::new(1, 10)
    .with_rate_limit(RateLimitConfig::per_hour(10000));
```

令牌桶提供平滑限流——令牌以恒定速率补充，每个命令消耗一个令牌。若无可用令牌，命令将等待。

## 优先级提升

通过在截止时间临近时自动提升低优先级命令的优先级，防止其饥饿。

### 标准提升

在截止时间的 25%、50%、75% 处提升：

```rust
let config = LaneConfig::new(1, 10)
    .with_priority_boost(PriorityBoostConfig::standard(Duration::from_secs(60)));
```

对于 60 秒截止时间：
- 15s 时：第一次提升
- 30s 时：第二次提升
- 45s 时：第三次提升（接近最高优先级）

### 激进提升

针对时间敏感型工作负载，更频繁地升级：

```rust
let config = LaneConfig::new(1, 10)
    .with_priority_boost(PriorityBoostConfig::aggressive(Duration::from_secs(30)));
```

### 自定义提升间隔

定义精确的提升时间点：

```rust
let config = LaneConfig::new(1, 10)
    .with_priority_boost(PriorityBoostConfig::custom(
        Duration::from_secs(120),
        vec![
            Duration::from_secs(30),  // 30s 时第一次提升
            Duration::from_secs(60),  // 60s 时第二次提升
            Duration::from_secs(90),  // 90s 时第三次提升
        ],
    ));
```

## 队列分区

将命令分散到多个分区，实现多核并行。

### 分区策略

```rust
use a3s_lane::PartitionConfig;

// 自动：每个 CPU 核心一个分区
let config = PartitionConfig::auto();

// 轮询：将命令均匀分配到 N 个分区
let config = PartitionConfig::round_robin(4);

// 哈希：相同命令类型始终路由到同一分区
let config = PartitionConfig::hash(4);

// 无分区：单一分区（默认）
let config = PartitionConfig::none();
```

### 策略对比

<TypeTable
  type={{
    "None": {
      description: "分布方式：单队列 · 顺序：严格 FIFO · 适用场景：简单工作负载",
    },
    "RoundRobin": {
      description: "分布方式：均匀分散 · 顺序：分区内 FIFO · 适用场景：均衡吞吐量",
    },
    "Hash": {
      description: "分布方式：按命令类型 · 顺序：按类型 FIFO · 适用场景：类型亲和性（缓存）",
    },
    "Auto": {
      description: "分布方式：按核心 · 顺序：分区内 FIFO · 适用场景：最大并行度",
    },
  }}
/>

## 分布式队列

多机部署时，实现 `DistributedQueue` trait：

```rust
use a3s_lane::{DistributedQueue, CommandEnvelope, CommandResult};

#[async_trait]
pub trait DistributedQueue: Send + Sync {
    async fn enqueue(&self, envelope: CommandEnvelope) -> Result<()>;
    async fn dequeue(&self, partition_id: PartitionId) -> Result<Option<CommandEnvelope>>;
    async fn complete(&self, result: CommandResult) -> Result<()>;
    fn num_partitions(&self) -> usize;
    fn worker_id(&self) -> WorkerId;
}
```

### 本地实现

用于单机多核并行：

```rust
use a3s_lane::LocalDistributedQueue;

// 自动检测 CPU 核心数
let queue = LocalDistributedQueue::auto();

// 显式指定分区数
let queue = LocalDistributedQueue::new(PartitionConfig::round_robin(8));
```

### 自定义实现

为 Redis、Kafka 或其他消息代理实现 `DistributedQueue`：

```rust
struct RedisDistributedQueue {
    client: redis::Client,
    worker_id: WorkerId,
    partitions: usize,
}

#[async_trait]
impl DistributedQueue for RedisDistributedQueue {
    async fn enqueue(&self, envelope: CommandEnvelope) -> Result<()> {
        let partition = envelope.partition_id % self.partitions;
        let key = format!("lane:partition:{}", partition);
        // LPUSH to Redis list
        Ok(())
    }

    async fn dequeue(&self, partition_id: PartitionId) -> Result<Option<CommandEnvelope>> {
        let key = format!("lane:partition:{}", partition_id);
        // BRPOP from Redis list
        Ok(None)
    }

    async fn complete(&self, result: CommandResult) -> Result<()> {
        // Store result, notify waiters
        Ok(())
    }

    fn num_partitions(&self) -> usize { self.partitions }
    fn worker_id(&self) -> WorkerId { self.worker_id }
}
```

## 扩展建议

### 单机

```rust
// 小型工作负载：默认 lanes，无分区
let manager = QueueManagerBuilder::new(emitter)
    .with_default_lanes()
    .build()
    .await?;

// 高吞吐量：限流 + 指标
let manager = QueueManagerBuilder::new(emitter)
    .with_lane("api", LaneConfig::new(2, 20)
        .with_rate_limit(RateLimitConfig::per_second(1000)), 0)
    .with_metrics(QueueMetrics::local())
    .build()
    .await?;
```

### 多核

```rust
// 对 CPU 密集型工作负载使用自动分区
let queue = LocalDistributedQueue::auto();
```

### 生产环境检查清单

<TypeTable
  type={{
    "重试策略": {
      description: "始终配置（至少使用 exponential(2)）",
    },
    "死信队列": {
      description: "始终启用（用于检查失败原因）",
    },
    "持久化存储": {
      description: "当命令必须在重启后保留时",
    },
    "指标": {
      description: "生产环境",
    },
    "告警": {
      description: "当 SLA 合规性重要时",
    },
    "限流": {
      description: "外部 API 调用、共享资源",
    },
    "优先级提升": {
      description: "混合优先级工作负载",
    },
    "分区": {
      description: "CPU 密集型、高吞吐量",
    },
  }}
/>
