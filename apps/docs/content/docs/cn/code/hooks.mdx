---
title: 生命周期 Hooks
description: 8 个生命周期 hooks 用于拦截工具调用、LLM 生成、会话和 skills
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

# 生命周期 Hooks

A3S Code 提供 8 个生命周期 hooks，用于在 agent 执行期间拦截和响应事件。Hooks 支持日志记录、安全执行、遥测和自定义行为，无需修改核心 agent 循环。

## Hook 事件

<TypeTable
  type={
    {`\`PreToolUse\``}: {
      description: "触发时机: 工具执行前 · 使用场景: 验证参数、污点追踪、阻止危险调用",
    },
    {`\`PostToolUse\``}: {
      description: "触发时机: 工具执行后 · 使用场景: 审计日志、注入扫描、输出过滤",
    },
    {`\`GenerateStart\``}: {
      description: "触发时机: LLM 调用前 · 使用场景: 注入检测、提示日志",
    },
    {`\`GenerateEnd\``}: {
      description: "触发时机: LLM 响应后 · 使用场景: 输出清洗、PII 脱敏",
    },
    {`\`SessionStart\``}: {
      description: "触发时机: 会话创建时 · 使用场景: 初始化会话资源",
    },
    {`\`SessionEnd\``}: {
      description: "触发时机: 会话销毁时 · 使用场景: 清理、持久化状态",
    },
    {`\`SkillLoad\``}: {
      description: "触发时机: Skill 加载时 · 使用场景: 验证 skill、记录激活",
    },
    {`\`SkillUnload\``}: {
      description: "触发时机: Skill 卸载时 · 使用场景: 清理 skill 资源",
    },
  }
/>

## Hooks 工作原理

Hooks 注册在 `HookEngine` 上，在 agent 循环的特定点触发。多个 hooks 可以监听同一事件 — 它们按优先级顺序执行（数字越小优先级越高）。

```
Agent 循环
  ├── GenerateStart hooks 触发
  ├── LLM 调用
  ├── GenerateEnd hooks 触发
  └── 对每个 tool_use：
      ├── PreToolUse hooks 触发
      ├── 权限检查
      ├── HITL 检查
      ├── 工具执行
      └── PostToolUse hooks 触发
```

## 内置 SecurityGuard

`SecurityGuard` 以优先级 1（最高）自动注册 hooks：

<TypeTable
  type={
    {`\`PreToolUse\``}: {
      description: "污点追踪 — 检查敏感值是否泄漏到工具参数中",
    },
    {`\`PostToolUse\``}: {
      description: "注入扫描 — 检测工具输出中的提示注入",
    },
    {`\`GenerateStart\``}: {
      description: "注入检测 — 扫描用户提示中的注入模式",
    },
    {`\`GenerateEnd\``}: {
      description: "输出清洗 — 从 LLM 响应中脱敏 PII",
    },
  }
/>

## Hook 注册（Rust）

通过 `HookEngine` 注册 hooks 和处理器：

```rust
use a3s_code_core::hooks::{
    Hook, HookConfig, HookEngine, HookEvent, HookEventType,
    HookHandler, HookResult, HookResponse, HookMatcher,
};
use std::sync::Arc;

let engine = HookEngine::new();

// 1. Register a hook definition (what to listen for)
engine.register(
    Hook::new("log-tools", HookEventType::PreToolUse)
        .with_config(HookConfig { priority: 10, ..Default::default() })
);

// 2. Register a handler (what to do when fired)
struct LogHandler;
impl HookHandler for LogHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            println!("Tool: {} Args: {:?}", e.tool, e.args);
        }
        HookResponse::continue_()
    }
}
engine.register_handler("log-tools", Arc::new(LogHandler));

// Block dangerous patterns
engine.register(
    Hook::new("block-dangerous", HookEventType::PreToolUse)
        .with_matcher(HookMatcher::tool("bash"))
        .with_config(HookConfig { priority: 5, ..Default::default() })
);

struct BlockHandler;
impl HookHandler for BlockHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            if e.args.to_string().contains("rm -rf") {
                return HookResponse::block("Dangerous command blocked");
            }
        }
        HookResponse::continue_()
    }
}
engine.register_handler("block-dangerous", Arc::new(BlockHandler));

// Fire a hook (done automatically by the agent loop)
let result = engine.fire(&event).await;
match result {
    HookResult::Continue(None) => { /* proceed */ }
    HookResult::Continue(Some(modified)) => { /* proceed with modified data */ }
    HookResult::Block(reason) => { /* stop execution */ }
    _ => {}
}
```

## Hook 优先级

Hooks 按优先级顺序执行。数字越小越先运行。

<TypeTable
  type={
    "1": {
      description: "SecurityGuard（内置，始终最先运行）",
    },
    "2-9": {
      description: "关键自定义 hooks（验证、阻止）",
    },
    "10-49": {
      description: "标准 hooks（日志、遥测）",
    },
    "50+": {
      description: "低优先级 hooks（分析、可选处理）",
    },
  }
/>

如果任何 hook 返回 `HookResult::Block`，操作会被取消，该事件的后续 hooks 会被跳过。

## Hook 事件载荷

每个 hook 事件携带一个类型化的载荷，包含事件特定的数据：

<Accordions>
<Accordion title="PreToolUse — PreToolUseEvent">

<TypeTable
  type={
    {`\`session_id\``}: {
      description: {`类型: \`String\` · 描述: 会话标识符`},
    },
    {`\`tool\``}: {
      description: {`类型: \`String\` · 描述: 被调用的工具名称`},
    },
    {`\`args\``}: {
      description: {`类型: \`Value\` · 描述: 工具参数`},
    },
    {`\`working_directory\``}: {
      description: {`类型: \`String\` · 描述: 当前工作区路径`},
    },
    {`\`recent_tools\``}: {
      description: {`类型: \`Vec<String>\` · 描述: 最近调用的工具`},
    },
  }
/>

</Accordion>
<Accordion title="PostToolUse — PostToolUseEvent">

<TypeTable
  type={
    {`\`session_id\``}: {
      description: {`类型: \`String\` · 描述: 会话标识符`},
    },
    {`\`tool\``}: {
      description: {`类型: \`String\` · 描述: 工具名称`},
    },
    {`\`args\``}: {
      description: {`类型: \`Value\` · 描述: 工具参数`},
    },
    {`\`result.success\``}: {
      description: {`类型: \`bool\` · 描述: 工具是否成功`},
    },
    {`\`result.output\``}: {
      description: {`类型: \`String\` · 描述: 工具输出文本`},
    },
    {`\`result.exit_code\``}: {
      description: {`类型: \`i32\` · 描述: 退出码`},
    },
    {`\`result.duration_ms\``}: {
      description: {`类型: \`u64\` · 描述: 执行时间`},
    },
  }
/>

</Accordion>
<Accordion title="GenerateStart — GenerateStartEvent">

<TypeTable
  type={
    {`\`session_id\``}: {
      description: {`类型: \`String\` · 描述: 会话标识符`},
    },
    {`\`prompt\``}: {
      description: {`类型: \`String\` · 描述: 用户提示`},
    },
    {`\`system_prompt\``}: {
      description: {`类型: \`String\` · 描述: 系统提示`},
    },
    {`\`model_provider\``}: {
      description: {`类型: \`String\` · 描述: 提供商名称`},
    },
    {`\`model_name\``}: {
      description: {`类型: \`String\` · 描述: 模型名称`},
    },
    {`\`available_tools\``}: {
      description: {`类型: \`Vec<String>\` · 描述: 已注册的工具名称`},
    },
  }
/>

</Accordion>
<Accordion title="GenerateEnd — GenerateEndEvent">

<TypeTable
  type={
    {`\`session_id\``}: {
      description: {`类型: \`String\` · 描述: 会话标识符`},
    },
    {`\`response_text\``}: {
      description: {`类型: \`String\` · 描述: LLM 响应`},
    },
    {`\`tool_calls\``}: {
      description: {`类型: \`Vec<String>\` · 描述: 本轮调用的工具`},
    },
    {`\`usage.total_tokens\``}: {
      description: {`类型: \`u32\` · 描述: Token 使用量`},
    },
    {`\`duration_ms\``}: {
      description: {`类型: \`u64\` · 描述: 生成时间`},
    },
  }
/>

</Accordion>
<Accordion title="SessionStart / SessionEnd">

**SessionStartEvent：** `session_id`、`system_prompt`、`model_provider`、`model_name`

**SessionEndEvent：** `session_id`、`total_tokens`、`total_tool_calls`、`duration_ms`

</Accordion>
<Accordion title="SkillLoad / SkillUnload">

**SkillLoadEvent：** `skill_name`、`tool_names`、`version`、`description`、`loaded_at`

**SkillUnloadEvent：** `skill_name`、`tool_names`、`duration_ms`

</Accordion>
</Accordions>

## API 参考

### Hook 注册

<TypeTable
  type={
    "注册 hook": {
      description: {`Rust: \`session.register_hook(Hook::new(id, event_type))\` · 描述: 注册 hook 监听器`},
    },
    "注册处理器": {
      description: {`Rust: \`session.register_hook_handler(id, Arc::new(handler))\` · 描述: 将处理器附加到 hook`},
    },
    "注销": {
      description: {`Rust: \`session.unregister_hook(id)\` · 描述: 移除 hook 和处理器`},
    },
    "计数": {
      description: {`Rust: \`session.hook_count()\` · 描述: 已注册的 hooks 数量`},
    },
  }
/>

### HookHandler trait（Rust）

```rust
impl HookHandler for MyHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        match event {
            HookEvent::PreToolUse(e) => { /* ... */ }
            _ => {}
        }
        HookResponse::continue_()
    }
}
```

### HookResponse 值

<TypeTable
  type={
    {`\`HookResponse::continue_()\``}: {
      description: "允许操作继续",
    },
    {`\`HookResponse::block(reason)\``}: {
      description: "以原因字符串取消操作",
    },
    {`\`HookResponse::modify(data)\``}: {
      description: "在执行前替换事件数据",
    },
  }
/>

### Hook 优先级

数字越小 = 优先级越高。`SecurityGuard` 使用优先级 `1`。默认 hooks 使用优先级 `100`。

```rust
Hook::new("my-hook", HookEventType::PreToolUse).with_priority(50)
```
