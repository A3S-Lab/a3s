---
title: 记忆
description: 文件记忆、自定义后端和记忆事件的实用示例
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

# 记忆示例

## 文件持久化记忆

记忆在会话重启后仍然保留。多个会话指向同一目录即可共享长期知识。

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};

let agent = Agent::new("agent.hcl").await?;

let session = agent.session(".", Some(
    SessionOptions::new()
        .with_file_memory("./memory")
))?;

// 第一次会话 — Agent 存储一条事实
session.send("记住：我们通过 GitHub Actions 部署到 AWS us-east-1").await?;

// 之后的会话（同一 memory 目录）— Agent 自动召回
let session2 = agent.session(".", Some(
    SessionOptions::new()
        .with_file_memory("./memory")
))?;
let result = session2.send("我们部署在哪里？").await?;
// Agent 无需再次告知，直接从记忆中回答
```
</Tab>
<Tab value="TypeScript">
```typescript
const agent = await Agent.create('agent.hcl');

// 第一次会话
const s1 = agent.session('.', { fileMemory: './memory' });
await s1.send('记住：我们通过 GitHub Actions 部署到 AWS us-east-1');

// 之后的会话 — 同一 memory 目录
const s2 = agent.session('.', { fileMemory: './memory' });
const result = await s2.send('我们部署在哪里？');
```
</Tab>
<Tab value="Python">
```python
agent = Agent("agent.hcl")

s1 = agent.session(".", SessionOptions(file_memory="./memory"))
s1.send("记住：我们通过 GitHub Actions 部署到 AWS us-east-1")

s2 = agent.session(".", SessionOptions(file_memory="./memory"))
result = s2.send("我们部署在哪里？")
```
</Tab>
</Tabs>

## 直接存储记忆

通过 `session.memory()` 在代码中主动存储和查询记忆：

```rust
use a3s_memory::{MemoryItem, MemoryType};

let memory = session.memory().unwrap();

// 完整控制
memory.remember(
    MemoryItem::new("Auth 使用 JWT，有效期 24 小时")
        .with_importance(0.9)
        .with_tag("auth")
        .with_tag("security")
        .with_type(MemoryType::Semantic)
).await?;

// 便捷方法（自动设置重要性和标签）
memory.remember_success("重构 auth 模块 — 测试全部通过").await?;
memory.remember_failure("未运行 fmt 检查直接部署会导致 CI 失败").await?;

// 查询
let results = memory.recall("auth", 5).await?;
for item in results {
    println!("[{:.2}] {}", item.importance, item.content);
}
```

## 自定义后端

实现 `a3s-memory` 中的 `MemoryStore` trait 接入任意存储系统：

```rust
use a3s_memory::{MemoryItem, MemoryStore};
use async_trait::async_trait;
use std::sync::Arc;

struct SqliteMemoryStore {
    pool: sqlx::SqlitePool,
}

#[async_trait]
impl MemoryStore for SqliteMemoryStore {
    async fn store(&self, item: MemoryItem) -> anyhow::Result<()> {
        sqlx::query!(
            "INSERT OR REPLACE INTO memories (id, content, importance, tags, timestamp)
             VALUES (?, ?, ?, ?, ?)",
            item.id, item.content, item.importance,
            serde_json::to_string(&item.tags)?,
            item.timestamp.to_rfc3339(),
        )
        .execute(&self.pool).await?;
        Ok(())
    }

    async fn search(&self, query: &str, limit: usize) -> anyhow::Result<Vec<MemoryItem>> {
        // 全文搜索或语义相似度搜索
        todo!()
    }

    async fn retrieve(&self, id: &str) -> anyhow::Result<Option<MemoryItem>> { todo!() }
    async fn search_by_tags(&self, tags: &[String], limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn get_recent(&self, limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn get_important(&self, threshold: f32, limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn delete(&self, id: &str) -> anyhow::Result<()> { todo!() }
    async fn clear(&self) -> anyhow::Result<()> { todo!() }
    async fn count(&self) -> anyhow::Result<usize> { todo!() }
}

let store = Arc::new(SqliteMemoryStore { pool });
let session = agent.session(".", Some(
    SessionOptions::new().with_memory(store)
))?;
```

## 记忆事件

通过流式 API 订阅记忆生命周期事件：

```rust
let (mut rx, _handle) = session.stream("你对这个项目了解什么？", None).await?;

while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::MemoryStored { memory_id, memory_type } => {
            println!("已存储 {} ({:?})", memory_id, memory_type);
        }
        AgentEvent::MemoryRecalled { memory_id, .. } => {
            println!("已召回 {}", memory_id);
        }
        AgentEvent::MemoriesSearched { query, count } => {
            println!("搜索 '{}' → {} 条结果", query, count);
        }
        _ => {}
    }
}
```

## 相关性调优

根据使用场景调整评分参数：

```rust
use a3s_memory::RelevanceConfig;
use a3s_code_core::memory::MemoryConfig;

// 长期助手：衰减慢，重要性权重高
let config = MemoryConfig {
    relevance: RelevanceConfig {
        decay_days: 365.0,
        importance_weight: 0.9,
        recency_weight: 0.1,
    },
    max_short_term: 200,
    max_working: 20,
};

// 短期编码会话：衰减快，时效性权重高
let config = MemoryConfig {
    relevance: RelevanceConfig {
        decay_days: 1.0,
        importance_weight: 0.3,
        recency_weight: 0.7,
    },
    max_short_term: 50,
    max_working: 5,
};

SessionOptions::new().with_memory_config(config)
```

## 索引重建

`FileMemoryStore` 的索引损坏或丢失时，无需数据损失即可恢复：

```rust
use a3s_memory::FileMemoryStore;

let store = FileMemoryStore::new("./memory").await?;

// 扫描 items/ 目录，从 item 文件重建 index.json
let recovered = store.rebuild_index().await?;
println!("已恢复 {} 条记忆", recovered);
```

<Callout type="info">
完整 API 参考请查看[记忆系统](/cn/docs/code/memory)。
</Callout>
