---
title: MCP 支持
description: 通过 Model Context Protocol 扩展 agent 的外部工具
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# MCP 支持

A3S Code 支持 [Model Context Protocol](https://modelcontextprotocol.io/)（MCP）来集成外部工具服务器。当服务器连接时，MCP 工具会自动注册到 ToolExecutor 中。

## 传输方式

A3S Code 支持三种 MCP 传输方式：

<TypeTable
  type={{
    "stdio": {
      description: "协议: JSON-RPC 2.0 over stdin/stdout · 使用场景: 本地工具、基于 CLI 的服务器",
    },
    "http": {
      description: "协议: JSON-RPC 2.0 over HTTP + Server-Sent Events · 使用场景: 远程服务器、共享基础设施（旧版 SSE 传输）",
    },
    "streamable-http": {
      description: "协议: JSON-RPC 2.0 over HTTP（MCP 2025-03-26 规范）· 使用场景: 远程服务器 — 单一端点，支持 JSON 和 SSE 响应，通过 Mcp-Session-Id 头管理会话",
    },
  }}
/>

## 配置

### stdio 传输

用于作为子进程运行的本地 MCP 服务器：

```hcl
mcp_servers {
  name      = "filesystem"
  transport = "stdio"
  command   = "npx"
  args      = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
  enabled   = true
}

mcp_servers {
  name      = "github"
  transport = "stdio"
  command   = "npx"
  args      = ["-y", "@modelcontextprotocol/server-github"]
  enabled   = true
  env = {
    GITHUB_TOKEN = "ghp_..."
  }
}
```

### HTTP+SSE 传输

用于使用旧版 SSE 传输的远程 MCP 服务器：

```hcl
mcp_servers {
  name      = "remote-tools"
  transport = "http"
  url       = "https://mcp.example.com/sse"
  enabled   = true
  headers = {
    Authorization = "Bearer token-..."
  }
}
```

请求通过 HTTP POST 发送到基础 URL；响应通过 `/sse` 端点的 Server-Sent Events 流式返回。

### Streamable HTTP 传输

用于实现 MCP 2025-03-26 规范的远程 MCP 服务器：

```hcl
mcp_servers {
  name      = "remote-tools"
  transport = "streamable-http"
  url       = "https://mcp.example.com/mcp"
  enabled   = true
  headers = {
    Authorization = "Bearer token-..."
  }
}
```

所有通信通过单一端点进行。服务器可以返回纯 JSON 或 SSE 流。会话通过 `Mcp-Session-Id` 头跟踪，关闭时发送 DELETE 请求终止会话。

## 工具命名

MCP 工具使用服务器名称作为命名空间以避免冲突：

```
mcp__<server_name>__<tool_name>
```

例如，`filesystem` 服务器的 `read_file` 工具变为 `mcp__filesystem__read_file`。

## 权限集成

MCP 工具遵循与内置工具相同的权限系统。在权限规则中使用命名空间前缀：

```
mcp__filesystem  → 匹配 filesystem 服务器的所有工具
mcp__github      → 匹配 github 服务器的所有工具
```

## 防止覆盖

MCP 工具不能覆盖内置工具名称。如果 MCP 服务器暴露了名为 `Bash`、`Read`、`Write` 或其他内置名称的工具，工具注册会被拒绝。这防止了恶意 MCP 服务器拦截敏感操作。

## 执行超时

MCP 工具执行有可配置的超时时间（默认：60 秒）。如果工具在超时时间内未响应，执行会被取消并返回错误。这防止了挂起的 MCP 服务器阻塞 agent。

## API 参考

### HCL 配置

```hcl
mcp_servers {
  name    = "filesystem"
  command = "npx"
  args    = ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
}

mcp_servers {
  name = "github"
  command = "npx"
  args    = ["-y", "@modelcontextprotocol/server-github"]
  env     = { GITHUB_TOKEN = env("GITHUB_TOKEN") }
}

mcp_servers {
  name      = "remote"
  transport = "streamable-http"
  url       = "https://mcp.example.com/mcp"
  headers   = { Authorization = "Bearer token" }
}
```

### MCP 服务器配置字段

<TypeTable
  type={{
    "name": {
      description: "类型: string · 必填: ✅ · 描述: 服务器标识符（用于工具名称前缀）",
    },
    "transport": {
      description: "类型: string · 必填: ❌ · 默认: stdio · 描述: stdio、http 或 streamable-http",
    },
    "command": {
      description: "类型: string · 必填: ❌ · 描述: 要启动的可执行文件（仅 stdio）",
    },
    "args": {
      description: "类型: string[] · 必填: ❌ · 描述: 命令参数（仅 stdio）",
    },
    "url": {
      description: "类型: string · 必填: ❌ · 描述: 服务器端点 URL（http / streamable-http 必填）",
    },
    "headers": {
      description: "类型: object · 必填: ❌ · 描述: HTTP 请求头（http / streamable-http）",
    },
    "env": {
      description: "类型: object · 必填: ❌ · 描述: 环境变量（仅 stdio）",
    },
    "timeout_ms": {
      description: "类型: number · 必填: ❌ · 默认: 60000 · 描述: 工具执行超时（毫秒）",
    },
  }}
/>

### 工具命名

MCP 工具命名为 `mcp__{server}__{tool}`。在权限规则中使用此前缀：

<TypeTable
  type={{
    "mcp__filesystem": {
      description: "filesystem 服务器的所有工具",
    },
    "mcp__github__create_issue": {
      description: "特定工具",
    },
    "mcp__*": {
      description: "所有 MCP 工具",
    },
  }}
/>

## 动态 MCP 服务器注册

使用 `add_mcp_server()` 在运行时将 MCP 服务器连接到活跃 session — 无需重启 agent 或重新加载配置。服务器启动后，其工具会被自动发现，并在下一轮 LLM 调用中立即可用。

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use std::sync::Arc;
use a3s_code_core::{Agent, mcp::manager::McpManager};

let agent = Agent::new("agent.hcl").await?;
let session = Arc::new(agent.session(".", None)?);

let manager = Arc::new(McpManager::new());

// stdio 服务器
let tool_count = session.add_mcp_server(
    Arc::clone(&manager),
    "filesystem",
).await?;
println!("从 filesystem 服务器注册了 {tool_count} 个工具");

// 工具现在可用：mcp__filesystem__read_file 等
let result = session.send("列出 /tmp 中的文件").await?;
```
</Tab>
<Tab value="TypeScript">
```typescript
import { Agent } from '@a3s-lab/code'; // v0.9.5

const agent = await Agent.create('agent.hcl');
const session = agent.session('.');

// stdio 服务器
const toolCount = await session.addMcpServer(
  'filesystem',
  { transport: 'stdio', command: 'npx', args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'] },
);
console.log(`注册了 ${toolCount} 个工具`);

// Streamable HTTP 服务器
await session.addMcpServer(
  'remote',
  {
    transport: 'streamable-http',
    url: 'https://mcp.example.com/mcp',
    headers: { Authorization: `Bearer ${process.env.API_TOKEN}` },
  },
);

const result = await session.send('列出 /tmp 中的文件');
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent  # v0.9.5

agent = Agent.create("agent.hcl")
session = agent.session(".")

# stdio 服务器
tool_count = session.add_mcp_server(
    "filesystem",
    transport="stdio",
    command="npx",
    args=["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
)
print(f"注册了 {tool_count} 个工具")

# Streamable HTTP 服务器
session.add_mcp_server(
    "remote",
    transport="streamable-http",
    url="https://mcp.example.com/mcp",
    headers={"Authorization": f"Bearer {os.environ['API_TOKEN']}"},
)

result = session.send("列出 /tmp 中的文件")
```
</Tab>
</Tabs>

### add_mcp_server 参数

<TypeTable
  type={{
    "name": {
      description: "类型: string · 必填: ✅ · 描述: 服务器标识符 — 用作工具名称前缀（mcp__{name}__{tool}）",
    },
    "transport": {
      description: "类型: 'stdio' | 'http' | 'streamable-http' · 必填: ❌ · 默认: stdio · 描述: 传输协议",
    },
    "command": {
      description: "类型: string · 必填: ❌ · 描述: 要启动的可执行文件 — stdio 传输必填",
    },
    "args": {
      description: "类型: string[] · 必填: ❌ · 描述: 传递给服务器进程的命令行参数（仅 stdio）",
    },
    "url": {
      description: "类型: string · 必填: ❌ · 描述: 服务器端点 URL — http 和 streamable-http 传输必填",
    },
    "headers": {
      description: "类型: object · 必填: ❌ · 描述: 每次请求发送的 HTTP 头（http / streamable-http）",
    },
    "env": {
      description: "类型: object · 必填: ❌ · 描述: 服务器进程的额外环境变量（仅 stdio）",
    },
  }}
/>

返回从服务器注册的工具数量。如果服务器启动失败或初始 `list_tools` 调用失败，则抛出错误。
