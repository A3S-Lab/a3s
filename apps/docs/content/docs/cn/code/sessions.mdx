---
title: ä¼šè¯
description: åˆ›å»ºä¼šè¯ã€å‘é€æç¤ºã€æµå¼å“åº”å’Œç®¡ç†å¯¹è¯å†å²
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

# ä¼šè¯

æ¯ä¸ªä¼šè¯ç»‘å®šåˆ°ä¸€ä¸ªå·¥ä½œåŒºç›®å½•ã€‚Agent é€šè¿‡ `agent.session(workspace, options?)` åˆ›å»ºä¼šè¯ã€‚ä¼šè¯æŒæœ‰è‡ªå·±çš„ LLM å®¢æˆ·ç«¯ã€å¯¹è¯å†å²å’Œå·¥å…·ä¸Šä¸‹æ–‡ã€‚

ç”Ÿæˆ API â€” `send()` å’Œ `stream()` â€” å°†æç¤ºå‘é€ç»™ LLM å¹¶è¿”å›å“åº”ã€‚Agent å¾ªç¯è‡ªåŠ¨å¤„ç†å·¥å…·æ‰§è¡Œã€‚

## åˆ›å»ºä¼šè¯

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};

let agent = Agent::new("agent.hcl").await?;

// Default session (uses config's default model)
let session = agent.session("/my-project", None)?;

// Session with model override
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_model("openai/gpt-4o")
))?;
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

const agent = await Agent.create('agent.hcl');

// Default session
const session = agent.session('/my-project');

// Session with model override
const session = agent.session('/my-project', {
  model: 'openai/gpt-4o',
});
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent

agent = Agent.create("agent.hcl")

# Default session
session = agent.session("/my-project")

# Session with model override
session = agent.session("/my-project", model="openai/gpt-4o")
```
</Tab>
</Tabs>

## SessionOptions

| å‚æ•° | Rust | TypeScript | Python | æè¿° |
|-----------|------|-----------|--------|-------------|
| æ¨¡å‹è¦†ç›– | `with_model("provider/model")` | `model: "provider/model"` | `model="provider/model"` | æ ¼å¼ï¼š`provider/model`ï¼ˆä¾‹å¦‚ `openai/gpt-4o`ï¼‰ |
| Skill ç›®å½• | `with_skill_dir("path")` | `skillDirs: ["path"]` | `skill_dirs=["path"]` | é¢å¤–çš„ skill æ–‡ä»¶æ‰«æç›®å½•ï¼ˆä¸å…¨å±€ `skill_dirs` åˆå¹¶ï¼‰ |
| Agent ç›®å½• | `with_agent_dir("path")` | `agentDirs: ["path"]` | `agent_dirs=["path"]` | é¢å¤–çš„ agent æ–‡ä»¶æ‰«æç›®å½•ï¼ˆä¸å…¨å±€ `agent_dirs` åˆå¹¶ï¼‰ |
| è§£æé‡è¯• | `with_parse_retries(n)` | `maxParseRetries: n` | `max_parse_retries=n` | è¿ç»­å·¥å…·å‚æ•°æ ¼å¼é”™è¯¯çš„æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ˆé»˜è®¤ï¼š2ï¼‰ |
| å·¥å…·è¶…æ—¶ | `with_tool_timeout(ms)` | `toolTimeoutMs: ms` | `tool_timeout_ms=ms` | æ¯ä¸ªå·¥å…·çš„æ‰§è¡Œè¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼›è¶…æ—¶åé”™è¯¯ä¼šåé¦ˆç»™ LLMï¼ˆé»˜è®¤ï¼šæ— ï¼‰ |
| ç†”æ–­å™¨ | `with_circuit_breaker(n)` | `circuitBreakerThreshold: n` | `circuit_breaker_threshold=n` | éæµå¼æ¨¡å¼ä¸‹ LLM API å¤±è´¥çš„æœ€å¤§æ¬¡æ•°ï¼ˆé»˜è®¤ï¼š3ï¼‰ |
| å¼¹æ€§å¥—ä»¶ | `with_resilience_defaults()` | â€” | â€” | å¯ç”¨ parse_retries=2ã€tool_timeout=120sã€circuit_breaker=3 |
| æ²™ç®± | `with_sandbox(SandboxConfig)` | â€” | â€” | é€šè¿‡ A3S Box MicroVM è·¯ç”± `bash` å·¥å…·ï¼ˆéœ€è¦ `sandbox` featureï¼‰ |

æ¨¡å‹å¿…é¡»åœ¨ agent é…ç½®æ–‡ä»¶çš„ `providers` ä¸­å®šä¹‰ã€‚æ ¼å¼ä¸º `provider_name/model_id`ã€‚

å…¨å±€ `skill_dirs` å’Œ `agent_dirs` åœ¨ agent é…ç½®ä¸­è®¾ç½®ã€‚æ¯ä¸ªä¼šè¯çš„ç›®å½•ä¼šä¸å…¨å±€ç›®å½•åˆå¹¶ â€” è¯¦è§ [Skills](/cn/docs/code/skills)ã€‚

## é”™è¯¯æ¢å¤ä¸å¼¹æ€§

ä¸‰å±‚é”™è¯¯æ¢å¤æœºåˆ¶ä¿æŠ¤é•¿æ—¶é—´è¿è¡Œçš„ä¼šè¯ï¼š

<Accordions>
<Accordion title="è§£æé”™è¯¯æ¢å¤">
å½“ LLM è¿”å›æ ¼å¼é”™è¯¯çš„å·¥å…·å‚æ•°ï¼ˆ`__parse_error`ï¼‰æ—¶ï¼Œé”™è¯¯ä¼šä½œä¸ºå·¥å…·ç»“æœåé¦ˆç»™æ¨¡å‹ä»¥ä¾¿è‡ªæˆ‘ä¿®æ­£ã€‚è¿ç»­å¤±è´¥ `max_parse_retries` æ¬¡åå¾ªç¯ä¸­æ­¢ã€‚
</Accordion>
<Accordion title="å·¥å…·æ‰§è¡Œè¶…æ—¶">
æ¯ä¸ªå·¥å…·è°ƒç”¨éƒ½åŒ…è£…åœ¨ `tokio::time::timeout` ä¸­ã€‚è¶…æ—¶çš„å·¥å…·ä¼šäº§ç”Ÿé”™è¯¯æ¶ˆæ¯åé¦ˆç»™ LLMï¼›ä¼šè¯ç»§ç»­è¿è¡Œã€‚
</Accordion>
<Accordion title="ç†”æ–­å™¨">
ç¬æ€ LLM API æ•…éšœï¼ˆç½‘ç»œé”™è¯¯ã€é€Ÿç‡é™åˆ¶ï¼‰åœ¨éæµå¼æ¨¡å¼ä¸‹ä¼šä»¥çŸ­æŒ‡æ•°é€€é¿é‡è¯•æœ€å¤š `circuit_breaker_threshold` æ¬¡ã€‚åœ¨æµå¼æ¨¡å¼ä¸‹ï¼Œä»»ä½•æ•…éšœéƒ½æ˜¯è‡´å‘½çš„ï¼ˆäº‹ä»¶æ— æ³•é‡æ”¾ï¼‰ã€‚
</Accordion>
</Accordions>

```rust
// Rust â€” individual controls
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_parse_retries(3)          // bail after 3 consecutive parse errors
        .with_tool_timeout(30_000)      // 30s per tool
        .with_circuit_breaker(5)        // retry LLM up to 5 times
))?;

// Rust â€” sensible bundle (parse=2, timeout=2min, circuit_breaker=3)
let session = agent.session(".", Some(
    SessionOptions::new().with_resilience_defaults()
))?;
```

## å‘é€ï¼ˆéæµå¼ï¼‰

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let result = session.send("What files handle authentication?").await?;
println!("{}", result.text);
println!("Tools: {}, Tokens: {}", result.tool_calls_count, result.usage.total_tokens);
```
</Tab>
<Tab value="TypeScript">
```typescript
const result = await session.send('What files handle authentication?');
console.log(result.text);
console.log(`Tools: ${result.toolCallsCount}, Tokens: ${result.totalTokens}`);
```
</Tab>
<Tab value="Python">
```python
result = session.send("What files handle authentication?")
print(result.text)
print(f"Tools: {result.tool_calls_count}, Tokens: {result.total_tokens}")
```
</Tab>
</Tabs>

## å¸¦é™„ä»¶å‘é€ï¼ˆè§†è§‰ï¼‰

å‘é€å›¾ç‰‡é™„ä»¶å’Œæ–‡æœ¬æç¤ºã€‚éœ€è¦æ”¯æŒè§†è§‰çš„æ¨¡å‹ï¼ˆClaude Sonnetã€GPT-4oï¼‰ã€‚

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::Attachment;

// From file (auto-detects media type from extension)
let image = Attachment::from_file("screenshot.png")?;

// Or from bytes
let image = Attachment::jpeg(raw_bytes);

let result = session.send_with_attachments(
    "What's in this screenshot?",
    &[image],
    None,
).await?;
println!("{}", result.text);
```
</Tab>
<Tab value="TypeScript">
```typescript
const image = await fs.readFile('screenshot.png');
const result = await session.sendWithAttachments(
  "What's in this screenshot?",
  [{ data: image, mediaType: 'image/png' }],
);
console.log(result.text);
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Attachment

image = Attachment.from_file("screenshot.png")
result = session.send_with_attachments(
    "What's in this screenshot?",
    [image],
)
print(result.text)
```
</Tab>
</Tabs>

æ”¯æŒçš„å›¾ç‰‡æ ¼å¼ï¼šJPEGã€PNGã€GIFã€WebPã€‚

æµå¼å˜ä½“ï¼š

```rust
let (rx, handle) = session.stream_with_attachments(
    "Describe this diagram",
    &[Attachment::from_file("diagram.png")?],
    None,
).await?;
```

### å·¥å…·å›¾ç‰‡è¾“å‡º

å·¥å…·å¯ä»¥åœ¨æ–‡æœ¬è¾“å‡ºæ—è¿”å›å›¾ç‰‡ã€‚å½“å·¥å…·è¿”å›å›¾ç‰‡æ—¶ï¼Œå®ƒä»¬ä¼šä½œä¸ºå¤šæ¨¡æ€å†…å®¹å—åŒ…å«åœ¨å‘é€ç»™ LLM çš„å·¥å…·ç»“æœæ¶ˆæ¯ä¸­ã€‚

```rust
// In a custom tool implementation
async fn execute(&self, args: &Value, ctx: &ToolContext) -> Result<ToolOutput> {
    let screenshot_bytes = take_screenshot().await?;
    Ok(ToolOutput::success("Screenshot captured")
        .with_images(vec![Attachment::png(screenshot_bytes)]))
}
```

## æµå¼

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::AgentEvent;

// AgentEvent is #[non_exhaustive] â€” always include a wildcard arm
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::ToolStart { name, .. } => println!("\nğŸ”§ {name}"),
        AgentEvent::End { text, usage } => {
            println!("\nâœ… Done: {} tokens", usage.total_tokens);
            break;
        }
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
// Returns an EventStream â€” use for await...of or call .next() manually
const stream = await session.stream('Refactor the auth module');
for await (const event of stream) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  if (event.type === 'tool_start') console.log(`\nğŸ”§ ${event.toolName}`);
  if (event.type === 'tool_end') console.log(`  â†’ ${event.toolOutput?.slice(0, 100)}`);
}

// Or iterate manually with .next()
const stream2 = await session.stream('Explain src/main.rs');
while (true) {
  const { value, done } = await stream2.next();
  if (done) break;
  if (value.type === 'text_delta') process.stdout.write(value.text);
}
```
</Tab>
<Tab value="Python">
```python
# Sync iteration (works without an event loop)
for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nğŸ”§ {event.tool_name}")
    elif event.event_type == "tool_end":
        print(f"  â†’ {event.tool_output[:100]}")

# Async iteration (inside async def)
async for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "end":
        print(f"\nDone â€” {event.total_tokens} tokens")
        break
```
</Tab>
</Tabs>

## å¯¹è¯å†å²ï¼ˆRustï¼‰

é€šè¿‡ä¼ é€’å†å²è®°å½•ç»´æŠ¤å¤šè½®å¯¹è¯ï¼š

```rust
use a3s_code_core::llm::{ContentBlock, Message};

let history = vec![
    Message::user("What's in src/?"),
    Message {
        role: "assistant".to_string(),
        content: vec![ContentBlock::Text {
            text: "The src/ directory contains main.rs and lib.rs.".to_string(),
        }],
        reasoning_content: None,
    },
];

// Continue the conversation
let result = session.send_with_history(&history, "Now explain main.rs").await?;
```

## ç›´æ¥å·¥å…·æ‰§è¡Œ

ç›´æ¥è°ƒç”¨å·¥å…·è€Œä¸ç»è¿‡ LLMï¼š

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
session.read_file("src/main.rs").await?;
session.bash("cargo test").await?;
session.glob("**/*.rs").await?;
session.grep("fn main").await?;
session.tool("write", serde_json::json!({"file_path": "x.rs", "content": "..."})).await?;
```
</Tab>
<Tab value="TypeScript">
```typescript
await session.readFile('src/main.rs');
await session.bash('cargo test');
await session.glob('**/*.rs');
await session.grep('fn main');
await session.tool('write', { file_path: 'x.rs', content: '...' });
```
</Tab>
<Tab value="Python">
```python
session.read_file("src/main.rs")
session.bash("cargo test")
session.glob("**/*.rs")
session.grep("fn main")
session.tool("write", {"file_path": "x.rs", "content": "..."})
```
</Tab>
</Tabs>

## é…ç½®

å‚è§ [æä¾›å•†ä¸é…ç½®](/cn/docs/code/providers) è·å–å®Œæ•´çš„ HCL é…ç½®å‚è€ƒï¼ŒåŒ…æ‹¬æ‰€æœ‰å­—æ®µã€`env()` å‡½æ•°ã€é˜Ÿåˆ—å’Œæœç´¢é…ç½®ã€‚

## è¿”å›ç±»å‹

### AgentResult

| å­—æ®µ | ç±»å‹ | æè¿° |
|-------|------|-------------|
| `text` | `string` | LLM æœ€ç»ˆå“åº”æ–‡æœ¬ |
| `messages` | `Vec<Message>` | å®Œæ•´å¯¹è¯å†å²ï¼ˆä»… Rustï¼‰ |
| `usage` | `TokenUsage` | Token ä½¿ç”¨ç»Ÿè®¡ |
| `tool_calls_count` | `usize` | å·¥å…·è°ƒç”¨æ¬¡æ•° |

### TokenUsage

| å­—æ®µ | ç±»å‹ | æè¿° |
|-------|------|-------------|
| `prompt_tokens` | `usize` | è¾“å…¥ token æ•° |
| `completion_tokens` | `usize` | è¾“å‡º token æ•° |
| `total_tokens` | `usize` | æ€» token æ•° |
| `cache_read_tokens` | `Option<usize>` | ç¼“å­˜è¯»å–çš„è¾“å…¥ token æ•° |
| `cache_write_tokens` | `Option<usize>` | ç¼“å­˜å†™å…¥çš„è¾“å…¥ token æ•° |

### AgentEvent

`AgentEvent` æ˜¯ `#[non_exhaustive]` çš„ â€” åœ¨ Rust ä¸­åŒ¹é…æ—¶å§‹ç»ˆåŒ…å«é€šé…ç¬¦åˆ†æ”¯ã€‚

**Agent ç”Ÿå‘½å‘¨æœŸï¼š**

| äº‹ä»¶ | å­—æ®µ | æè¿° |
|-------|--------|-------------|
| `Start` | `prompt` | å¼€å§‹å¤„ç† |
| `TurnStart` | `turn` | æ–°è½®æ¬¡å¼€å§‹ |
| `TextDelta` | `text` | åŠ©æ‰‹çš„æ–‡æœ¬ç‰‡æ®µ |
| `TurnEnd` | `turn`, `total_tokens` | è½®æ¬¡å®Œæˆ |
| `End` | `text`, `total_tokens` | ç”Ÿæˆå®Œæˆ |
| `Error` | `error` | å‘ç”Ÿé”™è¯¯ |

**å·¥å…·æ‰§è¡Œï¼š**

| äº‹ä»¶ | å­—æ®µ | æè¿° |
|-------|--------|-------------|
| `ToolStart` | `tool_id`, `tool_name` | å·¥å…·è°ƒç”¨å¼€å§‹ |
| `ToolEnd` | `tool_id`, `tool_name`, `tool_output`, `exit_code` | å·¥å…·è°ƒç”¨å®Œæˆ |
| `ToolOutputDelta` | `tool_id`, `tool_name`, `text` | å·¥å…·è¾“å‡ºå¢é‡ |

**HITL å’Œæƒé™ï¼š**

| äº‹ä»¶ | å­—æ®µ | æè¿° |
|-------|--------|-------------|
| `ConfirmationRequired` | `tool_id`, `tool_name`, `args`, `timeout_ms` | éœ€è¦ HITL ç¡®è®¤ |
| `ConfirmationReceived` | `tool_id`, `approved`, `reason` | æ”¶åˆ° HITL ç¡®è®¤ |
| `ConfirmationTimeout` | `tool_id`, `action_taken` | HITL ç¡®è®¤è¶…æ—¶ |
| `PermissionDenied` | `tool_id`, `tool_name`, `args`, `reason` | å·¥å…·è¢«æƒé™ç­–ç•¥é˜»æ­¢ |

**ä¸Šä¸‹æ–‡å’Œè®°å¿†ï¼š**

| äº‹ä»¶ | å­—æ®µ | æè¿° |
|-------|--------|-------------|
| `ContextResolving` | `providers` | ä¸Šä¸‹æ–‡è§£æå¼€å§‹ |
| `ContextResolved` | `total_items`, `total_tokens` | ä¸Šä¸‹æ–‡è§£æå®Œæˆ |
| `MemoryStored` | â€” | è®°å¿†é¡¹å·²å­˜å‚¨ |
| `MemoryRecalled` | â€” | è®°å¿†é¡¹å·²å¬å› |
| `MemoriesSearched` | â€” | è®°å¿†æœç´¢å®Œæˆ |
| `MemoryCleared` | â€” | è®°å¿†å·²æ¸…é™¤ |

**ä»»åŠ¡ã€å­ä»£ç†å’Œ Lane é˜Ÿåˆ—ï¼š**

| äº‹ä»¶ | å­—æ®µ | æè¿° |
|-------|--------|-------------|
| `TaskUpdated` | `session_id`, `tasks` | ä»»åŠ¡åˆ—è¡¨å˜æ›´ |
| `SubagentStart` | â€” | å­ä»£ç†æ‰§è¡Œå¼€å§‹ |
| `ExternalTaskPending` | â€” | å¤–éƒ¨ä»»åŠ¡å·²å…¥é˜Ÿ |
| `ExternalTaskCompleted` | â€” | å¤–éƒ¨ä»»åŠ¡å·²å®Œæˆ |
| `CommandDeadLettered` | â€” | Lane å‘½ä»¤è¿›å…¥æ­»ä¿¡é˜Ÿåˆ— |
| `CommandRetry` | â€” | Lane å‘½ä»¤é‡è¯• |
| `QueueAlert` | â€” | é˜Ÿåˆ—å‘Šè­¦è§¦å‘ |

## API å‚è€ƒ

### Agent

| æ–¹æ³• | ç­¾å | æè¿° |
|--------|-----------|-------------|
| `new` | `Agent::new(config: &str) -> Result<Agent>` | ä» HCL æ–‡ä»¶æˆ–å­—ç¬¦ä¸²åŠ è½½ |
| `from_config` | `Agent::from_config(config: AgentConfig) -> Result<Agent>` | ä»ç»“æ„ä½“åŠ è½½ |
| `session` | `agent.session(workspace, options?) -> Result<AgentSession>` | åˆ›å»ºç»‘å®šå·¥ä½œåŒºçš„ä¼šè¯ |

### AgentSession

| æ–¹æ³• | Rust | Python | Node.js |
|--------|------|--------|---------|
| å‘é€æç¤º | `session.send(prompt, None).await?` | `await session.send(prompt)` | `await session.send(prompt)` |
| æµå¼äº‹ä»¶ | `session.stream(prompt, None).await?` | `session.stream(prompt)` | `session.stream(prompt)` |
| å¸¦å›¾ç‰‡å‘é€ | `session.send_with_attachments(p, &[img], None).await?` | `await session.send_with_attachments(p, [img])` | `await session.sendWithAttachments(p, [img])` |
| è¯»å–æ–‡ä»¶ | `session.read_file(path).await?` | `await session.read_file(path)` | `await session.readFile(path)` |
| è¿è¡Œ bash | `session.bash(cmd).await?` | `await session.bash(cmd)` | `await session.bash(cmd)` |
| Glob | `session.glob(pattern).await?` | `await session.glob(pattern)` | `await session.glob(pattern)` |
| Grep | `session.grep(pattern).await?` | `await session.grep(pattern)` | `await session.grep(pattern)` |
| è°ƒç”¨å·¥å…· | `session.tool(name, args).await?` | `await session.tool(name, args)` | `await session.tool(name, args)` |
| å†å²è®°å½• | `session.history()` | `session.history()` | `session.history()` |

### SessionOptions

| é€‰é¡¹ | Rust | Python | Node.js | é»˜è®¤å€¼ |
|--------|------|--------|---------|---------|
| æ¨¡å‹ | `.with_model("provider/model")` | `model="provider/model"` | `model: "provider/model"` | é…ç½®é»˜è®¤å€¼ |
| å®½æ¾æ¨¡å¼ | `.with_permissive_policy()` | `permissive=True` | `permissive: true` | `false` |
| è§„åˆ’ | `.with_planning(true)` | `planning=True` | `planning: true` | `false` |
| ç›®æ ‡è·Ÿè¸ª | `.with_goal_tracking(true)` | `goal_tracking=True` | `goalTracking: true` | `false` |
| å†…ç½® skills | `.with_builtin_skills()` | `builtin_skills=True` | `builtinSkills: true` | `false` |
| Skill ç›®å½• | `.with_skills_from_dir(path)` | `skill_dirs=[path]` | `skillDirs: [path]` | `[]` |
| é»˜è®¤å®‰å…¨ | `.with_default_security()` | `default_security=True` | `defaultSecurity: true` | `false` |
| æ–‡ä»¶è®°å¿† | `.with_file_memory(path)` | `memory_dir=path` | `memoryDir: path` | `None` |
| è‡ªåŠ¨å‹ç¼© | `.with_auto_compact(true)` | `auto_compact=True` | `autoCompact: true` | `false` |
| è‡ªåŠ¨å‹ç¼©é˜ˆå€¼ | `.with_auto_compact_threshold(f)` | `auto_compact_threshold=f` | `autoCompactThreshold: f` | `0.8` |
| æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ | `.with_fs_context(path)` | `fs_context=path` | `fsContext: path` | `None` |
| é˜Ÿåˆ—é…ç½® | `.with_queue_config(cfg)` | `queue_config=cfg` | `queueConfig: cfg` | `None` |
| è§£æé‡è¯• | `.with_parse_retries(n)` | `max_parse_retries=n` | `maxParseRetries: n` | `2` |
| å·¥å…·è¶…æ—¶ | `.with_tool_timeout(ms)` | `tool_timeout_ms=ms` | `toolTimeoutMs: ms` | `None` |
| ç†”æ–­å™¨ | `.with_circuit_breaker(n)` | `circuit_breaker_threshold=n` | `circuitBreakerThreshold: n` | `3` |
| å¼¹æ€§é»˜è®¤å€¼ | `.with_resilience_defaults()` | â€” | â€” | â€” |
| æ²™ç®± | `.with_sandbox(cfg)` | â€” | â€” | `None` |
| æƒé™æ£€æŸ¥å™¨ | `.with_permission_checker(p)` | â€” | â€” | `PermissionPolicy` |
| ç¡®è®¤ç®¡ç†å™¨ | `.with_confirmation_manager(m)` | â€” | â€” | `None` |
| å®‰å…¨æä¾›è€… | `.with_security_provider(p)` | â€” | â€” | `None` |
| ä¸Šä¸‹æ–‡æä¾›è€… | `.with_context_provider(p)` | â€” | â€” | `None` |
| è®°å¿†å­˜å‚¨ | `.with_memory(store)` | â€” | â€” | `InMemoryStore` |
| Hook å¼•æ“ | `.with_hook_engine(h)` | â€” | â€” | `HookEngine` |

### AgentResponse

| å­—æ®µ | Rust | Python | Node.js |
|-------|------|--------|---------|
| æ–‡æœ¬ | `result.text` | `result.text` | `result.text` |
| æ€» token æ•° | `result.usage.total_tokens` | `result.usage.total_tokens` | `result.usage.totalTokens` |
| å·¥å…·è°ƒç”¨æ¬¡æ•° | `result.tool_calls_count` | `result.tool_calls_count` | `result.toolCallsCount` |
