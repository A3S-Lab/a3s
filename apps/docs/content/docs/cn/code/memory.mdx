---
title: 记忆系统
description: 可插拔的 Agent 长期记忆 — 跨会话存储、搜索和召回知识
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';

# 记忆系统

A3S Code 采用两层记忆架构。存储层（`a3s-memory`）负责 `MemoryStore` trait 及其默认实现；Agent 层（`a3s-code`）负责三层会话记忆（`AgentMemory`）和上下文注入（`MemoryContextProvider`）。

```
a3s-memory                          a3s-code
──────────────────────────────      ──────────────────────────────
MemoryStore (trait)                 AgentMemory
InMemoryStore                         ├── working    (Vec, 最多 10 条)
FileMemoryStore                       ├── short_term (VecDeque, 最多 100 条)
MemoryItem                            └── long_term  (→ MemoryStore)
MemoryType
RelevanceConfig                     MemoryConfig
                                    MemoryContextProvider
```

这种分层设计意味着你可以随时替换存储后端，而无需修改任何 Agent 代码。

## 快速开始

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};

let agent = Agent::new("agent.hcl").await?;

// 文件持久化记忆（重启后仍保留）
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_file_memory("./memory")
))?;

let result = session.send("记住：本项目部署在 AWS us-east-1").await?;
```
</Tab>
<Tab value="TypeScript">
```typescript
const agent = await Agent.create('agent.hcl');
const session = agent.session('.', {
  fileMemory: './memory',
});

const result = await session.send('记住：本项目部署在 AWS us-east-1');
```
</Tab>
<Tab value="Python">
```python
agent = Agent("agent.hcl")
session = agent.session(".", SessionOptions(
    file_memory="./memory",
))

result = session.send("记住：本项目部署在 AWS us-east-1")
```
</Tab>
</Tabs>

## 记忆类型

| 类型 | 用途 | 默认重要性 |
|------|------|-----------|
| `Episodic` | 具体事件和交互记录 | 0.5 |
| `Semantic` | 事实和领域知识 | 0.5–0.8 |
| `Procedural` | 成功模式（turn 完成后自动存储） | 0.8 |
| `Working` | 当前任务的活跃上下文 | 不固定 |

失败记录以 `Episodic` 类型存储，重要性为 `0.9`，高于成功记录，确保 Agent 不会重蹈覆辙。

## 三层会话记忆

```
工作记忆   — 活跃上下文，超出容量时按相关性自动裁剪（最多 10 条）
短期记忆   — 当前会话，超出容量时 FIFO 裁剪（最多 100 条）
长期记忆   — 通过 MemoryStore 持久化，会话重启后仍可访问
```

`remember()` 同时写入长期记忆和短期记忆。

```rust
let memory = session.memory().unwrap();

// 存储一条知识
memory.remember(
    MemoryItem::new("项目使用 PostgreSQL 15")
        .with_importance(0.8)
        .with_tag("database")
        .with_type(MemoryType::Semantic)
).await?;

// 便捷方法（自动设置重要性和标签）
memory.remember_success("通过 `just release` 完成部署").await?;
memory.remember_failure("未运行 fmt 检查直接发布会导致 CI 失败").await?;
```

## MemoryItem

每条记忆都是一个 `MemoryItem`，Builder API 让构建更简洁：

```rust
use a3s_memory::{MemoryItem, MemoryType};

let item = MemoryItem::new("文件 I/O 优先使用 write_all 而非 write")
    .with_importance(0.8)          // 0.0–1.0，自动截断
    .with_tag("rust")
    .with_tag("io")
    .with_type(MemoryType::Semantic)
    .with_metadata("source", "code-review");
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | `String` | UUID，自动生成 |
| `content` | `String` | 记忆内容 |
| `memory_type` | `MemoryType` | `Episodic`、`Semantic`、`Procedural`、`Working` |
| `importance` | `f32` | 0.0–1.0，自动截断 |
| `tags` | `Vec<String>` | 分类标签 |
| `metadata` | `HashMap<String, String>` | 任意键值对 |
| `timestamp` | `DateTime<Utc>` | 创建时间 |
| `access_count` | `u32` | 检索次数 |
| `last_accessed` | `Option<DateTime<Utc>>` | 最近检索时间 |

## 相关性评分

Agent 需要上下文时，会对每条记忆按以下公式打分并排序：

```
score = importance × importance_weight + exp(−age_days / decay_days) × recency_weight
```

默认配置：`importance_weight = 0.7`，`recency_weight = 0.3`，`decay_days = 30`。

通过 HCL 配置：

```hcl
memory {
  relevance {
    decay_days        = 30.0
    importance_weight = 0.7
    recency_weight    = 0.3
  }
  max_short_term = 100
  max_working    = 10
}
```

或在代码中配置：

```rust
use a3s_memory::RelevanceConfig;
use a3s_code_core::memory::MemoryConfig;

SessionOptions::new()
    .with_memory_config(MemoryConfig {
        relevance: RelevanceConfig {
            decay_days: 7.0,        // 短期会话，衰减更快
            importance_weight: 0.9,
            recency_weight: 0.1,
        },
        max_short_term: 100,
        max_working: 10,
    })
```

## 存储后端

### FileMemoryStore

默认的持久化后端。每条记忆对应一个 JSON 文件，外加一个轻量索引用于快速搜索：

```
memory/
  index.json          ← 轻量索引（id、tags、importance、timestamp）
  items/
    {uuid}.json       ← 完整记忆内容，原子写入
```

关键特性：
- 通过 `.tmp` → rename 原子写入，崩溃不会导致数据损坏
- 启动时将索引加载到内存，`search()` 和 `search_by_tags()` 速度快
- 对记忆 ID 进行路径穿越防护
- `rebuild_index()` 可通过扫描 item 文件从索引损坏中恢复

### InMemoryStore

临时存储，零配置。适合测试和短生命周期会话：

```rust
use a3s_memory::InMemoryStore;

SessionOptions::new()
    .with_memory(Arc::new(InMemoryStore::new()))
```

### 自定义后端

实现 `MemoryStore` trait 即可接入任意存储系统——SQLite、Redis、向量数据库：

```rust
use a3s_memory::{MemoryItem, MemoryStore};

struct MyVectorStore { /* ... */ }

#[async_trait::async_trait]
impl MemoryStore for MyVectorStore {
    async fn store(&self, item: MemoryItem) -> anyhow::Result<()> {
        // 对 item.content 做向量嵌入并 upsert 到向量数据库
        todo!()
    }

    async fn search(&self, query: &str, limit: usize) -> anyhow::Result<Vec<MemoryItem>> {
        // 对 query 做向量嵌入，ANN 搜索，返回 top-k
        todo!()
    }

    async fn retrieve(&self, id: &str) -> anyhow::Result<Option<MemoryItem>> { todo!() }
    async fn search_by_tags(&self, tags: &[String], limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn get_recent(&self, limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn get_important(&self, threshold: f32, limit: usize) -> anyhow::Result<Vec<MemoryItem>> { todo!() }
    async fn delete(&self, id: &str) -> anyhow::Result<()> { todo!() }
    async fn clear(&self) -> anyhow::Result<()> { todo!() }
    async fn count(&self) -> anyhow::Result<usize> { todo!() }
}

SessionOptions::new().with_memory(Arc::new(MyVectorStore::new()))
```

`FileMemoryStore` 的 `search()` 使用子串匹配。向量存储实现只需替换这一方法为语义相似度搜索，其余无需改动。

## 上下文注入

记忆激活后，`MemoryContextProvider` 会自动注册。每次 turn：

1. 通过子串匹配从记忆中检索最多 5 条相关内容
2. 以结构化上下文块的形式注入系统提示词
3. Turn 完成后，将本次交互存储为 `Procedural` 记忆

```
系统提示词
├── 基础指令
├── [memory] 用户偏好 TypeScript           ← MemoryContextProvider
├── [memory] 通过 `just release` 部署      ← MemoryContextProvider
├── [resource] 相关代码片段                ← FileSystemContextProvider
└── 工具定义
```

## 事件

| 事件 | 说明 |
|------|------|
| `MemoryStored` | 记忆条目已持久化 |
| `MemoryRecalled` | 记忆条目已被检索用于上下文 |
| `MemoriesSearched` | 执行了一次记忆搜索 |
| `MemoryCleared` | 所有记忆已清除 |

## API 参考

### SessionOptions

| 方法 | 说明 |
|------|------|
| `.with_file_memory(path)` | 在指定路径启用 `FileMemoryStore` |
| `.with_memory(Arc<dyn MemoryStore>)` | 使用自定义后端 |
| `.with_memory_config(MemoryConfig)` | 配置相关性评分和各层容量 |

### MemoryStore trait

| 方法 | 说明 |
|------|------|
| `store(item)` | 持久化记忆条目（按 ID upsert） |
| `retrieve(id)` | 按 ID 获取单条记忆 |
| `search(query, limit)` | 子串搜索，按相关性排序 |
| `search_by_tags(tags, limit)` | 按标签过滤，按相关性排序 |
| `get_recent(limit)` | 最近创建的记忆 |
| `get_important(threshold, limit)` | 重要性高于阈值的记忆，降序排列 |
| `delete(id)` | 删除单条记忆 |
| `clear()` | 清除所有记忆 |
| `count()` | 记忆总数 |

<Callout type="info">
`a3s-memory` 是独立 crate，无需完整 Agent 框架即可使用：`cargo add a3s-memory`
</Callout>
