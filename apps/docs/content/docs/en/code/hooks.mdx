---
title: Lifecycle Hooks
description: 8 lifecycle hooks for intercepting tool calls, LLM generations, sessions, and skills
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

# Lifecycle Hooks

A3S Code provides 8 lifecycle hooks for intercepting and reacting to events during agent execution. Hooks enable logging, security enforcement, telemetry, and custom behavior without modifying the core agent loop.

## Hook Events

<TypeTable
  type={{
    "PreToolUse": {
      description: "Fires: Before tool execution · Use Case: Validate args, taint tracking, block dangerous calls",
    },
    "PostToolUse": {
      description: "Fires: After tool execution · Use Case: Audit logging, injection scanning, output filtering",
    },
    "GenerateStart": {
      description: "Fires: Before LLM call · Use Case: Injection detection, prompt logging",
    },
    "GenerateEnd": {
      description: "Fires: After LLM response · Use Case: Output sanitization, PII redaction",
    },
    "SessionStart": {
      description: "Fires: Session created · Use Case: Initialize session resources",
    },
    "SessionEnd": {
      description: "Fires: Session destroyed · Use Case: Cleanup, persist state",
    },
    "SkillLoad": {
      description: "Fires: Skill loaded · Use Case: Validate skill, log activation",
    },
    "SkillUnload": {
      description: "Fires: Skill unloaded · Use Case: Cleanup skill resources",
    },
  }}
/>

## How Hooks Work

Hooks are registered on the `HookEngine` and fire at specific points in the agent loop. Multiple hooks can listen to the same event — they execute in priority order (lower number = higher priority).

```
Agent Loop
  ├── GenerateStart hooks fire
  ├── LLM call
  ├── GenerateEnd hooks fire
  └── For each tool_use:
      ├── PreToolUse hooks fire
      ├── Permission check
      ├── HITL check
      ├── Tool execution
      └── PostToolUse hooks fire
```

## Built-in SecurityGuard

The `SecurityGuard` registers hooks at priority 1 (highest) automatically:

<TypeTable
  type={{
    "PreToolUse": {
      description: "Taint tracking — checks if sensitive values leak into tool arguments",
    },
    "PostToolUse": {
      description: "Injection scanning — detects prompt injection in tool outputs",
    },
    "GenerateStart": {
      description: "Injection detection — scans user prompt for injection patterns",
    },
    "GenerateEnd": {
      description: "Output sanitization — redacts PII from LLM responses",
    },
  }}
/>

## Hook Registration (Rust)

Register hooks and handlers via the `HookEngine`:

```rust
use a3s_code_core::hooks::{
    Hook, HookConfig, HookEngine, HookEvent, HookEventType,
    HookHandler, HookResult, HookResponse, HookMatcher,
};
use std::sync::Arc;

let engine = HookEngine::new();

// 1. Register a hook definition (what to listen for)
engine.register(
    Hook::new("log-tools", HookEventType::PreToolUse)
        .with_config(HookConfig { priority: 10, ..Default::default() })
);

// 2. Register a handler (what to do when fired)
struct LogHandler;
impl HookHandler for LogHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            println!("Tool: {} Args: {:?}", e.tool, e.args);
        }
        HookResponse::continue_()
    }
}
engine.register_handler("log-tools", Arc::new(LogHandler));

// Block dangerous patterns
engine.register(
    Hook::new("block-dangerous", HookEventType::PreToolUse)
        .with_matcher(HookMatcher::tool("bash"))
        .with_config(HookConfig { priority: 5, ..Default::default() })
);

struct BlockHandler;
impl HookHandler for BlockHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            if e.args.to_string().contains("rm -rf") {
                return HookResponse::block("Dangerous command blocked");
            }
        }
        HookResponse::continue_()
    }
}
engine.register_handler("block-dangerous", Arc::new(BlockHandler));

// Fire a hook (done automatically by the agent loop)
let result = engine.fire(&event).await;
match result {
    HookResult::Continue(None) => { /* proceed */ }
    HookResult::Continue(Some(modified)) => { /* proceed with modified data */ }
    HookResult::Block(reason) => { /* stop execution */ }
    _ => {}
}
```

## Hook Priority

Hooks execute in priority order. Lower numbers run first.

<TypeTable
  type={{
    "1": {
      description: "SecurityGuard (built-in, always runs first)",
    },
    "2-9": {
      description: "Critical custom hooks (validation, blocking)",
    },
    "10-49": {
      description: "Standard hooks (logging, telemetry)",
    },
    "50+": {
      description: "Low-priority hooks (analytics, optional processing)",
    },
  }}
/>

If any hook returns `HookResult::Block`, the operation is cancelled and subsequent hooks for that event are skipped.

## Hook Event Payloads

Each hook event carries a typed payload with event-specific data:

<Accordions>
<Accordion title="PreToolUse — PreToolUseEvent">

<TypeTable
  type={{
    session_id: {
      type: 'String',
      description: 'Session identifier',
    },
    tool: {
      type: 'String',
      description: 'Tool name being called',
    },
    args: {
      type: 'Value',
      description: 'Tool arguments',
    },
    working_directory: {
      type: 'String',
      description: 'Current workspace path',
    },
    recent_tools: {
      type: 'Vec<String>',
      description: 'Recently called tools',
    },
  }}
/>

</Accordion>
<Accordion title="PostToolUse — PostToolUseEvent">

<TypeTable
  type={{
    session_id: {
      type: 'String',
      description: 'Session identifier',
    },
    tool: {
      type: 'String',
      description: 'Tool name',
    },
    args: {
      type: 'Value',
      description: 'Tool arguments',
    },
    'result.success': {
      type: 'bool',
      description: 'Whether tool succeeded',
    },
    'result.output': {
      type: 'String',
      description: 'Tool output text',
    },
    'result.exit_code': {
      type: 'i32',
      description: 'Exit code',
    },
    'result.duration_ms': {
      type: 'u64',
      description: 'Execution time',
    },
  }}
/>

</Accordion>
<Accordion title="GenerateStart — GenerateStartEvent">

<TypeTable
  type={{
    session_id: {
      type: 'String',
      description: 'Session identifier',
    },
    prompt: {
      type: 'String',
      description: 'User prompt',
    },
    system_prompt: {
      type: 'String',
      description: 'System prompt',
    },
    model_provider: {
      type: 'String',
      description: 'Provider name',
    },
    model_name: {
      type: 'String',
      description: 'Model name',
    },
    available_tools: {
      type: 'Vec<String>',
      description: 'Registered tool names',
    },
  }}
/>

</Accordion>
<Accordion title="GenerateEnd — GenerateEndEvent">

<TypeTable
  type={{
    session_id: {
      type: 'String',
      description: 'Session identifier',
    },
    response_text: {
      type: 'String',
      description: 'LLM response',
    },
    tool_calls: {
      type: 'Vec<String>',
      description: 'Tools called this turn',
    },
    'usage.total_tokens': {
      type: 'u32',
      description: 'Token usage',
    },
    duration_ms: {
      type: 'u64',
      description: 'Generation time',
    },
  }}
/>

</Accordion>
<Accordion title="SessionStart / SessionEnd">

**SessionStartEvent:** `session_id`, `system_prompt`, `model_provider`, `model_name`

**SessionEndEvent:** `session_id`, `total_tokens`, `total_tool_calls`, `duration_ms`

</Accordion>
<Accordion title="SkillLoad / SkillUnload">

**SkillLoadEvent:** `skill_name`, `tool_names`, `version`, `description`, `loaded_at`

**SkillUnloadEvent:** `skill_name`, `tool_names`, `duration_ms`

</Accordion>
</Accordions>

## API Reference

### Hook registration

<TypeTable
  type={{
    "Register hook": {
      description: {`Rust: \`session.register_hook(Hook::new(id, event_type))\` · Description: Register a hook listener`},
    },
    "Register handler": {
      description: {`Rust: \`session.register_hook_handler(id, Arc::new(handler))\` · Description: Attach handler to hook`},
    },
    "Unregister": {
      description: {`Rust: \`session.unregister_hook(id)\` · Description: Remove hook and handler`},
    },
    "Count": {
      description: {`Rust: \`session.hook_count()\` · Description: Number of registered hooks`},
    },
  }}
/>

### HookHandler trait (Rust)

```rust
impl HookHandler for MyHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        match event {
            HookEvent::PreToolUse(e) => { /* ... */ }
            _ => {}
        }
        HookResponse::continue_()
    }
}
```

### HookResponse values

<TypeTable
  type={{
    "HookResponse::continue_()": {
      description: "Allow the operation to proceed",
    },
    "HookResponse::block(reason)": {
      description: "Cancel the operation with a reason string",
    },
    "HookResponse::modify(data)": {
      description: "Replace event data before execution",
    },
  }}
/>

### Hook priority

Lower number = higher priority. `SecurityGuard` uses priority `1`. Default hooks use priority `100`.

```rust
Hook::new("my-hook", HookEventType::PreToolUse).with_priority(50)
```
