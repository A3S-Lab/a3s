---
title: Built-in Tools
description: 11 built-in tools (12 with sandbox) for file operations, shell execution, search, web access, and subagent delegation
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Built-in Tools

A3S Code ships with 11 built-in tools (12 with the `sandbox` feature) covering file operations, shell execution, search, web access, and subagent delegation. All tools execute in-process via native Rust implementations.

## Tool Reference

<TypeTable
  type={
    {`\`read\``}: {
      description: "Purpose: Read files with line numbers · Example: View source code",
    },
    {`\`write\``}: {
      description: "Purpose: Create/overwrite files · Example: Create new files",
    },
    {`\`edit\``}: {
      description: "Purpose: String replacement editing · Example: Modify existing code",
    },
    {`\`patch\``}: {
      description: "Purpose: Apply unified diff patches · Example: Complex multi-line edits",
    },
    {`\`bash\``}: {
      description: {`Purpose: Execute shell commands · Example: \`git status\`, \`npm install\``},
    },
    {`\`grep\``}: {
      description: "Purpose: Search file contents (ripgrep) · Example: Find function definitions",
    },
    {`\`glob\``}: {
      description: {`Purpose: Find files by pattern · Example: \`/*.ts\`, \`src//*.rs\``},
    },
    {`\`ls\``}: {
      description: "Purpose: List directory contents · Example: Explore project structure",
    },
    {`\`web_fetch\``}: {
      description: "Purpose: Fetch web content · Example: Download documentation",
    },
    {`\`web_search\``}: {
      description: "Purpose: Search the web · Example: Query multiple search engines",
    },
    {`\`task\``}: {
      description: "Purpose: Delegate to subagents · Example: Offload specialized work",
    },
    {`\`sandbox\``}: {
      description: {`Purpose: Execute in MicroVM · Example: Isolated execution (\`sandbox\` feature)`},
    },
  }
/>

## File Operations

### `read`

Read file contents with line numbers. Supports offset and limit for large files.

```json
{
  "file_path": "src/main.rs",
  "offset": 0,
  "limit": 100
}
```

### `write`

Create or overwrite a file. Automatically creates parent directories.

```json
{
  "file_path": "src/config.rs",
  "content": "pub struct Config {\n    pub port: u16,\n}\n"
}
```

### `edit`

Replace a specific string in a file. Useful for targeted modifications.

```json
{
  "file_path": "src/main.rs",
  "old_string": "fn main() {",
  "new_string": "fn main() -> Result<()> {"
}
```

### `patch`

Apply a unified diff patch. Best for complex multi-line edits.

```json
{
  "file_path": "src/lib.rs",
  "diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use std::io;\n"
}
```

## Search

### `grep`

Search file contents using ripgrep patterns. Supports regex, globs, and context lines.

```json
{
  "pattern": "fn.*async",
  "path": "src/",
  "glob": "*.rs",
  "context": 2
}
```

### `glob`

Find files matching a glob pattern.

```json
{
  "pattern": "src/**/*.rs"
}
```

### `ls`

List directory contents with file sizes and types.

```json
{
  "path": "src/"
}
```

## Shell

### `bash`

Execute shell commands. Commands run in the session's workspace directory.

```json
{
  "command": "cargo test --lib -- test_name"
}
```

**Security:** Use [Permission System](/docs/code/security) to control bash access:

```rust
policy.deny("bash(rm -rf:*)");  // Block destructive commands
policy.ask("bash(*)");          // Require confirmation for all bash
```

## Web

### `web_fetch`

Fetch content from a URL. Returns text content extracted from HTML.

```json
{
  "url": "https://docs.rs/tokio/latest/tokio/"
}
```

### `web_search`

Search the web using multiple search engines.

```json
{
  "query": "rust async trait object",
  "engine": "google"
}
```

## Direct Tool Execution

Call tools directly on the session without going through the LLM:

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
// Convenience wrappers
let content = session.read_file("src/main.rs").await?;
let output = session.bash("cargo test --lib").await?;
let files = session.glob("**/*.rs").await?;
let matches = session.grep("fn main").await?;

// Generic tool call with JSON args
let result = session.tool("edit", serde_json::json!({
    "file_path": "src/main.rs",
    "old_string": "fn main() {",
    "new_string": "fn main() -> Result<()> {"
})).await?;
println!("[{}] {}", result.exit_code, result.output);
```
</Tab>
<Tab value="TypeScript">
```typescript
// Convenience wrappers
const content = await session.readFile('src/main.rs');
const output = await session.bash('cargo test --lib');
const files = await session.glob('**/*.rs');
const matches = await session.grep('fn main');

// Generic tool call
const result = await session.tool('edit', {
  file_path: 'src/main.rs',
  old_string: 'fn main() {',
  new_string: 'fn main() -> Result<()> {',
});
console.log(`[${result.exitCode}] ${result.output}`);
```
</Tab>
<Tab value="Python">
```python
# Convenience wrappers
content = session.read_file("src/main.rs")
output = session.bash("cargo test --lib")
files = session.glob("**/*.rs")
matches = session.grep("fn main")

# Generic tool call with dict args
result = session.tool("edit", {
    "file_path": "src/main.rs",
    "old_string": "fn main() {",
    "new_string": "fn main() -> Result<()> {"
})
print(f"[{result['exit_code']}] {result['output']}")
```
</Tab>
</Tabs>

## Subagent Delegation

### `task`

Delegate work to a specialized child agent. The child agent runs in its own session with its own conversation history. See [Subagents](/docs/code/subagents) for details.

```json
{
  "description": "Write unit tests for the auth module",
  "prompt": "Create comprehensive tests for src/auth.rs covering all edge cases"
}
```

## Sandbox (Optional)

### `sandbox`

Execute commands in an isolated [A3S Box](/docs/box) MicroVM. Requires the `sandbox` Cargo feature.

```toml
a3s-code-core = { version = "0.7", features = ["sandbox"] }
```

Two modes of operation:

**Transparent Routing** — When `SandboxConfig` is set on the session, the `bash` tool silently routes through the sandbox:

```rust
use a3s_code_core::{SessionOptions, SandboxConfig};

let session = agent.session(".", Some(
    SessionOptions::new().with_sandbox(SandboxConfig {
        image: "ubuntu:22.04".into(),
        memory_mb: 512,
        network: false,
        ..SandboxConfig::default()
    })
))?;

// bash commands run inside the MicroVM sandbox
let result = session.send("Run the test suite", None).await?;
```

**Explicit `sandbox` Tool** — With the feature enabled, a `sandbox` tool is registered so the LLM can choose to use it explicitly. The workspace is mounted at `/workspace` inside the sandbox.

<TypeTable
  type={{
    image: {
      type: 'string',
      default: '"alpine:latest"',
      description: 'OCI image reference',
    },
    memory_mb: {
      type: 'u32',
      default: '512',
      description: 'Memory limit in megabytes',
    },
    cpus: {
      type: 'u32',
      default: '1',
      description: 'Number of vCPUs',
    },
    network: {
      type: 'bool',
      default: 'false',
      description: 'Enable outbound networking',
    },
    env: {
      type: 'HashMap<String, String>',
      default: '{}',
      description: 'Environment variables to inject',
    },
  }}
/>

## File Version History

All file-modifying tools (`write`, `edit`, `patch`) automatically capture a snapshot before making changes. You can:

- View the diff between versions
- Restore any previous version
- Track all modifications made during a session

The file history maintains up to 500 snapshots per session.

## Extending with Custom Tools

Beyond built-in tools, A3S Code supports external tool integration via:

- **[MCP](/docs/code/mcp)** — Connect external tool servers via Model Context Protocol (JSON-RPC 2.0, stdio + HTTP+SSE)
- **Custom Tool Trait** — Implement the `Tool` trait in Rust and register with `ToolRegistry`

See [MCP](/docs/code/mcp) for external tool integration examples.

## API Reference

### Tool input/output schemas

#### read

<TypeTable
  type={{
    file_path: { type: 'string', required: true, description: 'Absolute or workspace-relative path' },
    offset: { type: 'number', description: 'Start line (1-based)' },
    limit: { type: 'number', description: 'Max lines to return' },
  }}
/>

#### write

<TypeTable
  type={{
    file_path: { type: 'string', required: true, description: 'Path to write' },
    content: { type: 'string', required: true, description: 'Full file content' },
  }}
/>

#### edit

<TypeTable
  type={{
    file_path: { type: 'string', required: true, description: 'Path to edit' },
    old_string: { type: 'string', required: true, description: 'Exact string to replace' },
    new_string: { type: 'string', required: true, description: 'Replacement string' },
    replace_all: { type: 'boolean', default: 'false', description: 'Replace all occurrences' },
  }}
/>

#### patch

<TypeTable
  type={{
    file_path: { type: 'string', required: true, description: 'Path to patch' },
    diff: { type: 'string', required: true, description: 'Unified diff string' },
  }}
/>

#### grep

<TypeTable
  type={{
    pattern: { type: 'string', required: true, description: 'Regex or literal pattern' },
    path: { type: 'string', description: 'Directory or file to search (default: workspace root)' },
    glob: { type: 'string', description: 'File glob filter (e.g. `**/*.rs`)' },
    '-i': { type: 'boolean', description: 'Case-insensitive' },
    '-n': { type: 'boolean', description: 'Include line numbers' },
    context: { type: 'number', description: 'Lines of context around matches' },
  }}
/>

#### glob

<TypeTable
  type={{
    pattern: { type: 'string', required: true, description: 'Glob pattern (e.g. `**/*.rs`)' },
    path: { type: 'string', description: 'Base directory (default: workspace root)' },
  }}
/>

#### ls

<TypeTable
  type={{
    path: { type: 'string', description: 'Directory to list (default: workspace root)' },
  }}
/>

#### bash

<TypeTable
  type={{
    command: { type: 'string', required: true, description: 'Shell command to execute' },
    timeout: { type: 'number', description: 'Timeout in ms' },
    env: { type: 'object', description: 'Extra environment variables' },
  }}
/>

#### web_fetch

<TypeTable
  type={{
    url: { type: 'string', required: true, description: 'URL to fetch' },
    prompt: { type: 'string', description: 'Extraction prompt for the fetched content' },
  }}
/>

#### web_search

<TypeTable
  type={{
    query: { type: 'string', required: true, description: 'Search query' },
    allowed_domains: { type: 'string[]', description: 'Restrict results to these domains' },
    blocked_domains: { type: 'string[]', description: 'Exclude these domains' },
  }}
/>

#### task

<TypeTable
  type={{
    agent: { type: 'string', required: true, description: 'Agent name to delegate to' },
    prompt: { type: 'string', required: true, description: 'Task prompt for the subagent' },
    workspace: { type: 'string', description: 'Workspace override (default: current)' },
  }}
/>

#### batch

<TypeTable
  type={{
    invocations: { type: 'array', required: true, description: 'List of `{tool, args}` objects to run in parallel' },
  }}
/>

### Custom Tool trait (Rust)

```rust
use a3s_code_core::tools::{Tool, ToolOutput};
use async_trait::async_trait;

#[async_trait]
impl Tool for MyTool {
    fn name(&self) -> &str { "my_tool" }
    fn description(&self) -> &str { "Does something useful" }
    fn parameters(&self) -> serde_json::Value { /* JSON Schema */ }
    async fn execute(&self, args: serde_json::Value) -> anyhow::Result<ToolOutput> {
        Ok(ToolOutput::success("result"))
    }
}

session.register_tool(Arc::new(MyTool));
```
