---
title: Hooks
description: Lifecycle event interception — PreToolUse, PostToolUse, PrePrompt, PostResponse, OnError
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';

# Hooks

Hooks let you intercept agent lifecycle events to audit, modify, or block operations. Register a `Hook` + `HookHandler` pair on a session.

## Hook Event Types

<TypeTable
  type={
    {`\`PreToolUse\``}: {
      description: "Fires when: Before a tool executes · Can block?: ✅",
    },
    {`\`PostToolUse\``}: {
      description: "Fires when: After a tool completes · Can block?: ❌",
    },
    {`\`PrePrompt\``}: {
      description: "Fires when: Before prompt is sent to LLM · Can block?: ✅",
    },
    {`\`PostResponse\``}: {
      description: "Fires when: After LLM responds · Can block?: ❌",
    },
    {`\`OnError\``}: {
      description: "Fires when: On any agent error · Can block?: ❌",
    },
    {`\`GenerateStart\``}: {
      description: "Fires when: LLM generation begins · Can block?: ❌",
    },
    {`\`GenerateEnd\``}: {
      description: "Fires when: LLM generation ends · Can block?: ❌",
    },
    {`\`SessionStart\` / \`SessionEnd\``}: {
      description: "Fires when: Session lifecycle · Can block?: ❌",
    },
  }
/>

## Audit Hook (Log All Tool Calls)

<Tabs groupId="lang" items={['Rust', 'Python', 'Node.js']}>
<Tab value="Rust">
```rust
use a3s_code_core::hooks::{Hook, HookEvent, HookEventType, HookHandler, HookResponse};
use std::sync::{Arc, Mutex};

struct AuditHandler {
    log: Arc<Mutex<Vec<String>>>,
}

impl HookHandler for AuditHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            println!("→ tool: {}", e.tool);
            self.log.lock().unwrap().push(e.tool.clone());
        }
        HookResponse::continue_()
    }
}

// Register
let log = Arc::new(Mutex::new(Vec::new()));
let hook = Hook::new("audit", HookEventType::PreToolUse);
session.register_hook(hook);
session.register_hook_handler("audit", Arc::new(AuditHandler { log: Arc::clone(&log) }));

println!("Hooks: {}", session.hook_count());

// Run agent
let result = session.send("List files in the workspace", None).await?;

// Inspect log
println!("Tools called: {:?}", log.lock().unwrap());

// Cleanup
session.unregister_hook("audit");
```

**Run:** `cargo run --example test_hooks`
**Source:** [`core/examples/test_hooks.rs`](https://github.com/A3S-Lab/Code/blob/main/core/examples/test_hooks.rs)
</Tab>
<Tab value="Python">
```python
tool_log = []

def on_pre_tool_use(event):
    tool = event.get("tool", "unknown")
    print(f"→ tool: {tool}")
    tool_log.append(tool)
    return None  # allow execution

session.register_hook("audit", "pre_tool_use", on_pre_tool_use)
print(f"Hooks: {session.hook_count()}")

result = await session.send("List files in the workspace")

print(f"Tools called: {tool_log}")
session.unregister_hook("audit")
```

**Run:** `python examples/test_advanced_features.py`
**Source:** [`sdk/python/examples/test_advanced_features.py`](https://github.com/A3S-Lab/Code/blob/main/sdk/python/examples/test_advanced_features.py)
</Tab>
<Tab value="Node.js">
```javascript
const toolLog = [];

session.registerHook('audit', 'pre_tool_use', (event) => {
  const tool = event.tool || 'unknown';
  console.log(`→ tool: ${tool}`);
  toolLog.push(tool);
  return null; // allow execution
});

console.log(`Hooks: ${session.hookCount()}`);

const result = await session.send('List files in the workspace');

console.log('Tools called:', toolLog);
session.unregisterHook('audit');
```

**Run:** `node examples/test_advanced_features.js`
**Source:** [`sdk/node/examples/test_advanced_features.js`](https://github.com/A3S-Lab/Code/blob/main/sdk/node/examples/test_advanced_features.js)
</Tab>
</Tabs>

## Block Hook (Deny Specific Tools)

<Tabs groupId="lang" items={['Rust', 'Python', 'Node.js']}>
<Tab value="Rust">
```rust
struct DenyBashHandler;

impl HookHandler for DenyBashHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            if e.tool == "bash" {
                return HookResponse::block("bash is not allowed in this session");
            }
        }
        HookResponse::continue_()
    }
}

let hook = Hook::new("no-bash", HookEventType::PreToolUse);
session.register_hook(hook);
session.register_hook_handler("no-bash", Arc::new(DenyBashHandler));
```
</Tab>
<Tab value="Python">
```python
def deny_bash(event):
    if event.get("tool") == "bash":
        return {"action": "block", "reason": "bash is not allowed"}
    return None

session.register_hook("no-bash", "pre_tool_use", deny_bash)
```
</Tab>
<Tab value="Node.js">
```javascript
session.registerHook('no-bash', 'pre_tool_use', (event) => {
  if (event.tool === 'bash') {
    return { action: 'block', reason: 'bash is not allowed' };
  }
  return null;
});
```
</Tab>
</Tabs>

<Callout type="info">
For persistent hook configuration across sessions, see [Hooks](/docs/code/hooks).
</Callout>

## API Reference

### Hook Registration

<TypeTable
  type={
    "Register hook": {
      description: {`Rust: \`session.register_hook(hook)\` · Python: \`session.register_hook(id, event, fn)\` · Node.js: \`session.registerHook(id, event, fn)\``},
    },
    "Register handler": {
      description: {`Rust: \`session.register_hook_handler(id, Arc::new(h))\` · Python: _(combined with register)_ · Node.js: _(combined with register)_`},
    },
    "Unregister": {
      description: {`Rust: \`session.unregister_hook(id)\` · Python: \`session.unregister_hook(id)\` · Node.js: \`session.unregisterHook(id)\``},
    },
    "Count": {
      description: {`Rust: \`session.hook_count()\` · Python: \`session.hook_count()\` · Node.js: \`session.hookCount()\``},
    },
  }
/>

### HookResponse (Rust)

<TypeTable
  type={
    {`\`HookResponse::continue_()\``}: {
      description: "Allow the operation to proceed",
    },
    {`\`HookResponse::block(reason)\``}: {
      description: "Cancel the operation with a reason",
    },
    {`\`HookResponse::modify(data)\``}: {
      description: "Replace the event data before execution",
    },
  }
/>

### Hook Event Fields

<TypeTable
  type={
    {`\`PreToolUse\``}: {
      description: {`\`tool: String\`, \`args: Value\``},
    },
    {`\`PostToolUse\``}: {
      description: {`\`tool: String\`, \`output: String\`, \`exit_code: i32\``},
    },
    {`\`PrePrompt\``}: {
      description: {`\`prompt: String\``},
    },
    {`\`PostResponse\``}: {
      description: {`\`text: String\`, \`usage: Usage\``},
    },
    {`\`OnError\``}: {
      description: {`\`error: String\`, \`turn: u32\``},
    },
  }
/>
