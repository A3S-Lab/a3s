---
title: Session Persistence
description: Pluggable session storage backends for conversation persistence
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Session Persistence

A3S Code supports pluggable session storage backends. Sessions save conversation history and can be resumed across restarts.

## Quick Start

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};
use a3s_code_core::store::FileSessionStore;

let agent = Agent::new("agent.hcl").await?;

// File-based session with auto-save
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_file_session_store(".a3s/sessions")
        .with_session_id("my-session")
        .with_auto_save(true)
))?;

let result = session.send("Refactor auth", None).await?;
// Session is auto-saved after each send()

// Manual save
session.save().await?;

// Resume later
let session = agent.resume_session("my-session", SessionOptions::new()
    .with_file_session_store(".a3s/sessions")
)?;
println!("Resumed with {} messages", session.history().len());
```
</Tab>
<Tab value="TypeScript">
```typescript
const agent = await Agent.create('agent.hcl');

// Create with auto-save
const session = agent.session('.', {
  fileSessionStore: '.a3s/sessions',
  sessionId: 'my-session',
  autoSave: true,
});

await session.send('Refactor auth');

// Resume
const resumed = agent.resumeSession('my-session', {
  fileSessionStore: '.a3s/sessions',
});
```
</Tab>
<Tab value="Python">
```python
agent = Agent.create("agent.hcl")

session = agent.session(".", SessionOptions(
    file_session_store=".a3s/sessions",
    session_id="my-session",
    auto_save=True,
))

session.send("Refactor auth")

# Resume
resumed = agent.resume_session("my-session", SessionOptions(
    file_session_store=".a3s/sessions",
))
```
</Tab>
</Tabs>

## File Storage

`FileSessionStore` stores each session as a JSON file:

```
sessions_dir/
├── my-session.json
├── other-session.json
└── ...
```

- Atomic writes (write `.tmp` → rename) — safe on crash
- Full conversation history preserved
- Human-readable JSON format

## Session API

<TypeTable
  type={{
    "session_id()": {
      description: "Return the session's unique ID",
    },
    "save()": {
      description: "Persist current history to the store (no-op if no store)",
    },
    "agent.resume_session(id, opts)": {
      description: "Load a saved session and restore history",
    },
  }}
/>

## Auto-Save

When `with_auto_save(true)` is set, the session saves after each `send()` call that uses internal history. Failures are logged as warnings (non-fatal).

```rust
SessionOptions::new()
    .with_file_session_store(".a3s/sessions")
    .with_auto_save(true)
```

## Custom Storage Backend

For production deployments (PostgreSQL, Redis, S3, etc.), implement the `SessionStore` trait:

```rust
use a3s_code_core::store::{SessionStore, SessionData};

#[async_trait::async_trait]
impl SessionStore for PostgresStore {
    async fn save(&self, session: &SessionData) -> Result<()> { /* ... */ }
    async fn load(&self, id: &str) -> Result<Option<SessionData>> { /* ... */ }
    async fn delete(&self, id: &str) -> Result<()> { /* ... */ }
    async fn list(&self) -> Result<Vec<String>> { /* ... */ }
    async fn exists(&self, id: &str) -> Result<bool> { /* ... */ }
}

// Use it
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_session_store(Arc::new(PostgresStore::new(...).await?))
))?;
```

## SessionData Structure

What gets persisted per session:

<TypeTable
  type={{
    "id": {
      description: "Session identifier",
    },
    "messages": {
      description: "Full conversation history",
    },
    "config.workspace": {
      description: "Workspace path",
    },
    "config.system_prompt": {
      description: "System prompt",
    },
    "config.planning_enabled": {
      description: "Planning flag",
    },
    "tool_names": {
      description: "Tool names (rebuilt on resume)",
    },
  }}
/>

## API Reference

### SessionOptions

<TypeTable
  type={{
    "Custom store": {
      description: {`Rust: \`.with_session_store(Arc::new(s))\` · Python: _(Rust only)_ · Node.js: _(Rust only)_ · Default: \`FileSessionStore\``},
    },
  }}
/>

### SessionStore trait (Rust)

<TypeTable
  type={{
    "save": {
      description: {`Signature: \`async fn save(&self, data: &SessionData) -> Result<()>\` · Description: Persist session data`},
    },
    "load": {
      description: {`Signature: \`async fn load(&self, id: &str) -> Result<Option<SessionData>>\` · Description: Load session by ID`},
    },
    "delete": {
      description: {`Signature: \`async fn delete(&self, id: &str) -> Result<()>\` · Description: Remove session`},
    },
    "list": {
      description: {`Signature: \`async fn list(&self) -> Result<Vec<String>>\` · Description: List all session IDs`},
    },
  }}
/>

### SessionData fields

<TypeTable
  type={{
    id: { type: 'String', description: 'Session identifier' },
    messages: { type: 'Vec<Message>', description: 'Full conversation history' },
    tasks: { type: 'Vec<AgentTask>', description: 'Task list (alias: `todos`)' },
    'config.workspace': { type: 'String', description: 'Workspace path' },
    'config.system_prompt': { type: 'String', description: 'System prompt' },
    'config.planning_enabled': { type: 'bool', description: 'Planning flag' },
    tool_names: { type: 'Vec<String>', description: 'Tool names (rebuilt on resume)' },
    created_at: { type: 'DateTime<Utc>', description: 'Session creation time' },
    updated_at: { type: 'DateTime<Utc>', description: 'Last save time' },
  }}
/>

### Session management methods

<TypeTable
  type={{
    "Save session": {
      description: {`Rust: \`session.save().await?\` · Description: Persist current state`},
    },
    "Load session": {
      description: {`Rust: \`agent.resume(id, options?)?\` · Description: Resume from stored state`},
    },
    "List sessions": {
      description: {`Rust: \`agent.list_sessions().await?\` · Description: List all saved session IDs`},
    },
    "Delete session": {
      description: {`Rust: \`agent.delete_session(id).await?\` · Description: Remove stored session`},
    },
  }}
/>
