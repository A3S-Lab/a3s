---
title: Session Persistence
description: Pluggable session storage backends for conversation persistence
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Session Persistence

A3S Code supports pluggable session storage backends. Sessions save conversation history and can be resumed across restarts.

## Quick Start

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};
use a3s_code_core::store::FileSessionStore;

let agent = Agent::new("agent.hcl").await?;

// File-based session with auto-save
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_file_session_store(".a3s/sessions")
        .with_session_id("my-session")
        .with_auto_save(true)
))?;

let result = session.send("Refactor auth", None).await?;
// Session is auto-saved after each send()

// Manual save
session.save().await?;

// Resume later
let session = agent.resume_session("my-session", SessionOptions::new()
    .with_file_session_store(".a3s/sessions")
)?;
println!("Resumed with {} messages", session.history().len());
```
</Tab>
<Tab value="TypeScript">
```typescript
const agent = await Agent.create('agent.hcl');

// Create with auto-save
const session = agent.session('.', {
  fileSessionStore: '.a3s/sessions',
  sessionId: 'my-session',
  autoSave: true,
});

await session.send('Refactor auth');

// Resume
const resumed = agent.resumeSession('my-session', {
  fileSessionStore: '.a3s/sessions',
});
```
</Tab>
<Tab value="Python">
```python
agent = Agent.create("agent.hcl")

session = agent.session(".", SessionOptions(
    file_session_store=".a3s/sessions",
    session_id="my-session",
    auto_save=True,
))

session.send("Refactor auth")

# Resume
resumed = agent.resume_session("my-session", SessionOptions(
    file_session_store=".a3s/sessions",
))
```
</Tab>
</Tabs>

## File Storage

`FileSessionStore` stores each session as a JSON file:

```
sessions_dir/
├── my-session.json
├── other-session.json
└── ...
```

- Atomic writes (write `.tmp` → rename) — safe on crash
- Full conversation history preserved
- Human-readable JSON format

## Session API

| Method | Description |
|--------|-------------|
| `session_id()` | Return the session's unique ID |
| `save()` | Persist current history to the store (no-op if no store) |
| `agent.resume_session(id, opts)` | Load a saved session and restore history |

## Auto-Save

When `with_auto_save(true)` is set, the session saves after each `send()` call that uses internal history. Failures are logged as warnings (non-fatal).

```rust
SessionOptions::new()
    .with_file_session_store(".a3s/sessions")
    .with_auto_save(true)
```

## Custom Storage Backend

For production deployments (PostgreSQL, Redis, S3, etc.), implement the `SessionStore` trait:

```rust
use a3s_code_core::store::{SessionStore, SessionData};

#[async_trait::async_trait]
impl SessionStore for PostgresStore {
    async fn save(&self, session: &SessionData) -> Result<()> { /* ... */ }
    async fn load(&self, id: &str) -> Result<Option<SessionData>> { /* ... */ }
    async fn delete(&self, id: &str) -> Result<()> { /* ... */ }
    async fn list(&self) -> Result<Vec<String>> { /* ... */ }
    async fn exists(&self, id: &str) -> Result<bool> { /* ... */ }
}

// Use it
let session = agent.session(".", Some(
    SessionOptions::new()
        .with_session_store(Arc::new(PostgresStore::new(...).await?))
))?;
```

## SessionData Structure

What gets persisted per session:

| Field | Description |
|-------|-------------|
| `id` | Session identifier |
| `messages` | Full conversation history |
| `config.workspace` | Workspace path |
| `config.system_prompt` | System prompt |
| `config.planning_enabled` | Planning flag |
| `tool_names` | Tool names (rebuilt on resume) |

## API Reference

### SessionOptions

| Option | Rust | Python | Node.js | Default |
|--------|------|--------|---------|---------|
| Custom store | `.with_session_store(Arc::new(s))` | _(Rust only)_ | _(Rust only)_ | `FileSessionStore` |

### SessionStore trait (Rust)

| Method | Signature | Description |
|--------|-----------|-------------|
| `save` | `async fn save(&self, data: &SessionData) -> Result<()>` | Persist session data |
| `load` | `async fn load(&self, id: &str) -> Result<Option<SessionData>>` | Load session by ID |
| `delete` | `async fn delete(&self, id: &str) -> Result<()>` | Remove session |
| `list` | `async fn list(&self) -> Result<Vec<String>>` | List all session IDs |

### SessionData fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | `String` | Session identifier |
| `messages` | `Vec<Message>` | Full conversation history |
| `tasks` | `Vec<AgentTask>` | Task list (alias: `todos`) |
| `config.workspace` | `String` | Workspace path |
| `config.system_prompt` | `String` | System prompt |
| `config.planning_enabled` | `bool` | Planning flag |
| `tool_names` | `Vec<String>` | Tool names (rebuilt on resume) |
| `created_at` | `DateTime<Utc>` | Session creation time |
| `updated_at` | `DateTime<Utc>` | Last save time |

### Session management methods

| Method | Rust | Description |
|--------|------|-------------|
| Save session | `session.save().await?` | Persist current state |
| Load session | `agent.resume(id, options?)?` | Resume from stored state |
| List sessions | `agent.list_sessions().await?` | List all saved session IDs |
| Delete session | `agent.delete_session(id).await?` | Remove stored session |
