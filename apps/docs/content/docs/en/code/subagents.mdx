---
title: Subagents
description: Define specialized subagents with isolated permissions, custom prompts, and parallel delegation
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { TypeTable } from 'fumadocs-ui/components/type-table';

# Subagents

Subagents are specialized agents that run in isolated child sessions with their own permissions, system prompts, and tool access. A3S Code ships with 5 built-in subagents and supports user-defined subagents via YAML or Markdown files.

## Built-in Subagents

<TypeTable
  type={
    {`\`explore\``}: {
      description: "Description: Fast codebase exploration (read-only) · Max Steps: 20 · Permissions: read, grep, glob, ls",
    },
    {`\`general\``}: {
      description: "Description: General-purpose multi-step execution · Max Steps: 50 · Permissions: Full tool access",
    },
    {`\`plan\``}: {
      description: "Description: Architecture and planning (read-only) · Max Steps: 30 · Permissions: read, grep, glob",
    },
    {`\`title\``}: {
      description: "Description: Session title generation (hidden) · Max Steps: 1 · Permissions: None",
    },
    {`\`summary\``}: {
      description: "Description: Session summarization (hidden) · Max Steps: 5 · Permissions: read",
    },
  }
/>

## Defining Custom Subagents

### YAML Format

Create a YAML file in your agents directory:

```yaml
# ~/.a3s/agents/security-reviewer.yaml
name: security-reviewer
description: Reviews code for security vulnerabilities and best practices
mode: subagent
hidden: false
max_steps: 25
can_spawn_subagents: false

permissions:
  allow:
    - read
    - grep
    - glob
    - ls
  deny:
    - write
    - edit
    - bash
    - patch

prompt: |
  You are a security code reviewer. Analyze the codebase for:
  - SQL injection, XSS, CSRF vulnerabilities
  - Hardcoded secrets and credentials
  - Insecure cryptographic practices
  - Missing input validation
  - Unsafe deserialization

  Report findings with severity (Critical/High/Medium/Low),
  affected file and line, and recommended fix.
  Never modify any files — report only.
```

### Markdown Format

Or use Markdown with YAML frontmatter (the body becomes the system prompt):

```markdown
# ~/.a3s/agents/db-migration.md
---
name: db-migration
description: Database migration specialist
mode: subagent
max_steps: 40
permissions:
  allow: [read, write, edit, bash, grep, glob]
  deny: [web_fetch, web_search]
---
You are a database migration specialist. You can:
- Generate migration files (SQL or ORM-specific)
- Validate migration safety (no data loss, reversibility)
- Run migrations in development environments
- Generate rollback scripts

Always check for:
1. Backward compatibility with the current schema
2. Data preservation during column renames/type changes
3. Index impact on large tables
4. Foreign key constraint ordering
```

### With Model Override

Use a different model for specific subagents via `provider/model` format:

```yaml
name: quick-search
description: Fast search agent using a smaller model
mode: subagent
max_steps: 10
model: anthropic/claude-haiku-4-20250514
permissions:
  allow: [read, grep, glob, ls]
prompt: |
  You are a fast search agent. Find the requested information
  quickly and return concise results. Do not explain — just find.
```

## Loading Subagents

Configure agent directories in your agent config:

```hcl
agent_dirs = ["~/.a3s/agents", "/shared/team-agents"]
```

All `.yaml` and `.md` files in these directories are automatically loaded into the `AgentRegistry` at startup.

## The `delegate-task` Built-in Skill

A3S Code includes a built-in `delegate-task` skill (Instruction kind) that is automatically injected into the system prompt. It teaches the LLM:

- When to delegate work to sub-agents
- Which built-in agents are available and their capabilities
- How to invoke the `task` and `parallel_task` tools correctly
- Best practices for prompt design and parallelization

This means the LLM can delegate tasks to sub-agents without any additional configuration. See the [Skills System](/docs/code/skills) page for more on built-in skills.

## How Delegation Works

```
Parent Session
  │
  ├─ task("security-reviewer", "Review auth module")
  │    │
  │    ├─ 1. Look up AgentDefinition in AgentRegistry
  │    ├─ 2. Create child session with agent's permissions
  │    ├─ 3. Apply agent's system prompt
  │    ├─ 4. Execute task in isolated agentic loop
  │    ├─ 5. Return result to parent
  │    └─ 6. Child session ID preserved for reference
  │
  └─ Parent continues with subagent's result
```

Key isolation guarantees:
- Child session has its own context window (no parent context leakage)
- Permissions are restricted to the agent definition's policy
- Tool access is filtered per the agent's allow/deny rules
- `max_steps` prevents runaway execution
- `can_spawn_subagents: false` prevents recursive delegation

## AgentDefinition Reference

<TypeTable
  type={{
    name: { type: 'string', required: true, description: 'Unique agent identifier' },
    description: { type: 'string', required: true, description: 'What the agent does (shown to LLM)' },
    mode: { type: '"subagent" | "primary"', default: '"subagent"', description: 'Agent mode' },
    hidden: { type: 'bool', default: 'false', description: 'Hide from listing' },
    max_steps: { type: 'number', description: 'Maximum tool rounds' },
    can_spawn_subagents: { type: 'bool', default: 'false', description: 'Allow recursive delegation' },
    'permissions.allow': { type: 'string[]', description: 'Allowed tool names' },
    'permissions.deny': { type: 'string[]', description: 'Denied tool names' },
    model: { type: 'string', description: 'Model override in `provider/model` format' },
    prompt: { type: 'string', description: 'System prompt for the agent' },
  }}
/>

## Tool Invocation

The LLM delegates to sub-agents via two tools: `task` (single) and `parallel_task` (concurrent). Both are also callable from SDK code via `session.tool()`.

### `task` Parameters

<TypeTable
  type={{
    agent: { type: 'string', required: true, description: 'Agent name (built-in or custom)' },
    description: { type: 'string', required: true, description: 'Short task description' },
    prompt: { type: 'string', required: true, description: 'Detailed prompt for the subagent' },
    background: { type: 'bool', default: 'false', description: 'Run without waiting for result' },
    max_steps: { type: 'int', description: "Override agent's default max steps" },
  }}
/>

### `task` Result

<TypeTable
  type={{
    output: { type: 'string', description: 'Subagent response text' },
    session_id: { type: 'string', description: 'Child session ID' },
    agent: { type: 'string', description: 'Agent name used' },
    success: { type: 'bool', description: 'Whether execution succeeded' },
    task_id: { type: 'string', description: 'Unique task identifier' },
  }}
/>

### Single Delegation

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let result = session.tool("task", serde_json::json!({
    "agent": "explore",
    "description": "Find auth handlers",
    "prompt": "Search for files that handle user authentication and list them with line numbers."
})).await?;

println!("{}", result.output);
```
</Tab>
<Tab value="TypeScript">
```typescript
const result = await session.tool('task', {
  agent: 'explore',
  description: 'Find auth handlers',
  prompt: 'Search for files that handle user authentication and list them with line numbers.',
});

console.log(result.output);
```
</Tab>
<Tab value="Python">
```python
result = session.tool("task", {
    "agent": "explore",
    "description": "Find auth handlers",
    "prompt": "Search for files that handle user authentication and list them with line numbers.",
})

print(result.output)
```
</Tab>
</Tabs>

### Parallel Delegation

`parallel_task` spawns multiple subagents concurrently via `tokio::JoinSet` and waits for all to complete. Results are returned as an array.

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let result = session.tool("parallel_task", serde_json::json!({
    "tasks": [
        {
            "agent": "explore",
            "description": "Find API routes",
            "prompt": "List all API route definitions with their HTTP methods."
        },
        {
            "agent": "explore",
            "description": "Find DB models",
            "prompt": "List all database model definitions with their fields."
        },
        {
            "agent": "security-reviewer",
            "description": "Review auth module",
            "prompt": "Check src/auth/ for security vulnerabilities."
        }
    ]
})).await?;

println!("{}", result.output);
// Each task's result is included with its agent name and success status
```
</Tab>
<Tab value="TypeScript">
```typescript
const result = await session.tool('parallel_task', {
  tasks: [
    {
      agent: 'explore',
      description: 'Find API routes',
      prompt: 'List all API route definitions with their HTTP methods.',
    },
    {
      agent: 'explore',
      description: 'Find DB models',
      prompt: 'List all database model definitions with their fields.',
    },
    {
      agent: 'security-reviewer',
      description: 'Review auth module',
      prompt: 'Check src/auth/ for security vulnerabilities.',
    },
  ],
});

console.log(result.output);
```
</Tab>
<Tab value="Python">
```python
result = session.tool("parallel_task", {
    "tasks": [
        {
            "agent": "explore",
            "description": "Find API routes",
            "prompt": "List all API route definitions with their HTTP methods.",
        },
        {
            "agent": "explore",
            "description": "Find DB models",
            "prompt": "List all database model definitions with their fields.",
        },
        {
            "agent": "security-reviewer",
            "description": "Review auth module",
            "prompt": "Check src/auth/ for security vulnerabilities.",
        },
    ],
})

print(result.output)
```
</Tab>
</Tabs>

### Subagent Events

When streaming, subagent lifecycle events are emitted on the parent session's event channel:

```rust
let (mut rx, _handle) = session.stream("Analyze this codebase thoroughly").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::SubagentStart { task_id, agent, description, .. } => {
            println!("▶ [{agent}] {description} (task: {task_id})");
        }
        AgentEvent::SubagentEnd { agent, success, output, .. } => {
            let status = if success { "✓" } else { "✗" };
            println!("{status} [{agent}] {}", output.chars().take(100).collect::<String>());
        }
        AgentEvent::End { .. } => break,
        _ => {}
    }
}
```

## Multi-Session Parallelism

For workloads that go beyond subagent delegation — e.g., processing multiple repositories or running the same analysis across different workspaces — you can create multiple independent sessions and drive them concurrently using language-native primitives.

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::Agent;
use tokio::task::JoinSet;

let agent = Agent::new("agent.hcl").await?;

let workspaces = vec![
    "/repos/service-auth",
    "/repos/service-billing",
    "/repos/service-gateway",
];

// Spawn one session per workspace, all running concurrently
let mut join_set = JoinSet::new();
for workspace in workspaces {
    let agent = agent.clone();
    join_set.spawn(async move {
        let session = agent.session(workspace, None)?;
        let result = session.send("Find all TODO comments and summarize them").await?;
        Ok::<_, a3s_code_core::CodeError>((workspace.to_string(), result.text))
    });
}

// Collect results as they complete
while let Some(result) = join_set.join_next().await {
    match result? {
        Ok((workspace, text)) => println!("=== {workspace} ===\n{text}\n"),
        Err(e) => eprintln!("Error: {e}"),
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

const agent = await Agent.create('agent.hcl');

const workspaces = [
  '/repos/service-auth',
  '/repos/service-billing',
  '/repos/service-gateway',
];

// Run all sessions concurrently with Promise.all
const results = await Promise.all(
  workspaces.map(async (workspace) => {
    const session = agent.session(workspace);
    const result = await session.send('Find all TODO comments and summarize them');
    return { workspace, text: result.text };
  })
);

for (const { workspace, text } of results) {
  console.log(`=== ${workspace} ===\n${text}\n`);
}
```
</Tab>
<Tab value="Python">
```python
import asyncio
from a3s_code import Agent

agent = Agent.create("agent.hcl")

workspaces = [
    "/repos/service-auth",
    "/repos/service-billing",
    "/repos/service-gateway",
]

async def analyze(workspace: str) -> tuple[str, str]:
    session = agent.session(workspace)
    result = session.send("Find all TODO comments and summarize them")
    return workspace, result.text

# Run all sessions concurrently
results = asyncio.run(asyncio.gather(*[analyze(ws) for ws in workspaces]))

for workspace, text in results:
    print(f"=== {workspace} ===\n{text}\n")
```
</Tab>
</Tabs>

> **Note:** Each session is independent — separate conversation history, tool context, and workspace boundary. There is no shared state between parallel sessions.

### Combining Both Patterns

For fan-out/fan-in workflows, combine multi-session parallelism with subagent delegation:

```rust
use a3s_code_core::Agent;
use tokio::task::JoinSet;

let agent = Agent::new("agent.hcl").await?;

// Phase 1: Parallel exploration across workspaces
let mut join_set = JoinSet::new();
for workspace in &["/repos/frontend", "/repos/backend", "/repos/infra"] {
    let agent = agent.clone();
    let ws = workspace.to_string();
    join_set.spawn(async move {
        let session = agent.session(&ws, None)?;
        // Each session uses parallel_task internally to fan out further
        let result = session.tool("parallel_task", serde_json::json!({
            "tasks": [
                { "agent": "explore", "description": "Find dependencies", "prompt": "List all external dependencies." },
                { "agent": "security-reviewer", "description": "Security scan", "prompt": "Scan for known vulnerability patterns." }
            ]
        })).await?;
        Ok::<_, a3s_code_core::CodeError>((ws, result.output))
    });
}

// Phase 2: Collect and summarize
let mut findings = Vec::new();
while let Some(result) = join_set.join_next().await {
    if let Ok(Ok((ws, output))) = result {
        findings.push(format!("## {ws}\n{output}"));
    }
}

// Phase 3: Feed combined results into a summary session
let summary_session = agent.session("/repos", None)?;
let summary = summary_session.send(&format!(
    "Summarize these findings into a single security report:\n\n{}",
    findings.join("\n\n")
)).await?;

println!("{}", summary.text);
```

Both built-in and custom agents are available by name. Custom agents loaded from `agent_dirs` appear alongside built-in agents automatically.

## API Reference

### AgentDefinition fields

<TypeTable
  type={{
    name: { type: 'string', required: true, description: 'Agent identifier (used in `task` tool)' },
    description: { type: 'string', required: true, description: 'What this agent does' },
    system_prompt: { type: 'string', required: true, description: "Agent's system prompt / instructions" },
    model: { type: 'string', description: 'Model override (`provider/model` format)' },
    allowed_tools: { type: 'string[]', description: 'Tool access restrictions' },
    max_tool_rounds: { type: 'number', description: 'Max tool rounds per invocation' },
  }}
/>

### task tool schema

<TypeTable
  type={{
    agent: { type: 'string', required: true, description: 'Agent name to delegate to' },
    prompt: { type: 'string', required: true, description: 'Task prompt' },
    workspace: { type: 'string', description: 'Workspace override' },
  }}
/>

### Built-in agents

<TypeTable
  type={
    {`\`code-reviewer\``}: {
      description: "Reviews code for style, security, and correctness",
    },
    {`\`test-writer\``}: {
      description: "Generates unit and integration tests",
    },
    {`\`doc-writer\``}: {
      description: "Writes documentation from code",
    },
    {`\`refactorer\``}: {
      description: "Refactors code for clarity and performance",
    },
    {`\`debugger\``}: {
      description: "Diagnoses and fixes bugs",
    },
  }
/>
