---
title: Providers
description: MemoryProvider for development and NatsProvider for production
---

import { TypeTable } from 'fumadocs-ui/components/type-table';

# Providers

A3S Event uses the `EventProvider` trait to abstract the underlying messaging system. Two implementations are included: `MemoryProvider` for development and `NatsProvider` for production.

## EventProvider Trait

```rust
#[async_trait]
pub trait EventProvider: Send + Sync {
    /// Publish an event, returning the provider-assigned sequence number
    async fn publish(&self, event: &Event) -> Result<u64>;

    /// Create a durable subscription (survives reconnects)
    async fn subscribe_durable(
        &self, consumer_name: &str, filter_subject: &str,
    ) -> Result<Box<dyn Subscription>>;

    /// Create an ephemeral subscription
    async fn subscribe(&self, filter_subject: &str) -> Result<Box<dyn Subscription>>;

    /// Fetch historical events
    async fn history(&self, filter_subject: Option<&str>, limit: usize) -> Result<Vec<Event>>;

    /// Delete a durable subscription by consumer name
    async fn unsubscribe(&self, consumer_name: &str) -> Result<()>;

    /// Get provider info (message count, bytes, consumers)
    async fn info(&self) -> Result<ProviderInfo>;

    /// Subject prefix for this provider (e.g., "events")
    fn subject_prefix(&self) -> &str;

    /// Provider name (e.g., "nats", "memory")
    fn name(&self) -> &str;

    // Default implementations (override for provider-specific behavior):
    fn build_subject(&self, category: &str, topic: &str) -> String { ... }
    fn category_subject(&self, category: &str) -> String { ... }
    async fn publish_with_options(&self, event: &Event, opts: &PublishOptions) -> Result<u64> { ... }
    async fn subscribe_durable_with_options(...) -> Result<Box<dyn Subscription>> { ... }
    async fn subscribe_with_options(...) -> Result<Box<dyn Subscription>> { ... }
    async fn health(&self) -> Result<bool> { ... }
}
```

## MemoryProvider

In-process event bus using `tokio::sync::broadcast`. Zero external dependencies.

```rust
use a3s_event::MemoryProvider;

// Default configuration
let provider = MemoryProvider::default();
```

With custom configuration:

```rust
use a3s_event::provider::memory::{MemoryProvider, MemoryConfig};

let provider = MemoryProvider::new(MemoryConfig {
    subject_prefix: "events".to_string(),
    max_events: 100_000,
    channel_capacity: 10_000,
});
```

### MemoryConfig Fields

<TypeTable
  type={{
    subject_prefix: { type: 'String', default: '"events"', description: 'Subject prefix for `build_subject()`' },
    max_events: { type: 'usize', default: '100_000', description: 'Max events in history buffer' },
    channel_capacity: { type: 'usize', default: '10_000', description: 'Broadcast channel capacity' },
  }}
/>

### Characteristics

- Events stored in an in-memory buffer (configurable size)
- Broadcast channel for pub/sub
- Wildcard matching (`>`, `*`) implemented in Rust
- No durable subscriptions (falls back to ephemeral)
- Publish/subscribe options accepted but ignored
- Health check always returns `true`
- Ideal for unit tests and local development

## NatsProvider

Requires the `nats` feature (enabled by default).

Production-grade provider using [NATS JetStream](https://docs.nats.io/nats-concepts/jetstream).

```rust
use a3s_event::{NatsProvider, NatsConfig, StorageType};

let provider = NatsProvider::connect(NatsConfig {
    url: "nats://localhost:4222".to_string(),
    stream_name: "A3S_EVENTS".to_string(),
    subject_prefix: "events".to_string(),
    storage: StorageType::File,
    max_events: 100_000,
    max_age_secs: 604_800,  // 7 days
    ..Default::default()
}).await?;
```

### NatsConfig Fields

<TypeTable
  type={{
    url: { type: 'String', default: '"nats://127.0.0.1:4222"', description: 'NATS server URL' },
    token: { type: 'Option<String>', default: 'None', description: 'Authentication token' },
    credentials_path: { type: 'Option<String>', default: 'None', description: 'NKey/JWT credentials file' },
    stream_name: { type: 'String', default: '"A3S_EVENTS"', description: 'JetStream stream name' },
    subject_prefix: { type: 'String', default: '"events"', description: 'Subject prefix' },
    storage: { type: 'StorageType', default: 'File', description: '`File` or `Memory` storage' },
    max_events: { type: 'i64', default: '100_000', description: 'Max messages in stream' },
    max_age_secs: { type: 'u64', default: '604_800', description: 'Max message age (7 days)' },
    max_bytes: { type: 'i64', default: '0', description: 'Max stream size in bytes (0 = unlimited)' },
    connect_timeout_secs: { type: 'u64', default: '5', description: 'Connection timeout' },
    request_timeout_secs: { type: 'u64', default: '10', description: 'Request timeout' },
  }}
/>

### NATS-Specific Features

**Deduplication:**

```rust
use a3s_event::PublishOptions;

let opts = PublishOptions {
    msg_id: Some("order-001".into()),
    ..Default::default()
};
bus.publish_event_with_options(&event, &opts).await?;
// Duplicate publishes with the same msg_id are ignored within the dedup window
```

**Manual Acknowledgement:**

```rust
let mut subs = bus.create_subscriber("order-processor").await?;
for sub in &mut subs {
    while let Some(pending) = sub.next_manual_ack().await? {
        match process(&pending.received.event).await {
            Ok(()) => pending.ack().await?,
            Err(_) => pending.nak().await?,  // triggers redelivery
        }
    }
}
```

**Delivery Policies:**

```rust
use a3s_event::{SubscribeOptions, DeliverPolicy, SubscriptionFilter};

bus.update_subscription(SubscriptionFilter {
    subscriber_id: "replay".to_string(),
    subjects: vec!["events.orders.>".to_string()],
    durable: true,
    options: Some(SubscribeOptions {
        deliver_policy: DeliverPolicy::ByStartSequence { sequence: 100 },
        ..Default::default()
    }),
}).await?;
```

## Custom Provider

Implement `EventProvider` for any messaging backend:

```rust
use a3s_event::provider::{EventProvider, Subscription, ProviderInfo};
use a3s_event::types::Event;
use a3s_event::Result;
use async_trait::async_trait;

pub struct RedisProvider { /* ... */ }

#[async_trait]
impl EventProvider for RedisProvider {
    async fn publish(&self, event: &Event) -> Result<u64> { todo!() }

    async fn subscribe_durable(
        &self, consumer_name: &str, filter_subject: &str,
    ) -> Result<Box<dyn Subscription>> { todo!() }

    async fn subscribe(&self, filter_subject: &str) -> Result<Box<dyn Subscription>> { todo!() }

    async fn history(
        &self, filter_subject: Option<&str>, limit: usize,
    ) -> Result<Vec<Event>> { todo!() }

    async fn unsubscribe(&self, consumer_name: &str) -> Result<()> { todo!() }
    async fn info(&self) -> Result<ProviderInfo> { todo!() }

    // Only subject_prefix() and name() are required.
    // build_subject() and category_subject() have default implementations.
    fn subject_prefix(&self) -> &str { "events" }
    fn name(&self) -> &str { "redis" }
}
```

Then use it like any other provider:

```rust
let bus = EventBus::new(RedisProvider::new(config));
bus.publish("orders", "created", "New order", "src", payload).await?;
```

## Responsibility Boundaries

These capabilities are delegated to the provider, not the `EventBus`:

<TypeTable
  type={
    "Retry / backoff": {
      description: {`Provider (NATS: \`MaxDeliver\` + \`BackOff\`)`},
    },
    "Backpressure": {
      description: {`Provider (NATS: \`MaxAckPending\`)`},
    },
    "Connection resilience": {
      description: "Provider (NATS: auto-reconnect)",
    },
    "Transport encryption": {
      description: "Provider (TLS config)",
    },
    "Exactly-once delivery": {
      description: "Provider (dedup + double ack)",
    },
    "Stream mirroring": {
      description: "Provider (NATS Mirror/Source config)",
    },
    "Partitioning": {
      description: "Provider (subject routing)",
    },
  }
/>
