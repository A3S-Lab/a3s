---
title: Channels
description: 7 messaging platform adapters with webhook authentication and message normalization
---

import { TypeTable } from 'fumadocs-ui/components/type-table';

# Channels

SafeClaw supports 7 messaging platforms through a unified adapter interface. Each adapter normalizes platform-specific webhook payloads into a common message format and handles authentication.

## Channel Adapter Trait

```rust
pub trait ChannelAdapter: Send + Sync {
    async fn send_message(&self, message: OutboundMessage) -> Result<String>;
    async fn receive_message(&self, payload: &[u8]) -> Result<InboundMessage>;
}
```

## Message Types

```rust
pub struct InboundMessage {
    pub channel: String,
    pub user_id: String,
    pub chat_id: String,
    pub content: String,
    pub attachments: Vec<MessageAttachment>,
    pub timestamp: i64,
}

pub struct OutboundMessage {
    pub channel: String,
    pub chat_id: String,
    pub content: String,
}

pub struct MessageAttachment {
    pub attachment_type: String,
    pub url: String,
    pub size: usize,
}
```

## Supported Platforms

<TypeTable
  type={
    "Telegram": {
      description: "Webhook Format: JSON (Bot API) · Auth Method: Token verification · Features: Text, commands, inline queries",
    },
    "Slack": {
      description: "Webhook Format: JSON (Events API) · Auth Method: HMAC-SHA256 signing · Features: Messages, slash commands, interactions",
    },
    "Discord": {
      description: "Webhook Format: JSON (Interactions) · Auth Method: Ed25519 signature · Features: Messages, slash commands",
    },
    "Feishu": {
      description: "Webhook Format: JSON (Event Subscription) · Auth Method: Token + signature · Features: Messages, card actions",
    },
    "DingTalk": {
      description: "Webhook Format: JSON (Robot) · Auth Method: HMAC-SHA256 · Features: Text, markdown, action cards",
    },
    "WeCom": {
      description: "Webhook Format: XML/JSON (Callback) · Auth Method: Token + signature · Features: Text, events",
    },
    "WebChat": {
      description: "Webhook Format: JSON (custom) · Auth Method: API key · Features: Generic web chat interface",
    },
  }
/>

## Webhook Authentication

```rust
pub trait ChannelAuth: Send + Sync {
    fn verify_signature(&self, payload: &[u8], signature: &str) -> Result<bool>;
}
```

Each platform has its own authentication implementation:

<TypeTable
  type={
    "Telegram": {
      description: {`\`TelegramAuth\` — Bot token verification`},
    },
    "Slack": {
      description: {`\`SlackAuth\` — HMAC-SHA256 with signing secret`},
    },
    "Discord": {
      description: {`\`DiscordAuth\` — Ed25519 public key signature`},
    },
    "Feishu": {
      description: {`\`FeishuAuth\` — Token + event signature`},
    },
    "DingTalk": {
      description: {`\`DingTalkAuth\` — HMAC-SHA256 with app secret`},
    },
    "WeCom": {
      description: {`\`WeComAuth\` — Token + message signature`},
    },
  }
/>

Failed authentication generates a `Critical` severity audit event with `LeakageVector::AuthFailure`.

## Configuration

```toml
[channels.telegram]
bot_token = "${TELEGRAM_BOT_TOKEN}"

[channels.slack]
bot_token = "${SLACK_BOT_TOKEN}"
signing_secret = "${SLACK_SIGNING_SECRET}"

[channels.discord]
bot_token = "${DISCORD_BOT_TOKEN}"
public_key = "${DISCORD_PUBLIC_KEY}"

[channels.feishu]
app_id = "${FEISHU_APP_ID}"
app_secret = "${FEISHU_APP_SECRET}"
verification_token = "${FEISHU_VERIFICATION_TOKEN}"

[channels.dingtalk]
app_key = "${DINGTALK_APP_KEY}"
app_secret = "${DINGTALK_APP_SECRET}"

[channels.wecom]
corp_id = "${WECOM_CORP_ID}"
agent_id = "${WECOM_AGENT_ID}"
secret = "${WECOM_SECRET}"
token = "${WECOM_TOKEN}"
encoding_aes_key = "${WECOM_ENCODING_AES_KEY}"

[channels.webchat]
api_key = "${WEBCHAT_API_KEY}"
```

## Webhook Endpoint

All webhooks are received at:

```
POST /api/v1/gateway/webhook/:channel
```

For example:
- `POST /api/v1/gateway/webhook/telegram`
- `POST /api/v1/gateway/webhook/slack`
- `POST /api/v1/gateway/webhook/discord`

## Message Flow

```
Platform Webhook
    ↓
Webhook Endpoint (/api/v1/gateway/webhook/:channel)
    ↓
Channel Auth (verify signature)
    ↓
Channel Adapter (parse → InboundMessage)
    ↓
Privacy Classifier (detect PII)
    ↓
Session Manager (route to local or TEE)
    ↓
AI Agent (process)
    ↓
Output Sanitizer (redact tainted data)
    ↓
Channel Adapter (OutboundMessage → platform format)
    ↓
Platform API (send response)
```

## A3S Gateway Integration

When running behind A3S Gateway, SafeClaw registers its routes automatically:

```toml
[a3s_gateway]
enabled = true
service_name = "safeclaw"
api_rule = "PathPrefix(`/safeclaw/api`)"
ws_rule = "Path(`/safeclaw/ws`)"
webhook_rule = "PathPrefix(`/safeclaw/webhook`)"
middlewares = ["auth-jwt", "rate-limit"]
entrypoints = ["websecure"]
conversation_affinity = true
affinity_cookie = "safeclaw_session"
token_metering = true
max_tokens_per_minute = 10000
```
