---
title: Dead Letter Queue
description: Capture permanently failed events for inspection and debugging
---

# Dead Letter Queue

Events that exceed the maximum delivery count are moved to a dead letter queue (DLQ) for inspection and debugging.

## Enable DLQ

```rust
use a3s_event::{EventBus, MemoryDlqHandler};
use a3s_event::provider::memory::MemoryProvider;
use std::sync::Arc;

let mut bus = EventBus::new(MemoryProvider::default());

let dlq = MemoryDlqHandler::new(100); // Max 100 dead letters
bus.set_dlq_handler(Arc::new(dlq));
```

## How It Works

When a message has been delivered `max_deliver` times without a successful ack, `should_dead_letter()` returns `true` and the event is routed to the DLQ handler:

```
Event delivered → processing fails → redelivered → fails again
    → max_deliver reached → DLQ handler receives the event
```

The `max_deliver` threshold is configured via `SubscribeOptions`:

```rust
use a3s_event::SubscribeOptions;

let options = SubscribeOptions {
    max_deliver: Some(3),  // After 3 failed deliveries, send to DLQ
    ..Default::default()
};
```

## DeadLetterEvent

```rust
pub struct DeadLetterEvent {
    pub event: Event,          // The original event
    pub reason: String,        // Why it was dead-lettered
    pub timestamp: u64,        // Unix milliseconds when dead-lettered
    // Optional fields (for SinkDlqHandler, requires `routing` feature):
    pub original_subject: Option<String>,
    pub delivery_attempts: Option<u32>,
    pub first_failure_at: Option<u64>,
}
```

## Inspecting Dead Letters

```rust
let dlq = bus.dlq_handler().unwrap();

// Count dead letters
let count = dlq.count().await;

// List recent dead letters
let letters = dlq.list(50).await;
for letter in &letters {
    println!("[{}] {}: {}",
        letter.timestamp,
        letter.event.subject,
        letter.reason);
}
```

## DlqHandler Trait

Implement custom DLQ backends (e.g., persist to database, forward to alerting):

```rust
use a3s_event::{DlqHandler, DeadLetterEvent};
use async_trait::async_trait;

#[async_trait]
pub trait DlqHandler: Send + Sync {
    async fn handle(&self, dead_letter: DeadLetterEvent) -> Result<()>;
    async fn list(&self, limit: usize) -> Vec<DeadLetterEvent>;
    async fn count(&self) -> usize;
}
```

### Custom Example: Forward to Slack

```rust
struct SlackDlqHandler {
    webhook_url: String,
    memory: MemoryDlqHandler,
}

#[async_trait]
impl DlqHandler for SlackDlqHandler {
    async fn handle(&self, dead_letter: DeadLetterEvent) -> Result<()> {
        self.memory.handle(dead_letter.clone()).await?;

        reqwest::Client::new()
            .post(&self.webhook_url)
            .json(&serde_json::json!({
                "text": format!("DLQ: {} — {}",
                    dead_letter.event.subject,
                    dead_letter.reason)
            }))
            .send()
            .await?;

        Ok(())
    }

    async fn list(&self, limit: usize) -> Vec<DeadLetterEvent> {
        self.memory.list(limit).await
    }

    async fn count(&self) -> usize {
        self.memory.count().await
    }
}
```

## MemoryDlqHandler

The built-in in-memory implementation with capacity management:

```rust
let dlq = MemoryDlqHandler::new(100);
// When capacity is reached, oldest dead letters are evicted
```

## Helper Function

```rust
use a3s_event::should_dead_letter;

// Check if an event should be dead-lettered
if should_dead_letter(delivery_count, max_deliver) {
    dlq.handle(dead_letter_event).await?;
}
```
