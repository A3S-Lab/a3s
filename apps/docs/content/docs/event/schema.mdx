---
title: Schema Validation
description: Event schemas with required fields validation and version compatibility checking
---

# Schema Validation

A3S Event supports optional schema validation on publish. Register event schemas with required fields, and the `EventBus` validates payloads before they reach the provider.

## Enable Schema Validation

```rust
use a3s_event::{EventBus, MemorySchemaRegistry, EventSchema, Compatibility};
use a3s_event::provider::memory::MemoryProvider;
use std::sync::Arc;

let mut bus = EventBus::new(MemoryProvider::default());

let mut registry = MemorySchemaRegistry::new();

registry.register(EventSchema {
    event_type: "order.created".into(),
    version: 1,
    required_fields: vec!["order_id".into(), "total".into()],
    compatibility: Compatibility::Backward,
});

registry.register(EventSchema {
    event_type: "order.shipped".into(),
    version: 1,
    required_fields: vec!["order_id".into(), "tracking_number".into()],
    compatibility: Compatibility::Backward,
});

bus.set_schema_registry(Arc::new(registry));
```

## Validation on Publish

When a schema registry is set, typed events are validated against the registered schema:

```rust
use a3s_event::Event;

// Passes validation (has order_id and total)
let event = Event::typed(
    "events.orders.created", "orders",
    "order.created", 1,
    "New order", "order-service",
    serde_json::json!({"order_id": "ORD-001", "total": 99.99}),
);
bus.publish_event(&event).await?;

// Fails validation (missing "total" field)
let bad_event = Event::typed(
    "events.orders.created", "orders",
    "order.created", 1,
    "New order", "order-service",
    serde_json::json!({"order_id": "ORD-001"}),
);
let result = bus.publish_event(&bad_event).await;
assert!(result.is_err());
```

Events without an `event_type` (created via `Event::new()`) skip schema validation.

## Schema Evolution

Register multiple versions of the same event type:

```rust
// Version 1: original schema
registry.register(EventSchema {
    event_type: "order.created".into(),
    version: 1,
    required_fields: vec!["order_id".into(), "total".into()],
    compatibility: Compatibility::Backward,
});

// Version 2: added "currency" field
registry.register(EventSchema {
    event_type: "order.created".into(),
    version: 2,
    required_fields: vec!["order_id".into(), "total".into(), "currency".into()],
    compatibility: Compatibility::Backward,
});
```

## Compatibility Checking

Check whether a new schema version is compatible with an existing one:

```rust
let compat = registry.check_compatibility("order.created", 1, 2);

match compat {
    Compatibility::Backward => println!("New version can read old data"),
    Compatibility::Forward => println!("Old version can read new data"),
    Compatibility::Full => println!("Fully compatible in both directions"),
    Compatibility::None => println!("Breaking change"),
}
```

### Compatibility Rules

| Type | Meaning | Example |
|------|---------|---------|
| `Backward` | New schema can read old data | Added optional field |
| `Forward` | Old schema can read new data | Removed optional field |
| `Full` | Compatible both ways | No field changes |
| `None` | Breaking change | Added required field |

## SchemaRegistry Trait

Implement custom registries (e.g., backed by a database):

```rust
use a3s_event::{SchemaRegistry, EventSchema, Compatibility};

pub trait SchemaRegistry: Send + Sync {
    fn register(&mut self, schema: EventSchema);
    fn validate(&self, event_type: &str, version: u32, payload: &serde_json::Value) -> Result<()>;
    fn get(&self, event_type: &str, version: u32) -> Option<&EventSchema>;
    fn check_compatibility(&self, event_type: &str, old_version: u32, new_version: u32) -> Compatibility;
    fn all_schemas(&self) -> Vec<&EventSchema>;
}
```

## EventSchema Fields

| Field | Type | Description |
|-------|------|-------------|
| `event_type` | `String` | Event type identifier (e.g., `order.created`) |
| `version` | `u32` | Schema version number |
| `required_fields` | `Vec<String>` | Fields that must be present in the payload |
| `compatibility` | `Compatibility` | Compatibility mode for this schema |

## Validation Order

When both schema validation and encryption are enabled:

1. Schema validation (on plaintext payload)
2. Encryption (payload becomes ciphertext)
3. Publish to provider

This ensures schemas always validate the actual data, not encrypted blobs.
