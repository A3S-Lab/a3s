---
title: EventBus
description: High-level API for publishing, subscribing, and managing events
---

# EventBus

`EventBus` is the primary API for working with events. It wraps an `EventProvider` and adds schema validation, encryption, DLQ handling, state persistence, and metrics.

## Creating an EventBus

```rust
use a3s_event::{EventBus, MemoryProvider};

let provider = MemoryProvider::new();
let bus = EventBus::new(provider);
```

## Publishing

### Simple Publish

```rust
bus.publish(
    "orders.created",
    serde_json::json!({ "order_id": "ORD-001", "total": 99.99 }),
).await?;
```

### Typed / Versioned Publish

Attach an `event_type` and `version` for schema validation:

```rust
bus.publish_typed(
    "orders.created",       // subject
    "order.created",        // event_type
    1,                      // version
    serde_json::json!({ "order_id": "ORD-001", "total": 99.99 }),
).await?;
```

### Publish with Options

```rust
use a3s_event::PublishOptions;
use std::time::Duration;

let options = PublishOptions {
    msg_id: Some("dedup-123".into()),        // Deduplication ID
    expected_sequence: Some(42),              // Optimistic concurrency
    timeout: Some(Duration::from_secs(5)),   // Publish timeout
};

bus.publish_with_options(
    "orders.created",
    serde_json::json!({ "order_id": "ORD-001" }),
    options,
).await?;
```

### PublishOptions Fields

| Field | Type | Description |
|-------|------|-------------|
| `msg_id` | `Option<String>` | Deduplication ID (NATS dedup window) |
| `expected_sequence` | `Option<u64>` | Expected stream sequence for optimistic concurrency |
| `timeout` | `Option<Duration>` | Publish timeout |

## Subscribing

### Ephemeral Subscription

Cleaned up when the subscriber disconnects:

```rust
let mut rx = bus.subscribe("orders.>").await?;

while let Some(event) = rx.recv().await {
    println!("{}: {}", event.subject, event.payload);
}
```

### Durable Subscription

Survives process restarts (NATS JetStream only):

```rust
let mut rx = bus.subscribe_durable("orders.>", "order-processor").await?;

while let Some(event) = rx.recv().await {
    println!("{}: {}", event.subject, event.payload);
    event.ack().await?;  // Manual acknowledgement
}
```

### Subscribe with Options

```rust
use a3s_event::{SubscribeOptions, DeliverPolicy};
use std::time::Duration;

let options = SubscribeOptions {
    deliver_policy: Some(DeliverPolicy::New),
    max_deliver: Some(3),
    ack_wait: Some(Duration::from_secs(30)),
    max_ack_pending: Some(100),
    backoff: Some(vec![
        Duration::from_secs(1),
        Duration::from_secs(5),
        Duration::from_secs(30),
    ]),
};

let mut rx = bus.subscribe_with_options("orders.>", options).await?;
```

### SubscribeOptions Fields

| Field | Type | Description |
|-------|------|-------------|
| `deliver_policy` | `Option<DeliverPolicy>` | Where to start consuming |
| `max_deliver` | `Option<i64>` | Max redelivery attempts before DLQ |
| `ack_wait` | `Option<Duration>` | Time to wait for ack before redelivery |
| `max_ack_pending` | `Option<i64>` | Backpressure: max unacked messages |
| `backoff` | `Option<Vec<Duration>>` | Redelivery backoff schedule |

### Delivery Policies

```rust
pub enum DeliverPolicy {
    All,                         // All messages from the beginning
    Last,                        // Last message only
    New,                         // Only new messages after subscribe
    ByStartSequence(u64),        // From a specific stream sequence
    ByStartTime(DateTime<Utc>),  // From a specific timestamp
    LastPerSubject,              // Last message per subject
}
```

## Wildcards

Both providers support NATS-style wildcards:

| Pattern | Matches | Example |
|---------|---------|---------|
| `orders.>` | All subjects under `orders.` | `orders.created`, `orders.us.shipped` |
| `orders.*` | One level under `orders.` | `orders.created` but not `orders.us.shipped` |

## History & Querying

```rust
// Get recent events for a subject
let events = bus.history("orders.created", 100).await?;
for event in &events {
    println!("[{}] {}", event.timestamp, event.payload);
}

// Count events by category
let counts = bus.count("orders").await?;
println!("Order events: {}", counts.total);
```

## Subscription Management

```rust
// List active subscriptions
let filters = bus.subscriptions();

// Update a subscription filter
bus.update_subscription("orders.>", new_filter).await?;

// Remove a subscription
bus.remove_subscription("orders.>").await?;
```

## Health Check

```rust
let is_healthy = bus.health().await?;
```

Returns `true` if the underlying provider is connected and operational. MemoryProvider always returns `true`. NatsProvider checks the NATS connection.
