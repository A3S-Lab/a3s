---
title: Architecture
description: System architecture, data flow, and design decisions
---

# Architecture

## Library-First Design

A3S Code is a library-first framework. The core (`a3s-code-core`) embeds directly in your application via native bindings — no server, no IPC overhead.

```
Your Application (Rust / TypeScript / Python)
    │
    ▼ Agent::new("agent.hcl") / Agent.create("agent.hcl")
┌──────────────────────────────────────────────────────┐
│  Agent (config-driven, workspace-independent)         │
│  ┌────────────┬──────────────┬─────────────────────┐ │
│  │ LlmClient  │  CodeConfig  │   SessionManager    │ │
│  └────────────┴──────────────┴─────────────────────┘ │
│                       │                               │
│        agent.session("/workspace", options?)           │
│                       ▼                               │
│  ┌──────────────────────────────────────────────┐    │
│  │  AgentSession (workspace-bound)               │    │
│  │  ┌─────────┬──────────┬──────────┬─────────┐ │    │
│  │  │ Agent   │ Tool     │Permission│  LLM    │ │    │
│  │  │ Loop    │ Executor │ System   │ Provider│ │    │
│  │  │         │ (10)     │          │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ HITL    │ Subagent │  Hook    │  MCP    │ │    │
│  │  │         │          │  Engine  │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Llm     │ Security │ Memory   │ File    │ │    │
│  │  │ Planner │ Provider │          │ History │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Wave    │ Context  │ Cost     │Telemetry│ │    │
│  │  │Scheduler│Compactor │ Tracking │         │ │    │
│  │  └─────────┴──────────┴──────────┴─────────┘ │    │
│  └──────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

Native bindings:

| Language | Package | Binding |
|----------|---------|---------|
| Rust | `a3s-code-core` | Native |
| Python | `a3s-code` | PyO3 |
| Node.js | `@a3s-lab/code` | napi-rs |

## Core Concepts

| Concept | Description |
|---------|-------------|
| **Agent** | Config-driven top-level object. Holds LLM client and config. Workspace-independent. |
| **AgentSession** | Bound to a specific workspace. All LLM interaction and tool execution happens here. |
| **SessionOptions** | Optional per-session override: model (`provider/model` format), planning, HITL, etc. |
| **AgentLoop** | Core execution engine driving the LLM ↔ tool multi-turn loop. |
| **ToolExecutor** | Tool registry and execution. Manages 11 built-in tools. |
| **LlmPlanner** | JSON-structured planning — decomposes complex tasks into execution plans with dependency graphs. |
| **WaveScheduler** | Groups independent plan steps into waves and executes them in parallel via `JoinSet`. |
| **AgentEvent** | `#[non_exhaustive]` event enum emitted during streaming — safe for SDK evolution. |

## Agent Loop

The core execution cycle. Each round:

1. **GenerateStart hook** fires (optional)
2. **LLM call** — streaming to Anthropic or OpenAI-compatible API
3. **GenerateEnd hook** fires (optional)
4. If LLM returns `tool_use`:
   - **PreToolUse hook** fires (optional)
   - **Permission check** — Deny → Allow → Ask → Default evaluation
   - **HITL confirmation** — if required, wait for user approval (with timeout)
   - **SecurityProvider check** — pluggable security logic via trait
   - **Tool execution** — run the tool, capture output
   - **PostToolUse hook** fires (optional)
5. Feed tool result back to LLM, go to step 1
6. If LLM returns text-only → done

Maximum rounds per generation configurable via `max_tool_rounds` (default: 50).

## Security Layers

Two built-in layers, plus extensibility via traits:

| Layer | Component | What it does |
|-------|-----------|-------------|
| 1 | Permission Policy | Deny → Allow → Ask → Default rule evaluation with glob patterns |
| 2 | HITL Confirmation | Independent of permissions — even `Allow` goes through HITL check |
| 3 | SecurityProvider | Pluggable trait for taint tracking, output sanitization, injection detection |
| 4 | Workspace Boundary | All file operations restricted to session workspace |
| 5 | HookEngine | Custom security logic via lifecycle hooks |

See [Security](/docs/code/security) for details.

## Context Management

When context usage exceeds the threshold (default 80% of model's context window):

1. Keep first 2 messages (system context)
2. Keep last 20 messages (recent context)
3. Summarize middle messages via LLM call
4. Insert summary as a synthetic message

This keeps the session within context limits while preserving important context.

## Planning & Parallel Execution

When planning is enabled:

1. **LlmPlanner** decomposes the task into steps with dependencies
2. **WaveScheduler** groups independent steps into waves
3. Each wave executes in parallel via `tokio::JoinSet`
4. Dependent steps wait for their dependencies to complete

```
Wave 1: [Analyze auth] + [Analyze DB schema]  ← parallel
Wave 2: [Implement JWT integration]           ← waits for wave 1
Wave 3: [Write tests]                         ← waits for wave 2
```

See [Tasks](/docs/code/tasks) for details.

## Lane Queue System

The lane queue routes tool calls to different execution strategies:

| Lane | Purpose | Default Mode |
|------|---------|--------------|
| Query | Read-only operations (read, grep, glob, ls) | Internal (parallel) |
| Execute | Write operations (write, edit, patch, bash) | Internal (sequential) |
| Generate | LLM calls | Internal |

Each lane can be switched to **External** mode to offload execution to remote workers. See [Lane Queue](/docs/code/lane-queue) for details.

## Memory System

Four memory types:

| Type | Purpose | Storage |
|------|---------|---------|
| Episodic | Session events and interactions | In-memory |
| Semantic | Facts and knowledge | In-memory |
| Procedural | Successful patterns and workflows | In-memory |
| Working | Current task context | In-memory |

See [Memory](/docs/code/memory) for details.

## Extensibility

A3S Code is designed for extensibility:

- **MCP Integration** — Connect external tool servers via Model Context Protocol
- **Custom Tools** — Implement the `Tool` trait and register with `ToolRegistry`
- **SecurityProvider** — Implement custom security logic via trait
- **HookEngine** — Register custom logic at 8 lifecycle events
- **Subagents** — Delegate specialized tasks to focused child agents
- **PermissionChecker** — Implement custom permission logic via trait
- **ConfirmationProvider** — Implement custom HITL logic via trait
- **Planner** — Implement custom planning logic via trait

All core systems use trait-based interfaces for maximum flexibility.
