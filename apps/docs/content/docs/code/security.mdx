---
title: Security
description: Permissions, HITL confirmation, injection defense, workspace boundaries, and secret management
---

# Security

A3S Code includes multiple layers of security hardening to protect against prompt injection, tool misuse, and data leakage. The `SecurityGuard` orchestrates all security checks per-session.

## Security Architecture

When the agent wants to execute a tool, the following checks happen in order. Any layer can block the call — all layers must pass for execution to proceed.

```
User Prompt → SecurityGuard
                ├── InjectionDetector (pre-LLM)
                ├── PermissionPolicy (pre-tool)       ← Deny → Allow → Ask → Default
                ├── HITL Confirmation (pre-tool)       ← independent of permissions
                ├── ToolInterceptor (pre-tool)         ← hard-block dangerous patterns
                ├── WorkspaceBoundary (pre-tool)
                ├── OutputSanitizer (post-LLM)
                ├── TaintTracker (runtime)
                └── AuditLog (all events)
```

## Permission Policy

The permission system controls which tools the agent can use. Rules are evaluated in order: **Deny → Allow → Ask → Default**.

### Rule Types

| Action | Behavior |
|--------|----------|
| `deny` | Block the tool call immediately |
| `allow` | Permit the tool call |
| `ask` | Prompt the user for confirmation (via HITL) |

### Pattern Matching

Rules use glob-style pattern matching on tool names and arguments:

```
Tool(pattern)
```

| Pattern | Matches |
|---------|---------|
| `Bash(rm -rf:*)` | Any bash command starting with `rm -rf` |
| `Read(src/**)` | Read operations on any file under `src/` |
| `Write(*)` | All write operations |
| `mcp__pencil` | All `mcp__pencil__*` tools (prefix matching) |

Wildcards: `*` matches any character except `/`, `**` matches including `/`, `:*` matches any suffix.

### Preset Policies

| Preset | Behavior |
|--------|----------|
| `PermissionPolicy::permissive()` | Allow all tools by default |
| `PermissionPolicy::strict()` | Deny all tools by default |

### Building a Custom Policy

```rust
use a3s_code_core::permissions::{PermissionPolicy, PermissionRule};

let policy = PermissionPolicy::new()
    .deny(PermissionRule::new("Bash(rm -rf:*)"))
    .deny(PermissionRule::new("Bash(curl:*|sh)"))
    .allow(PermissionRule::new("Read(src/**)"))
    .allow(PermissionRule::new("Glob(*)"))
    .ask(PermissionRule::new("Write(*)"))
    .ask(PermissionRule::new("Bash(*)"));
```

Tool-specific argument extraction: `Bash` matches on command, `Read`/`Write`/`Edit` match on file_path, `Glob` matches on pattern, `Grep` matches on pattern and path.

## Human-in-the-Loop (HITL)

HITL is **independent** of the permission system. Even if a tool is `allow`-ed by permissions, it still goes through the HITL check when `ConfirmationPolicy` is enabled. This provides defense-in-depth.

### ConfirmationPolicy

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `enabled` | bool | `false` | Whether HITL is active |
| `default_timeout_ms` | u64 | `30000` | Timeout for user response (30s) |
| `timeout_action` | TimeoutAction | `Reject` | What to do on timeout |
| `yolo_lanes` | HashSet&lt;SessionLane&gt; | `{}` | Lanes that skip confirmation |

### Timeout Actions

| Action | Behavior |
|--------|----------|
| `Reject` | Reject the tool call on timeout (default, recommended) |
| `AutoApprove` | Auto-approve on timeout (use with caution) |

### Confirmation Flow

When a tool requires confirmation, the agent:

1. Emits `ConfirmationRequired` event with tool name, args, and timeout
2. Waits for user response or timeout
3. Emits `ConfirmationReceived` (approved/denied with reason) or `ConfirmationTimeout` (with action taken)

```rust
use a3s_code_core::hitl::{ConfirmationPolicy, TimeoutAction};

let hitl = ConfirmationPolicy {
    enabled: true,
    default_timeout_ms: 30_000,
    timeout_action: TimeoutAction::Reject,
    yolo_lanes: HashSet::new(),
};
```

### YOLO Mode

Tools executed in YOLO lanes skip HITL confirmation even when the permission policy returns `Ask`. This is useful for lane-based automation where human oversight isn't practical.

```rust
use a3s_code_core::queue::SessionLane;

let hitl = ConfirmationPolicy {
    enabled: true,
    yolo_lanes: HashSet::from([SessionLane::Execute, SessionLane::Query]),
    ..Default::default()
};
// Tools in Execute and Query lanes auto-approve without confirmation
```

Available lanes: `Control`, `Query`, `Execute`, `Generate`.

## Indirect Prompt Injection Defense

A3S Code scans tool outputs for injection attempts using a `PostToolUse` hook. When a tool returns content that contains suspicious patterns (e.g., instructions to the LLM embedded in file contents), the scanner flags it before the content reaches the LLM.

```
Tool Output → PostToolUse Hook → Injection Scanner
                                    ├── Clean → pass to LLM
                                    └── Suspicious → flag + warn
```

This protects against attacks where malicious content in files, web pages, or API responses tries to hijack the agent's behavior.

## Builtin Tool Shadowing Prevention

Custom tools and MCP tools cannot shadow built-in tool names. If a skill or MCP server registers a tool with the same name as a built-in (e.g., `Bash`, `Read`, `Write`), the registration is rejected. This prevents malicious tools from intercepting sensitive operations.

## Workspace Boundary Enforcement

All file operations are restricted to the session's workspace directory. The boundary check resolves symlinks to prevent escape via symbolic links:

```
Read("/project/src/main.rs")     → ✅ within workspace
Read("/project/link-to-etc")     → resolves symlink → /etc/passwd → ❌ blocked
Read("../../etc/passwd")         → resolves to /etc/passwd → ❌ blocked
```

Path traversal patterns (`../`) are also validated with `validate_path_safe_id()` to prevent directory escape in identifiers.

## SecretString

API keys and sensitive credentials are wrapped in `SecretString`, which redacts the value in `Debug` and `Display` output:

```rust
let key = SecretString::new("sk-ant-api03-...");
println!("{:?}", key);  // [REDACTED]
println!("{}", key);    // [REDACTED]
key.expose()            // "sk-ant-api03-..." (explicit access only)
```

This prevents accidental leakage of API keys in logs, error messages, and debug output.

## Output Sanitizer

The output sanitizer scans LLM responses for PII (personally identifiable information) and redacts it before returning to the user. Integrated with `a3s-common` for classification.

## Taint Tracking

The taint tracker monitors sensitive values as they flow through the system. When a secret value is used in a tool argument, the tracker ensures it doesn't leak into logs or responses.

## Tool Interceptor

The tool interceptor blocks dangerous tool invocations based on configurable rules. It runs before the permission system and provides a hard block on known-dangerous patterns:

| Pattern | Blocked |
|---------|---------|
| `rm -rf /` | Destructive filesystem operations |
| `curl \| sh` | Remote code execution |
| `chmod 777` | Overly permissive file permissions |

## MCP Tool Timeout

MCP tool executions have a configurable timeout (default: 60 seconds). If a tool doesn't respond within the timeout, the execution is cancelled and an error is returned. This prevents hanging MCP servers from blocking the agent.

## Audit Log

All security-relevant events are recorded in an in-memory audit log (10,000 entry ring buffer):

- Permission checks (allow/deny/ask)
- Tool executions and results
- Injection detection alerts
- Workspace boundary violations
- HITL confirmations and timeouts

Access via the `SecurityGuard` API or through agent events.
