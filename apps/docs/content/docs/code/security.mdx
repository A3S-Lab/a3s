---
title: Security
description: Permission system, HITL confirmation, and extensible security traits
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Security

A3S Code provides two built-in security layers: **Permission Policy** and **Human-in-the-Loop (HITL) Confirmation**. Additional security logic can be implemented via the `SecurityProvider` trait and `HookEngine`.

## Security Architecture

```
User Prompt ‚Üí Agent Loop
  ‚îú‚îÄ Permission Policy    ‚Üê Deny ‚Üí Allow ‚Üí Ask ‚Üí Default
  ‚îú‚îÄ HITL Confirmation    ‚Üê Independent of permissions
  ‚îú‚îÄ Tool Execution
  ‚îî‚îÄ SecurityProvider     ‚Üê Pluggable via trait (taint tracking, sanitization, etc.)
```

## Permission Policy

The permission system controls which tools the agent can use. Rules are evaluated in order: **Deny ‚Üí Allow ‚Üí Ask ‚Üí Default**.

### Rule Types

| Action | Behavior |
|--------|----------|
| `deny` | Block the tool call immediately |
| `allow` | Permit the tool call |
| `ask` | Prompt the user for confirmation (via HITL) |

### Pattern Matching

Rules use glob-style pattern matching on tool names and arguments:

```
Tool(pattern)
```

| Pattern | Matches |
|---------|---------|
| `bash(rm -rf:*)` | Any bash command starting with `rm -rf` |
| `read(src/**)` | Read operations on any file under `src/` |
| `write(*)` | All write operations |
| `mcp__pencil` | All `mcp__pencil__*` tools (prefix matching) |

Wildcards: `*` matches any character except `/`, `**` matches including `/`, `:*` matches any suffix.

### Preset Policies

| Preset | Behavior |
|--------|----------|
| `PermissionPolicy::permissive()` | Allow all tools by default (default) |
| `PermissionPolicy::strict()` | Deny all tools by default |

### Building a Custom Policy

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::permissions::PermissionPolicy;

let policy = PermissionPolicy::new()
    .deny("bash(rm -rf:*)")
    .deny("bash(curl:*|sh)")
    .allow("read(*)")
    .allow("glob(*)")
    .allow("grep(*)")
    .ask("write(*)")
    .ask("bash(*)");

// Apply to session
session.set_permission_policy(policy).await;
```
</Tab>
<Tab value="TypeScript">
```typescript
const { PermissionPolicy } = require('@a3s-lab/code');

const policy = new PermissionPolicy()
  .deny('bash(rm -rf:*)')
  .deny('bash(curl:*|sh)')
  .allow('read(*)')
  .allow('glob(*)')
  .allow('grep(*)')
  .ask('write(*)')
  .ask('bash(*)');

await session.setPermissionPolicy(policy);
```
</Tab>
<Tab value="Python">
```python
from a3s_code import PermissionPolicy

policy = PermissionPolicy()
policy.deny("bash(rm -rf:*)")
policy.deny("bash(curl:*|sh)")
policy.allow("read(*)")
policy.allow("glob(*)")
policy.allow("grep(*)")
policy.ask("write(*)")
policy.ask("bash(*)")

session.set_permission_policy(policy)
```
</Tab>
</Tabs>

### Evaluation Order

Rules are evaluated in this order:

1. **Deny rules** ‚Äî If any deny rule matches, block immediately
2. **Allow rules** ‚Äî If any allow rule matches, permit
3. **Ask rules** ‚Äî If any ask rule matches, trigger HITL confirmation
4. **Default policy** ‚Äî If no rules match, use the default (permissive or strict)

Example:

```rust
let policy = PermissionPolicy::new()
    .deny("bash(rm -rf:*)")      // Block destructive commands
    .allow("bash(git *)")         // Allow git commands
    .ask("bash(*)")               // Ask for all other bash commands
    .allow("read(*)")             // Allow all reads
    .ask("write(*)");             // Ask for all writes
```

## Human-in-the-Loop (HITL)

HITL confirmation is **independent** of the permission system. Even if a tool is `allow`ed by permissions, HITL can still require user confirmation.

### Configuration

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::hitl::{ConfirmationPolicy, TimeoutAction};

let hitl = ConfirmationPolicy {
    enabled: true,
    default_timeout_ms: 30_000,
    timeout_action: TimeoutAction::Reject,
    ..Default::default()
};

let session = agent.session("/project", Some(
    SessionOptions::new().with_confirmation_policy(hitl)
))?;
```
</Tab>
<Tab value="TypeScript">
```typescript
const session = agent.session('/project', {
  confirmationPolicy: {
    enabled: true,
    timeoutMs: 30000,
    timeoutAction: 'reject',
  },
});
```
</Tab>
<Tab value="Python">
```python
from a3s_code import ConfirmationPolicy

session = agent.session("/project",
    confirmation_policy=ConfirmationPolicy(
        enabled=True,
        timeout_ms=30000,
        timeout_action="reject",
    ))
```
</Tab>
</Tabs>

### Handling Confirmation Events

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let (mut rx, _handle) = session.stream("Clean up old logs").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::ConfirmationRequired { tool_id, tool_name, args, .. } => {
            println!("üîí Approve '{tool_name}'? {args:?}");
            // Approve or reject
            session.respond_confirmation(&tool_id, true, None).await;
        }
        AgentEvent::PermissionDenied { tool_name, reason, .. } => {
            println!("üö´ {tool_name} blocked: {reason}");
        }
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::End { .. } => break,
        _ => {}
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
for await (const event of session.stream('Clean up old logs')) {
  if (event.type === 'confirmation_required') {
    console.log(`üîí Approve '${event.toolName}'?`, event.toolArgs);
    await session.respondConfirmation(event.toolId, { approved: true });
  } else if (event.type === 'permission_denied') {
    console.log(`üö´ ${event.toolName} blocked: ${event.reason}`);
  } else if (event.type === 'text_delta') {
    process.stdout.write(event.text);
  }
}
```
</Tab>
<Tab value="Python">
```python
for event in session.stream("Clean up old logs"):
    if event.event_type == "confirmation_required":
        print(f"üîí Approve '{event.tool_name}'? {event.tool_args}")
        session.respond_confirmation(event.tool_id, approved=True)
    elif event.event_type == "permission_denied":
        print(f"üö´ {event.tool_name} blocked: {event.reason}")
    elif event.event_type == "text_delta":
        print(event.text, end="", flush=True)
```
</Tab>
</Tabs>

### Timeout Behavior

| TimeoutAction | Behavior |
|---------------|----------|
| `Reject` | Reject the tool call if no response within timeout (default) |
| `Approve` | Approve the tool call if no response within timeout |

## Workspace Boundaries

All file operations are restricted to the session's workspace directory. Attempts to access files outside the workspace are blocked.

```rust
let session = agent.session("/my-project", None)?;

// ‚úÖ Allowed: within workspace
session.read_file("src/main.rs").await?;

// ‚ùå Blocked: outside workspace
session.read_file("../other-project/secret.txt").await?;
```

## Extensible Security via Traits

A3S Code provides a `SecurityProvider` trait for implementing custom security logic:

```rust
pub trait SecurityProvider: Send + Sync {
    /// Classify and register sensitive data found in input text
    fn taint_input(&self, text: &str) {}

    /// Sanitize output text by redacting sensitive data
    fn sanitize_output(&self, text: &str) -> String {
        text.to_string()
    }

    /// Securely wipe all session security state
    fn wipe(&self) {}

    /// Register security hooks with the given engine
    fn register_hooks(&self, hook_engine: &HookEngine) {}

    /// Unregister all hooks from the engine
    fn teardown(&self, hook_engine: &HookEngine) {}
}
```

### Example: Custom Security Provider

```rust
use a3s_code_core::security::SecurityProvider;
use a3s_code_core::hooks::{HookEngine, HookEvent, HookResult};

struct MySecurityProvider {
    // Your security state
}

impl SecurityProvider for MySecurityProvider {
    fn taint_input(&self, text: &str) {
        // Detect and track sensitive data (SSN, API keys, etc.)
    }

    fn sanitize_output(&self, text: &str) -> String {
        // Redact sensitive data from LLM output
        text.replace("sk-ant-", "[REDACTED]")
    }

    fn register_hooks(&self, hook_engine: &HookEngine) {
        // Register pre/post tool use hooks for security checks
        hook_engine.register(/* your hooks */);
    }
}

// Use in session
let security = Arc::new(MySecurityProvider { /* ... */ });
let session = agent.session("/project", Some(
    SessionOptions::new().with_security_provider(security)
))?;
```

See [Hooks](/docs/code/hooks) for lifecycle event integration.

## Best Practices

1. **Start with strict policy** ‚Äî Use `PermissionPolicy::strict()` and explicitly allow only needed tools
2. **Block dangerous patterns** ‚Äî Always deny destructive bash commands: `bash(rm -rf:*)`, `bash(curl:*|sh)`
3. **Enable HITL for writes** ‚Äî Require confirmation for file modifications and bash execution
4. **Use workspace boundaries** ‚Äî Never disable workspace restrictions
5. **Implement SecurityProvider** ‚Äî Add custom taint tracking and output sanitization for sensitive data
6. **Audit logs** ‚Äî Use hooks to log all tool executions for security review

## Security Events

The agent emits security-related events during streaming:

| Event | When |
|-------|------|
| `PermissionDenied` | Tool call blocked by permission policy |
| `ConfirmationRequired` | HITL confirmation needed |
| `ConfirmationTimeout` | User didn't respond within timeout |
| `ConfirmationRejected` | User rejected the tool call |

See [Sessions](/docs/code/sessions) for full event reference.
