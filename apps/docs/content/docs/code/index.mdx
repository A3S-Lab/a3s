---
title: A3S Code
description: Library-first AI coding agent framework — embeddable Rust core with native Node.js and Python bindings, config-driven multi-provider LLM, 14 built-in tools, and defense-in-depth security
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# A3S Code

A3S Code is a high-performance Rust framework for building AI coding agents. It ships as an embeddable library (`a3s-code-core`) with native Python and Node.js bindings.

All subsystems — hooks, security, memory, MCP, subagent delegation, planning — are wired into the core and active by default.

## Key Features

- **Library-First** — Embeddable Rust library, no server needed
- **Native SDKs** — Node.js (napi-rs) and Python (PyO3) bindings
- **Config-Driven** — Multi-provider LLM config via HCL or JSON
- **Session-Per-Workspace** — One Agent serves many workspaces
- **Per-Session Model Override** — Use different models per session via `provider/model`
- **14 Built-in Tools** — 11 core tools + 3 skill discovery tools (search_skills, install_skill, load_skill)
- **Permission System** — Allow/Deny/Ask rules for fine-grained tool access control
- **Human-in-the-Loop** — Require user confirmation before sensitive operations
- **Skills System** — Markdown-based prompt-injection skills with runtime discovery and installation
- **Subagent Delegation** — Delegate specialized tasks to focused child agents
- **MCP Integration** — External tools via Model Context Protocol (JSON-RPC 2.0, stdio + HTTP+SSE)
- **8 Lifecycle Hooks** — Pre/post events for tool calls, sessions, messages, and errors
- **Security** — 5 layers: sanitizer, taint tracking, interceptor, injection detection, audit logging
- **Memory** — 4 types: episodic, semantic, procedural, working memory
- **JSON-Structured Planning** — Execution plans and goal tracking via LlmPlanner
- **Context Compaction** — Auto-summarize long conversations (80% threshold)
- **Context Store** — Persistent semantic search with embeddings (feature-gated: `context-store`)
- **File History** — Auto-snapshots (500-snapshot capacity) with diff and restore
- **Cost Tracking** — Per-session token cost calculation with per-model pricing
- **Thinking Models** — Extended reasoning with `reasoning_content` support
- **API Retry** — Exponential backoff for transient errors
- **`#[non_exhaustive]` Events** — AgentEvent uses `#[non_exhaustive]` for safe SDK evolution

## Quick Example

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, AgentEvent, SessionOptions};

// Create agent from config file
let agent = Agent::new("agent.hcl").await?;

// Bind session to workspace
let session = agent.session("/my-project", None)?;

// Streaming (AgentEvent is #[non_exhaustive] — always include a wildcard arm)
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::ToolCall { name, .. } => println!("\nTool: {name}"),
        AgentEvent::End { .. } => break,
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

// Create agent from config file
const agent = await Agent.create('agent.hcl');

// Bind session to workspace
const session = agent.session('/my-project');

// Streaming
const events = await session.stream('Refactor the auth module');
for (const event of events) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  if (event.type === 'tool_start') console.log(`\nTool: ${event.toolName}`);
}
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent

# Create agent from config file
agent = Agent.create("agent.hcl")

# Bind session to workspace
session = agent.session("/my-project")

# Streaming
for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nTool: {event.tool_name}")
```
</Tab>
</Tabs>

## Architecture at a Glance

```
Your App (Rust / TypeScript / Python)
  │
  ▼ Agent.create("agent.hcl")
┌──────────────────────────────────────────────────────┐
│  Agent (config-driven, workspace-independent)         │
│  ┌────────────┬──────────────┬─────────────────────┐ │
│  │ LlmClient  │  CodeConfig  │   SessionManager    │ │
│  └────────────┴──────────────┴─────────────────────┘ │
│                       │                               │
│        agent.session("/workspace", options)            │
│                       ▼                               │
│  ┌──────────────────────────────────────────────┐    │
│  │  AgentSession (workspace-bound)               │    │
│  │  ┌─────────┬──────────┬──────────┬─────────┐ │    │
│  │  │ Agent   │ Tool     │Permission│  LLM    │ │    │
│  │  │ Loop    │ Executor │ System   │ Provider│ │    │
│  │  │         │ (14)     │          │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Skills  │ Subagent │  Hook    │  MCP    │ │    │
│  │  │         │          │  Engine  │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Llm     │ Security │ Memory   │ File    │ │    │
│  │  │ Planner │          │          │ History │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Context │ Cost     │ Cron     │ Session │ │    │
│  │  │Compactor│ Tracking │Scheduler │ Store   │ │    │
│  │  └─────────┴──────────┴──────────┴─────────┘ │    │
│  └──────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```
