---
title: A3S Code
description: Library-first AI coding agent framework — embeddable Rust core with native Node.js and Python bindings, config-driven multi-provider LLM, 14 built-in tools, and defense-in-depth security
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# A3S Code

A3S Code is a high-performance Rust framework for building AI coding agents. It ships as an embeddable library (`a3s-code-core`) with native Python and Node.js bindings.

All subsystems — hooks, security, memory, MCP, subagent delegation, planning — are wired into the core and active by default.

## Key Features

- **Library-First** — Embeddable Rust library, no server needed
- **Native SDKs** — Node.js (napi-rs) and Python (PyO3) bindings
- **Config-Driven** — Multi-provider LLM config via HCL or JSON
- **Session-Per-Workspace** — One Agent serves many workspaces
- **Per-Session Model Override** — Use different models per session via `provider/model`
- **14 Built-in Tools** — 11 core tools + 3 skill discovery tools (search_skills, install_skill, load_skill)
- **Permission System** — Allow/Deny/Ask rules for fine-grained tool access control
- **Human-in-the-Loop** — Require user confirmation before sensitive operations
- **Skills System** — Markdown-based prompt-injection skills with runtime discovery and installation
- **Subagent Delegation** — Delegate specialized tasks to focused child agents
- **MCP Integration** — External tools via Model Context Protocol (JSON-RPC 2.0, stdio + HTTP+SSE)
- **8 Lifecycle Hooks** — Pre/post events for tool calls, sessions, messages, and errors
- **Security** — 5 layers: sanitizer, taint tracking, interceptor, injection detection, audit logging
- **Memory** — 4 types: episodic, semantic, procedural, working memory
- **JSON-Structured Planning** — Execution plans with dependency graphs and goal tracking via LlmPlanner
- **Parallel Plan Execution** — Independent plan steps execute concurrently via wave-based scheduling (`tokio::JoinSet`); dependent steps wait automatically
- **Lane Queue** — Priority-based tool routing with parallel reads (Query lane) and sequential writes (Execute lane)
- **External Task Offloading** — Route any lane to `External` mode; tool calls become `ExternalTask` objects that remote workers poll, execute, and complete via callback — enabling multi-machine parallel execution
- **Context Compaction** — Auto-summarize long conversations (80% threshold)
- **Context Store** — Persistent semantic search with embeddings (feature-gated: `context-store`)
- **File History** — Auto-snapshots (500-snapshot capacity) with diff and restore
- **Cost Tracking** — Per-session token cost calculation with per-model pricing
- **Thinking Models** — Extended reasoning with `reasoning_content` support
- **API Retry** — Exponential backoff for transient errors
- **`#[non_exhaustive]` Events** — AgentEvent uses `#[non_exhaustive]` for safe SDK evolution

## Quick Example

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, AgentEvent, SessionOptions};

// Create agent from config file
let agent = Agent::new("agent.hcl").await?;

// Bind session to workspace
let session = agent.session("/my-project", None)?;

// Streaming (AgentEvent is #[non_exhaustive] — always include a wildcard arm)
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::ToolStart { name, .. } => println!("\nTool: {name}"),
        AgentEvent::End { .. } => break,
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

// Create agent from config file
const agent = await Agent.create('agent.hcl');

// Bind session to workspace
const session = agent.session('/my-project');

// Streaming
const events = await session.stream('Refactor the auth module');
for (const event of events) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  if (event.type === 'tool_start') console.log(`\nTool: ${event.toolName}`);
}
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent

# Create agent from config file
agent = Agent.create("agent.hcl")

# Bind session to workspace
session = agent.session("/my-project")

# Streaming
for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nTool: {event.tool_name}")
```
</Tab>
</Tabs>

## Architecture at a Glance

```
Your App (Rust / TypeScript / Python)
  │
  ▼ Agent.create("agent.hcl")
┌──────────────────────────────────────────────────────┐
│  Agent (config-driven, workspace-independent)         │
│  ┌────────────┬──────────────┬─────────────────────┐ │
│  │ LlmClient  │  CodeConfig  │   SessionManager    │ │
│  └────────────┴──────────────┴─────────────────────┘ │
│                       │                               │
│        agent.session("/workspace", options)            │
│                       ▼                               │
│  ┌──────────────────────────────────────────────┐    │
│  │  AgentSession (workspace-bound)               │    │
│  │  ┌─────────┬──────────┬──────────┬─────────┐ │    │
│  │  │ Agent   │ Tool     │Permission│  LLM    │ │    │
│  │  │ Loop    │ Executor │ System   │ Provider│ │    │
│  │  │         │ (14)     │          │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Skills  │ Subagent │  Hook    │  MCP    │ │    │
│  │  │         │          │  Engine  │         │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Llm     │ Security │ Memory   │ File    │ │    │
│  │  │ Planner │          │          │ History │ │    │
│  │  ├─────────┼──────────┼──────────┼─────────┤ │    │
│  │  │ Wave    │ Context  │ Cost     │ Cron    │ │    │
│  │  │Scheduler│Compactor │ Tracking │Scheduler│ │    │
│  │  └─────────┴──────────┴──────────┴─────────┘ │    │
│  └──────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

## Parallel Plan Execution

Enable planning to decompose complex tasks into steps with a dependency graph. Independent steps execute **in parallel** — no extra configuration needed.

```
Wave 1: [Analyze auth] + [Analyze DB schema]  ← parallel
Wave 2: [Implement JWT integration]           ← waits for wave 1
Wave 3: [Write tests]                         ← waits for wave 2
```

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, AgentEvent, SessionOptions};

let agent = Agent::new("agent.hcl").await?;
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_planning(true)
        .with_goal_tracking(true)
))?;

let (mut rx, _handle) = session.stream("Refactor auth to use JWT and update all tests").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::StepStart { description, step_number, total_steps, .. } => {
            println!("[{step_number}/{total_steps}] Starting: {description}");
        }
        AgentEvent::StepEnd { status, step_number, total_steps, .. } => {
            println!("[{step_number}/{total_steps}] {status}");
        }
        AgentEvent::GoalProgress { progress, completed_steps, total_steps, .. } => {
            println!("Progress: {:.0}% ({completed_steps}/{total_steps})", progress * 100.0);
        }
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::End { .. } => break,
        _ => {}
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

const agent = await Agent.create('agent.hcl');
const session = agent.session('/my-project', {
  planning: true,
  goalTracking: true,
});

const events = await session.stream('Refactor auth to use JWT and update all tests');
for (const event of events) {
  if (event.type === 'step_start')
    console.log(`[${event.stepNumber}/${event.totalSteps}] Starting: ${event.description}`);
  if (event.type === 'step_end')
    console.log(`[${event.stepNumber}/${event.totalSteps}] ${event.status}`);
  if (event.type === 'goal_progress')
    console.log(`Progress: ${(event.progress * 100).toFixed(0)}%`);
  if (event.type === 'text_delta')
    process.stdout.write(event.text);
}
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent

agent = Agent.create("agent.hcl")
session = agent.session("/my-project", planning=True, goal_tracking=True)

for event in session.stream("Refactor auth to use JWT and update all tests"):
    if event.event_type == "step_start":
        print(f"[{event.step_number}/{event.total_steps}] Starting: {event.description}")
    elif event.event_type == "step_end":
        print(f"[{event.step_number}/{event.total_steps}] {event.status}")
    elif event.event_type == "goal_progress":
        print(f"Progress: {event.progress:.0%}")
    elif event.event_type == "text_delta":
        print(event.text, end="", flush=True)
```
</Tab>
</Tabs>

## External Task Offloading

Route any [lane](/docs/code/lane-queue) to **External** mode to offload tool calls to remote worker machines. The agent loop blocks until your SDK code polls the task, dispatches it to a worker, and feeds the result back.

```
Coordinator (agent session)          Workers (remote machines)
  Agent Loop → Lane Queue              ┌─ Worker A ─┐
    ├─ Query  [Internal] → local       │  bash exec  │
    ├─ Execute [External] ────────────→│  write exec │
    └─ Generate [Internal] → local     └─────────────┘
       pending_external_tasks() → dispatch → complete_external_task()
```

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{
    Agent, AgentEvent, SessionOptions, SessionQueueConfig,
    SessionLane, LaneHandlerConfig, TaskHandlerMode, ExternalTaskResult,
};

let session = agent.session("/project", Some(
    SessionOptions::new()
        .with_queue_config(SessionQueueConfig::default().with_lane_features())
))?;

// Route Execute lane to remote workers
session.set_lane_handler(SessionLane::Execute, LaneHandlerConfig {
    mode: TaskHandlerMode::External,
    timeout_ms: 60_000,
}).await;

let (mut rx, _handle) = session.stream("Run tests and deploy").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::ExternalTaskPending { .. } => {
            for task in session.pending_external_tasks().await {
                let session = session.clone();
                tokio::spawn(async move {
                    let result = dispatch_to_worker(&task).await;
                    session.complete_external_task(&task.task_id, result.into()).await;
                });
            }
        }
        AgentEvent::End { .. } => break,
        _ => {}
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const session = agent.session('/project', {
  queueConfig: { enableAllFeatures: true },
});

await session.setLaneHandler('execute', { mode: 'external', timeoutMs: 60000 });

const events = await session.stream('Run tests and deploy');
for (const event of events) {
  if (event.type === 'external_task_pending') {
    const tasks = await session.pendingExternalTasks();
    await Promise.all(tasks.map(async (task) => {
      const result = await dispatchToWorker(task);
      await session.completeExternalTask(task.task_id, result);
    }));
  }
}
```
</Tab>
<Tab value="Python">
```python
session = agent.session("/project",
    queue_config=SessionQueueConfig().with_lane_features())

session.set_lane_handler("execute", mode="external", timeout_ms=60000)

for event in session.stream("Run tests and deploy"):
    if event.event_type == "external_task_pending":
        for task in session.pending_external_tasks():
            result = dispatch_to_worker(task)
            session.complete_external_task(task["task_id"], result)
```
</Tab>
</Tabs>

Three handler modes: **Internal** (local default), **External** (block for callback), **Hybrid** (local + notify). Lanes switch at runtime. See the full guide: [Lane Queue → External Task Handling](/docs/code/lane-queue#external-task-handling).
