---
title: Code Generation
description: Generate responses with streaming support
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Code Generation

The generation APIs send prompts to the LLM and return responses. The agent loop handles tool execution automatically â€” you just call `send()` or `stream()`.

## Send (Non-Streaming)

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let result = session.send("What files are in the src/ directory?").await?;

println!("{}", result.text);                    // Assistant response
println!("Tools: {}", result.tool_calls_count); // Tool calls made
println!("Tokens: {}", result.usage.total_tokens);
```
</Tab>
<Tab value="TypeScript">
```typescript
const result = await session.send('What files are in the src/ directory?');

console.log(result.text);
console.log(`Tools: ${result.toolCallsCount}`);
console.log(`Tokens: ${result.totalTokens}`);
```
</Tab>
<Tab value="Python">
```python
result = session.send("What files are in the src/ directory?")

print(result.text)
print(f"Tools: {result.tool_calls_count}")
print(f"Tokens: {result.total_tokens}")
```
</Tab>
</Tabs>

## Stream

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
// AgentEvent is #[non_exhaustive] â€” always include a wildcard arm
let (mut rx, _handle) = session.stream("Explain the auth module").await?;

while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::ToolCall { name, .. } => println!("\nðŸ”§ {name}"),
        AgentEvent::End { usage, .. } => {
            println!("\nâœ… {} tokens", usage.total_tokens);
            break;
        }
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const events = await session.stream('Explain the auth module');
for (const event of events) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  if (event.type === 'tool_start') console.log(`\nðŸ”§ ${event.toolName}`);
  if (event.type === 'tool_end') console.log(`  â†’ ${event.toolOutput?.slice(0, 200)}`);
  if (event.type === 'end') console.log(`\nâœ… ${event.totalTokens} tokens`);
}
```
</Tab>
<Tab value="Python">
```python
for event in session.stream("Explain the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nðŸ”§ {event.tool_name}")
    elif event.event_type == "tool_end":
        print(f"  â†’ {event.tool_output[:200]}")
    elif event.event_type == "end":
        print(f"\nâœ… {event.total_tokens} tokens")
```
</Tab>
</Tabs>

## Conversation History (Rust)

Maintain multi-turn conversations by passing history:

```rust
use a3s_code_core::llm::Message;

let history = vec![
    Message::user("What's in src/?"),
    Message::assistant("The src/ directory contains main.rs and lib.rs."),
];

let result = session.send_with_history(&history, "Now explain main.rs").await?;
```

## Event Types

| Event | Fields | Description |
|-------|--------|-------------|
| `start` | `prompt` | Generation started |
| `turn_start` | `turn` | New agent turn |
| `text_delta` | `text` | Text chunk from assistant |
| `tool_start` | `tool_id`, `tool_name` | Tool execution started |
| `tool_end` | `tool_id`, `tool_name`, `tool_output`, `exit_code` | Tool execution completed |
| `tool_output_delta` | `tool_id`, `tool_name`, `text` | Tool output increment |
| `turn_end` | `turn`, `total_tokens` | Turn completed |
| `end` | `text`, `total_tokens` | Generation finished |
| `confirmation_required` | `tool_id`, `tool_name`, `description` | HITL confirmation needed |
| `error` | `error` | Error occurred |
