---
title: Built-in Tools
description: 11 built-in tools (12 with sandbox) for file operations, shell execution, search, web access, and subagent delegation
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Built-in Tools

A3S Code ships with 11 built-in tools (12 with the `sandbox` feature) covering file operations, shell execution, search, web access, and subagent delegation. All tools execute in-process via native Rust implementations.

## Tool Reference

| Tool | Purpose | Example |
|------|---------|---------|
| `read` | Read files with line numbers | View source code |
| `write` | Create/overwrite files | Create new files |
| `edit` | String replacement editing | Modify existing code |
| `patch` | Apply unified diff patches | Complex multi-line edits |
| `bash` | Execute shell commands | `git status`, `npm install` |
| `grep` | Search file contents (ripgrep) | Find function definitions |
| `glob` | Find files by pattern | `**/*.ts`, `src/**/*.rs` |
| `ls` | List directory contents | Explore project structure |
| `web_fetch` | Fetch web content | Download documentation |
| `web_search` | Search the web | Query multiple search engines |
| `task` | Delegate to subagents | Offload specialized work |
| `sandbox` | Execute in MicroVM | Isolated execution (`sandbox` feature) |

## File Operations

### `read`

Read file contents with line numbers. Supports offset and limit for large files.

```json
{
  "file_path": "src/main.rs",
  "offset": 0,
  "limit": 100
}
```

### `write`

Create or overwrite a file. Automatically creates parent directories.

```json
{
  "file_path": "src/config.rs",
  "content": "pub struct Config {\n    pub port: u16,\n}\n"
}
```

### `edit`

Replace a specific string in a file. Useful for targeted modifications.

```json
{
  "file_path": "src/main.rs",
  "old_string": "fn main() {",
  "new_string": "fn main() -> Result<()> {"
}
```

### `patch`

Apply a unified diff patch. Best for complex multi-line edits.

```json
{
  "file_path": "src/lib.rs",
  "diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,3 +1,4 @@\n+use anyhow::Result;\n use std::io;\n"
}
```

## Search

### `grep`

Search file contents using ripgrep patterns. Supports regex, globs, and context lines.

```json
{
  "pattern": "fn.*async",
  "path": "src/",
  "glob": "*.rs",
  "context": 2
}
```

### `glob`

Find files matching a glob pattern.

```json
{
  "pattern": "src/**/*.rs"
}
```

### `ls`

List directory contents with file sizes and types.

```json
{
  "path": "src/"
}
```

## Shell

### `bash`

Execute shell commands. Commands run in the session's workspace directory.

```json
{
  "command": "cargo test --lib -- test_name"
}
```

**Security:** Use [Permission System](/docs/code/security) to control bash access:

```rust
policy.deny("bash(rm -rf:*)");  // Block destructive commands
policy.ask("bash(*)");          // Require confirmation for all bash
```

## Web

### `web_fetch`

Fetch content from a URL. Returns text content extracted from HTML.

```json
{
  "url": "https://docs.rs/tokio/latest/tokio/"
}
```

### `web_search`

Search the web using multiple search engines.

```json
{
  "query": "rust async trait object",
  "engine": "google"
}
```

## Direct Tool Execution

Call tools directly on the session without going through the LLM:

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
// Convenience wrappers
let content = session.read_file("src/main.rs").await?;
let output = session.bash("cargo test --lib").await?;
let files = session.glob("**/*.rs").await?;
let matches = session.grep("fn main").await?;

// Generic tool call with JSON args
let result = session.tool("edit", serde_json::json!({
    "file_path": "src/main.rs",
    "old_string": "fn main() {",
    "new_string": "fn main() -> Result<()> {"
})).await?;
println!("[{}] {}", result.exit_code, result.output);
```
</Tab>
<Tab value="TypeScript">
```typescript
// Convenience wrappers
const content = await session.readFile('src/main.rs');
const output = await session.bash('cargo test --lib');
const files = await session.glob('**/*.rs');
const matches = await session.grep('fn main');

// Generic tool call
const result = await session.tool('edit', {
  file_path: 'src/main.rs',
  old_string: 'fn main() {',
  new_string: 'fn main() -> Result<()> {',
});
console.log(`[${result.exitCode}] ${result.output}`);
```
</Tab>
<Tab value="Python">
```python
# Convenience wrappers
content = session.read_file("src/main.rs")
output = session.bash("cargo test --lib")
files = session.glob("**/*.rs")
matches = session.grep("fn main")

# Generic tool call with dict args
result = session.tool("edit", {
    "file_path": "src/main.rs",
    "old_string": "fn main() {",
    "new_string": "fn main() -> Result<()> {"
})
print(f"[{result['exit_code']}] {result['output']}")
```
</Tab>
</Tabs>

## Subagent Delegation

### `task`

Delegate work to a specialized child agent. The child agent runs in its own session with its own conversation history. See [Subagents](/docs/code/subagents) for details.

```json
{
  "description": "Write unit tests for the auth module",
  "prompt": "Create comprehensive tests for src/auth.rs covering all edge cases"
}
```

## Sandbox (Optional)

### `sandbox`

Execute commands in an isolated [A3S Box](/docs/box) MicroVM. Requires the `sandbox` Cargo feature.

```toml
a3s-code-core = { version = "0.7", features = ["sandbox"] }
```

Two modes of operation:

**Transparent Routing** — When `SandboxConfig` is set on the session, the `bash` tool silently routes through the sandbox:

```rust
use a3s_code_core::{SessionOptions, SandboxConfig};

let session = agent.session(".", Some(
    SessionOptions::new().with_sandbox(SandboxConfig {
        image: "ubuntu:22.04".into(),
        memory_mb: 512,
        network: false,
        ..SandboxConfig::default()
    })
))?;

// bash commands run inside the MicroVM sandbox
let result = session.send("Run the test suite", None).await?;
```

**Explicit `sandbox` Tool** — With the feature enabled, a `sandbox` tool is registered so the LLM can choose to use it explicitly. The workspace is mounted at `/workspace` inside the sandbox.

| `SandboxConfig` Field | Type | Default | Description |
|----------------------|------|---------|-------------|
| `image` | `string` | `"alpine:latest"` | OCI image reference |
| `memory_mb` | `u32` | `512` | Memory limit in megabytes |
| `cpus` | `u32` | `1` | Number of vCPUs |
| `network` | `bool` | `false` | Enable outbound networking |
| `env` | `HashMap<String,String>` | `{}` | Environment variables to inject |

## File Version History

All file-modifying tools (`write`, `edit`, `patch`) automatically capture a snapshot before making changes. You can:

- View the diff between versions
- Restore any previous version
- Track all modifications made during a session

The file history maintains up to 500 snapshots per session.

## Extending with Custom Tools

Beyond built-in tools, A3S Code supports external tool integration via:

- **[MCP](/docs/code/mcp)** — Connect external tool servers via Model Context Protocol (JSON-RPC 2.0, stdio + HTTP+SSE)
- **Custom Tool Trait** — Implement the `Tool` trait in Rust and register with `ToolRegistry`

See [MCP](/docs/code/mcp) for external tool integration examples.
