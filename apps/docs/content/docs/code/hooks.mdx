---
title: Lifecycle Hooks
description: 8 lifecycle hooks for intercepting tool calls, LLM generations, sessions, and skills
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Lifecycle Hooks

A3S Code provides 8 lifecycle hooks for intercepting and reacting to events during agent execution. Hooks enable logging, security enforcement, telemetry, and custom behavior without modifying the core agent loop.

## Hook Events

| Hook | Fires | Use Case |
|------|-------|----------|
| `PreToolUse` | Before tool execution | Validate args, taint tracking, block dangerous calls |
| `PostToolUse` | After tool execution | Audit logging, injection scanning, output filtering |
| `GenerateStart` | Before LLM call | Injection detection, prompt logging |
| `GenerateEnd` | After LLM response | Output sanitization, PII redaction |
| `SessionStart` | Session created | Initialize session resources |
| `SessionEnd` | Session destroyed | Cleanup, persist state |
| `SkillLoad` | Skill loaded | Validate skill, log activation |
| `SkillUnload` | Skill unloaded | Cleanup skill resources |

## How Hooks Work

Hooks are registered on the `HookEngine` and fire at specific points in the agent loop. Multiple hooks can listen to the same event — they execute in priority order (lower number = higher priority).

```
Agent Loop
  ├── GenerateStart hooks fire
  ├── LLM call
  ├── GenerateEnd hooks fire
  └── For each tool_use:
      ├── PreToolUse hooks fire
      ├── Permission check
      ├── HITL check
      ├── Tool execution
      └── PostToolUse hooks fire
```

## Built-in SecurityGuard

The `SecurityGuard` registers hooks at priority 1 (highest) automatically:

| Hook | SecurityGuard Behavior |
|------|----------------------|
| `PreToolUse` | Taint tracking — checks if sensitive values leak into tool arguments |
| `PostToolUse` | Injection scanning — detects prompt injection in tool outputs |
| `GenerateStart` | Injection detection — scans user prompt for injection patterns |
| `GenerateEnd` | Output sanitization — redacts PII from LLM responses |

## Hook Registration (Rust)

Register hooks and handlers via the `HookEngine`:

```rust
use a3s_code_core::hooks::{
    Hook, HookConfig, HookEngine, HookEvent, HookEventType,
    HookHandler, HookResult, HookResponse, HookMatcher,
};
use std::sync::Arc;

let engine = HookEngine::new();

// 1. Register a hook definition (what to listen for)
engine.register(
    Hook::new("log-tools", HookEventType::PreToolUse)
        .with_config(HookConfig { priority: 10, ..Default::default() })
);

// 2. Register a handler (what to do when fired)
struct LogHandler;
impl HookHandler for LogHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            println!("Tool: {} Args: {:?}", e.tool, e.args);
        }
        HookResponse::continue_()
    }
}
engine.register_handler("log-tools", Arc::new(LogHandler));

// Block dangerous patterns
engine.register(
    Hook::new("block-dangerous", HookEventType::PreToolUse)
        .with_matcher(HookMatcher::tool("bash"))
        .with_config(HookConfig { priority: 5, ..Default::default() })
);

struct BlockHandler;
impl HookHandler for BlockHandler {
    fn handle(&self, event: &HookEvent) -> HookResponse {
        if let HookEvent::PreToolUse(e) = event {
            if e.args.to_string().contains("rm -rf") {
                return HookResponse::block("Dangerous command blocked");
            }
        }
        HookResponse::continue_()
    }
}
engine.register_handler("block-dangerous", Arc::new(BlockHandler));

// Fire a hook (done automatically by the agent loop)
let result = engine.fire(&event).await;
match result {
    HookResult::Continue(None) => { /* proceed */ }
    HookResult::Continue(Some(modified)) => { /* proceed with modified data */ }
    HookResult::Block(reason) => { /* stop execution */ }
    _ => {}
}
```

## Hook Priority

Hooks execute in priority order. Lower numbers run first.

| Priority | Convention |
|----------|-----------|
| 1 | SecurityGuard (built-in, always runs first) |
| 2-9 | Critical custom hooks (validation, blocking) |
| 10-49 | Standard hooks (logging, telemetry) |
| 50+ | Low-priority hooks (analytics, optional processing) |

If any hook returns `HookResult::Block`, the operation is cancelled and subsequent hooks for that event are skipped.

## Hook Event Payloads

Each hook event carries a typed payload with event-specific data:

| Event | Payload Type | Fields |
|-------|-------------|--------|
| `PreToolUse` | `PreToolUseEvent` | `session_id`, `tool`, `args`, `working_directory`, `recent_tools` |
| `PostToolUse` | `PostToolUseEvent` | `session_id`, `tool`, `args`, `result` (`success`, `output`, `exit_code`, `duration_ms`) |
| `GenerateStart` | `GenerateStartEvent` | `session_id`, `prompt`, `system_prompt`, `model_provider`, `model_name`, `available_tools` |
| `GenerateEnd` | `GenerateEndEvent` | `session_id`, `prompt`, `response_text`, `tool_calls`, `usage`, `duration_ms` |
| `SessionStart` | `SessionStartEvent` | `session_id`, `system_prompt`, `model_provider`, `model_name` |
| `SessionEnd` | `SessionEndEvent` | `session_id`, `total_tokens`, `total_tool_calls`, `duration_ms` |
| `SkillLoad` | `SkillLoadEvent` | `skill_name`, `tool_names`, `version`, `description`, `loaded_at` |
| `SkillUnload` | `SkillUnloadEvent` | `skill_name`, `tool_names`, `duration_ms` |
