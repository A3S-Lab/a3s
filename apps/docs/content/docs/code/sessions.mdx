---
title: Sessions
description: Create and configure workspace-bound agent sessions
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Sessions

Each session is bound to a workspace directory. The Agent creates sessions via `agent.session(workspace, options?)`. Sessions hold their own LLM client, conversation history, and tool context.

## Create Session

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::{Agent, SessionOptions};

let agent = Agent::new("agent.hcl").await?;

// Default session (uses config's default model)
let session = agent.session("/my-project", None)?;

// Session with model override
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_model("openai/gpt-4o")
))?;
```
</Tab>
<Tab value="TypeScript">
```typescript
const { Agent } = require('@a3s-lab/code');

const agent = await Agent.create('agent.hcl');

// Default session
const session = agent.session('/my-project');

// Session with model override
const session = agent.session('/my-project', {
  model: 'openai/gpt-4o',
});
```
</Tab>
<Tab value="Python">
```python
from a3s_code import Agent

agent = Agent.create("agent.hcl")

# Default session
session = agent.session("/my-project")

# Session with model override
session = agent.session("/my-project", model="openai/gpt-4o")
```
</Tab>
</Tabs>

## SessionOptions

| Parameter | Rust | TypeScript | Python | Description |
|-----------|------|-----------|--------|-------------|
| Model override | `with_model("provider/model")` | `model: "provider/model"` | `model="provider/model"` | Format: `provider/model` (e.g., `openai/gpt-4o`) |

The model must be defined in the agent's config file under `providers`. The format is `provider_name/model_id`.

> **Note:** `skill_dirs` and `agent_dirs` are configured at the agent level via `CodeConfig`, not per-session. See [Configuration](#configuration) below.

## Send (Non-Streaming)

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
let result = session.send("What files handle authentication?").await?;
println!("{}", result.text);
println!("Tools: {}, Tokens: {}", result.tool_calls_count, result.usage.total_tokens);
```
</Tab>
<Tab value="TypeScript">
```typescript
const result = await session.send('What files handle authentication?');
console.log(result.text);
console.log(`Tools: ${result.toolCallsCount}, Tokens: ${result.totalTokens}`);
```
</Tab>
<Tab value="Python">
```python
result = session.send("What files handle authentication?")
print(result.text)
print(f"Tools: {result.tool_calls_count}, Tokens: {result.total_tokens}")
```
</Tab>
</Tabs>

## Stream

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
use a3s_code_core::AgentEvent;

// AgentEvent is #[non_exhaustive] â€” always include a wildcard arm
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;
while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::TextDelta { text } => print!("{text}"),
        AgentEvent::ToolStart { name, .. } => println!("\nðŸ”§ {name}"),
        AgentEvent::End { text, usage } => {
            println!("\nâœ… Done: {} tokens", usage.total_tokens);
            break;
        }
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```
</Tab>
<Tab value="TypeScript">
```typescript
const events = await session.stream('Refactor the auth module');
for (const event of events) {
  if (event.type === 'text_delta') process.stdout.write(event.text);
  if (event.type === 'tool_start') console.log(`\nðŸ”§ ${event.toolName}`);
  if (event.type === 'tool_end') console.log(`  â†’ ${event.toolOutput?.slice(0, 100)}`);
}
```
</Tab>
<Tab value="Python">
```python
for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nðŸ”§ {event.tool_name}")
    elif event.event_type == "tool_end":
        print(f"  â†’ {event.tool_output[:100]}")
```
</Tab>
</Tabs>

## Conversation History (Rust)

Maintain multi-turn conversations by passing history:

```rust
use a3s_code_core::llm::{ContentBlock, Message};

let history = vec![
    Message::user("What's in src/?"),
    Message {
        role: "assistant".to_string(),
        content: vec![ContentBlock::Text {
            text: "The src/ directory contains main.rs and lib.rs.".to_string(),
        }],
        reasoning_content: None,
    },
];

// Continue the conversation
let result = session.send_with_history(&history, "Now explain main.rs").await?;
```

## Direct Tool Execution

Call tools directly without going through the LLM:

<Tabs groupId="lang" items={['Rust', 'TypeScript', 'Python']}>
<Tab value="Rust">
```rust
session.read_file("src/main.rs").await?;
session.bash("cargo test").await?;
session.glob("**/*.rs").await?;
session.grep("fn main").await?;
session.tool("write", serde_json::json!({"file_path": "x.rs", "content": "..."})).await?;
```
</Tab>
<Tab value="TypeScript">
```typescript
await session.readFile('src/main.rs');
await session.bash('cargo test');
await session.glob('**/*.rs');
await session.grep('fn main');
await session.tool('write', { file_path: 'x.rs', content: '...' });
```
</Tab>
<Tab value="Python">
```python
session.read_file("src/main.rs")
session.bash("cargo test")
session.glob("**/*.rs")
session.grep("fn main")
session.tool("write", {"file_path": "x.rs", "content": "..."})
```
</Tab>
</Tabs>

## Configuration

Full HCL configuration reference:

```hcl
# === LLM (required) ===
default_model = "anthropic/claude-sonnet-4-20250514"

# === Agent Behavior ===
max_tool_rounds  = 20          # default: 50
thinking_budget  = 4096        # reasoning token budget

# === Extensions ===
skill_dirs = ["./skills"]      # *.md skill files
agent_dirs = ["./agents"]      # *.yaml/*.md agent files

# === Storage ===
storage_backend = "file"       # "memory" | "file" | "custom"
sessions_dir    = "/tmp/a3s"   # session persistence path
storage_url     = "redis://localhost:6379"

# === Providers ===
providers {
  name    = "anthropic"
  api_key = "sk-ant-..."

  models {
    id          = "claude-sonnet-4-20250514"
    name        = "Claude Sonnet 4"
    family      = "claude-sonnet"
    tool_call   = true
    temperature = true
    reasoning   = false
    cost {
      input       = 3.0
      output      = 15.0
      cache_read  = 0.3
      cache_write = 3.75
    }
    limit {
      context = 200000
      output  = 8192
    }
  }
}

providers {
  name    = "openai"
  api_key = "sk-..."

  models {
    id        = "gpt-4o"
    name      = "GPT-4o"
    tool_call = true
  }

  models {
    id        = "gpt-4o-proxy"
    name      = "GPT-4o (via Proxy)"
    api_key   = "sk-proxy-key..."                 # per-model override
    base_url  = "https://proxy.example.com/v1"    # per-model override
    tool_call = true
  }
}
```

Provider-level `api_key` and `base_url` are defaults. Model-level values override them. See [Providers](/docs/code/providers) for details.

### Config Options

| Field | HCL | JSON | Type | Default |
|-------|-----|------|------|---------|
| Default model | `default_model` | `defaultModel` | `string` | â€” (required, `provider/model` format) |
| Max tool rounds | `max_tool_rounds` | `maxToolRounds` | `int?` | `50` |
| Thinking budget | `thinking_budget` | `thinkingBudget` | `int?` | `null` |
| Skill dirs | `skill_dirs` | `skillDirs` | `string[]` | `[]` |
| Agent dirs | `agent_dirs` | `agentDirs` | `string[]` | `[]` |
| Storage backend | `storage_backend` | `storageBackend` | `string` | `"file"` |
| Sessions dir | `sessions_dir` | `sessionsDir` | `string?` | `null` |
| Storage URL | `storage_url` | `storageUrl` | `string?` | `null` |

## Return Types

### AgentResult

| Field | Type | Description |
|-------|------|-------------|
| `text` | `string` | Final LLM response text |
| `messages` | `Vec<Message>` | Full conversation history (Rust only) |
| `usage` | `TokenUsage` | Token usage statistics |
| `tool_calls_count` | `usize` | Number of tool calls |

### TokenUsage

| Field | Type | Description |
|-------|------|-------------|
| `prompt_tokens` | `usize` | Input tokens |
| `completion_tokens` | `usize` | Output tokens |
| `total_tokens` | `usize` | Total tokens |
| `cache_read_tokens` | `Option<usize>` | Cached input tokens read |
| `cache_write_tokens` | `Option<usize>` | Cached input tokens written |

### AgentEvent

| Event Type | Fields | Description |
|-----------|--------|-------------|
| `start` | `prompt` | Processing started |
| `text_delta` | `text` | Text increment |
| `turn_start` | `turn` | New turn started |
| `turn_end` | `turn`, `total_tokens` | Turn completed |
| `tool_start` | `tool_id`, `tool_name` | Tool call started |
| `tool_end` | `tool_id`, `tool_name`, `tool_output`, `exit_code` | Tool call completed |
| `tool_output_delta` | `tool_id`, `tool_name`, `text` | Tool output increment |
| `end` | `text`, `total_tokens` | Completed |
| `confirmation_required` | `tool_id`, `tool_name`, `args`, `timeout_ms` | HITL confirmation needed |
| `confirmation_received` | `tool_id`, `approved`, `reason` | HITL confirmation received |
| `confirmation_timeout` | `tool_id`, `action_taken` | HITL confirmation timed out |
| `permission_denied` | `tool_id`, `tool_name`, `args`, `reason` | Tool blocked by permission policy |
| `context_resolving` | `providers` | Context resolution started |
| `context_resolved` | `total_items`, `total_tokens` | Context resolution completed |
| `task_updated` | `session_id`, `tasks` | Task list updated |
| `error` | `error` | Error occurred |
