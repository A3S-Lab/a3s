---
title: Python SDK
description: Native PyO3 bindings for A3S Code
---

# Python SDK

The `a3s-code` package provides native PyO3 bindings to `a3s-code-core`. Synchronous API â€” all calls block until completion.

## Installation

```bash
pip install a3s-code
```

## Create Agent

```python
from a3s_code import Agent

# From config file (.hcl or .json)
agent = Agent.create("agent.hcl")

# From inline JSON string
agent = Agent.create('{"defaultModel": "anthropic/claude-sonnet-4-20250514", ...}')
```

## Create Session

```python
# Default session (uses config's default model)
session = agent.session("/my-project")

# Override model for this session
session = agent.session("/my-project", model="openai/gpt-4o")
```

## Send (Non-Streaming)

```python
result = session.send("What files handle authentication?")
print(result.text)
print(f"Tools: {result.tool_calls_count}, Tokens: {result.total_tokens}")
```

## Stream

```python
for event in session.stream("Refactor the auth module"):
    if event.event_type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.event_type == "tool_start":
        print(f"\nðŸ”§ {event.tool_name}")
    elif event.event_type == "tool_end":
        print(f"  â†’ {event.tool_output[:100]}")
```

## Direct Tool Execution

```python
# Generic tool call
result = session.tool("bash", {"command": "cargo test"})
print(f"[{result['exit_code']}] {result['output']}")

# Convenience wrappers
content = session.read_file("src/main.rs")
output = session.bash("git status")
files = session.glob("**/*.py")
matches = session.grep("def main")
```

## Return Types

```python
class AgentResult:
    text: str                    # Final response text
    tool_calls_count: int        # Number of tool calls
    prompt_tokens: int           # Prompt tokens used
    completion_tokens: int       # Completion tokens used
    total_tokens: int            # Total tokens used

class AgentEvent:
    event_type: str              # "start", "text_delta", "tool_start", etc.
    text: str | None             # For text_delta, end
    tool_name: str | None        # For tool_start, tool_end, permission_denied
    tool_id: str | None          # For tool_start, tool_end, confirmation_required
    tool_output: str | None      # For tool_end
    tool_args: dict | None       # For confirmation_required, permission_denied
    exit_code: int | None        # For tool_end
    turn: int | None             # For turn_start, turn_end
    prompt: str | None           # For start
    timeout_ms: int | None       # For confirmation_required
    reason: str | None           # For permission_denied
    error: str | None            # For error
    total_tokens: int | None     # For turn_end, end
```

## Notes

The Python SDK uses synchronous blocking calls via `py.allow_threads(|| runtime.block_on(...))`. This is the standard PyO3 pattern â€” the GIL is released during Rust execution, so other Python threads can run concurrently.
