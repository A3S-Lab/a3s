---
title: Rust SDK
description: Embed A3S Code directly in Rust â€” the native core library
---

# Rust SDK

The Rust SDK (`a3s-code-core`) is the native core library. All other SDKs are bindings to this crate.

## Installation

```toml
[dependencies]
a3s-code-core = "0.7.1"
tokio = { version = "1", features = ["full"] }
```

## Create Agent

```rust
use a3s_code_core::{Agent, AgentEvent, SessionOptions};

// From config file (.hcl or .json)
let agent = Agent::new("agent.hcl").await?;

// From inline JSON
let agent = Agent::new(r#"{"defaultModel": "anthropic/claude-sonnet-4-20250514", ...}"#).await?;

// From CodeConfig struct
let agent = Agent::from_config(config).await?;
```

## Create Session

```rust
// Default session (uses config's default model)
let session = agent.session("/my-project", None)?;

// Override model for this session
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_model("openai/gpt-4o")
))?;
```

## Send (Non-Streaming)

```rust
let result = session.send("What files handle authentication?").await?;

println!("{}", result.text);
println!("Tools called: {}", result.tool_calls_count);
println!("Tokens: {}", result.usage.total_tokens);
```

## Stream

```rust
// AgentEvent is #[non_exhaustive] â€” always include a wildcard arm
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;

while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::Start { prompt } => {
            println!("Starting: {prompt}");
        }
        AgentEvent::TurnStart { turn } => {
            println!("--- Turn {turn} ---");
        }
        AgentEvent::TextDelta { text } => {
            print!("{text}");
        }
        AgentEvent::ToolStart { id, name } => {
            println!("\nðŸ”§ {name} ({id})");
        }
        AgentEvent::ToolEnd { id, name, output, exit_code } => {
            println!("  â†’ [{exit_code}] {}", &output[..200.min(output.len())]);
        }
        AgentEvent::TurnEnd { turn, usage } => {
            println!("\n--- Turn {turn} done ({} tokens) ---", usage.total_tokens);
        }
        AgentEvent::End { text, usage } => {
            println!("\nâœ… Done: {} tokens", usage.total_tokens);
            break;
        }
        AgentEvent::Error { message } => {
            eprintln!("âŒ {message}");
        }
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```

## Conversation History

Maintain multi-turn conversations by passing history:

```rust
use a3s_code_core::llm::{ContentBlock, Message};

let history = vec![
    Message::user("What's in src/?"),
    Message {
        role: "assistant".to_string(),
        content: vec![ContentBlock::Text {
            text: "The src/ directory contains main.rs and lib.rs.".to_string(),
        }],
        reasoning_content: None,
    },
];

// Continue the conversation
let result = session.send_with_history(&history, "Now explain main.rs").await?;
```

## Direct Tool Execution

Call tools directly without going through the LLM:

```rust
// Generic tool call
let result = session.tool("bash", serde_json::json!({
    "command": "cargo test --lib"
})).await?;
println!("Exit: {}, Output: {}", result.exit_code, result.output);

// Convenience wrappers
let content = session.read_file("src/main.rs").await?;
let output = session.bash("git status").await?;
let files = session.glob("**/*.rs").await?;
let matches = session.grep("fn main").await?;
```

## Return Types

```rust
pub struct AgentResult {
    pub text: String,
    pub messages: Vec<Message>,       // Full conversation history
    pub usage: TokenUsage,
    pub tool_calls_count: usize,
}

pub struct TokenUsage {
    pub prompt_tokens: usize,
    pub completion_tokens: usize,
    pub total_tokens: usize,
    pub cache_read_tokens: Option<usize>,
    pub cache_write_tokens: Option<usize>,
}

pub struct ToolCallResult {
    pub name: String,
    pub output: String,
    pub exit_code: i32,
}

#[non_exhaustive]
pub enum AgentEvent {
    Start { prompt: String },
    TurnStart { turn: usize },
    TextDelta { text: String },
    ToolStart { id: String, name: String },
    ToolEnd { id: String, name: String, output: String, exit_code: i32 },
    ToolOutputDelta { id: String, name: String, delta: String },
    TurnEnd { turn: usize, usage: TokenUsage },
    End { text: String, usage: TokenUsage },
    ConfirmationRequired { tool_id: String, tool_name: String, args: Value, timeout_ms: u64 },
    ConfirmationReceived { tool_id: String, approved: bool, reason: Option<String> },
    ConfirmationTimeout { tool_id: String, action_taken: String },
    PermissionDenied { tool_id: String, tool_name: String, args: Value, reason: String },
    ContextResolving { providers: Vec<String> },
    ContextResolved { total_items: usize, total_tokens: usize },
    TaskUpdated { session_id: String, tasks: Vec<Task> },
    Error { message: String },
    // ... future variants may be added (use _ => {} in match)
}
```
