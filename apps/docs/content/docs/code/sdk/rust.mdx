---
title: Rust SDK
description: Embed A3S Code directly in Rust â€” the native core library
---

# Rust SDK

The Rust SDK (`a3s-code-core`) is the native core library. All other SDKs are bindings to this crate.

## Installation

```toml
[dependencies]
a3s-code-core = "0.7.2"
tokio = { version = "1", features = ["full"] }
```

## Create Agent

```rust
use a3s_code_core::{Agent, AgentEvent, SessionOptions};

// From config file (.hcl or .json)
let agent = Agent::new("agent.hcl").await?;

// From inline JSON
let agent = Agent::new(r#"{"defaultModel": "anthropic/claude-sonnet-4-20250514", ...}"#).await?;

// From CodeConfig struct
let agent = Agent::from_config(config).await?;
```

## Create Session

```rust
// Default session (uses config's default model)
let session = agent.session("/my-project", None)?;

// Override model for this session
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_model("openai/gpt-4o")
))?;

// With custom skill and agent directories
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_skill_dir("~/.a3s/skills")
        .with_agent_dir("~/.a3s/agents")
))?;
```

## Send (Non-Streaming)

```rust
let result = session.send("What files handle authentication?").await?;

println!("{}", result.text);
println!("Tools called: {}", result.tool_calls_count);
println!("Tokens: {}", result.usage.total_tokens);
```

## Stream

```rust
// AgentEvent is #[non_exhaustive] â€” always include a wildcard arm
let (mut rx, _handle) = session.stream("Refactor the auth module").await?;

while let Some(event) = rx.recv().await {
    match event {
        AgentEvent::Start { prompt } => {
            println!("Starting: {prompt}");
        }
        AgentEvent::TurnStart { turn } => {
            println!("--- Turn {turn} ---");
        }
        AgentEvent::TextDelta { text } => {
            print!("{text}");
        }
        AgentEvent::ToolStart { id, name } => {
            println!("\nðŸ”§ {name} ({id})");
        }
        AgentEvent::ToolEnd { id, name, output, exit_code } => {
            println!("  â†’ [{exit_code}] {}", &output[..200.min(output.len())]);
        }
        AgentEvent::TurnEnd { turn, usage } => {
            println!("\n--- Turn {turn} done ({} tokens) ---", usage.total_tokens);
        }
        AgentEvent::End { text, usage } => {
            println!("\nâœ… Done: {} tokens", usage.total_tokens);
            break;
        }
        AgentEvent::Error { message } => {
            eprintln!("âŒ {message}");
        }
        _ => {} // required: AgentEvent is #[non_exhaustive]
    }
}
```

## Conversation History

Maintain multi-turn conversations by passing history:

```rust
use a3s_code_core::llm::{ContentBlock, Message};

let history = vec![
    Message::user("What's in src/?"),
    Message {
        role: "assistant".to_string(),
        content: vec![ContentBlock::Text {
            text: "The src/ directory contains main.rs and lib.rs.".to_string(),
        }],
        reasoning_content: None,
    },
];

// Continue the conversation
let result = session.send_with_history(&history, "Now explain main.rs").await?;
```

## Direct Tool Execution

Call tools directly without going through the LLM:

```rust
// Generic tool call
let result = session.tool("bash", serde_json::json!({
    "command": "cargo test --lib"
})).await?;
println!("Exit: {}, Output: {}", result.exit_code, result.output);

// Convenience wrappers
let content = session.read_file("src/main.rs").await?;
let output = session.bash("git status").await?;
let files = session.glob("**/*.rs").await?;
let matches = session.grep("fn main").await?;
```

## Built-in Skills

Query skills compiled into the library:

```rust
use a3s_code_core::tools::{builtin_skills, SkillKind};

let skills = builtin_skills();
for skill in &skills {
    println!("{} ({:?}): {}", skill.name, skill.kind, skill.description);
}
// Output:
//   find-skills (Instruction): Helps users discover and install agent skills...
//   delegate-task (Instruction): Delegate complex or multi-step tasks to specialized sub-agents...
```

## Queue Configuration

Enable lane-based tool execution with parallel read operations:

```rust
use a3s_code_core::{SessionOptions, SessionQueueConfig, SessionLane, LaneHandlerConfig, TaskHandlerMode};

// Create session with queue enabled
let session = agent.session("/my-project", Some(
    SessionOptions::new()
        .with_queue_config(
            SessionQueueConfig::default()
                .with_lane_features()  // DLQ + metrics + alerts
        )
))?;

// Query-lane tools (read, glob, grep) now execute in parallel automatically
let result = session.send("Read all config files and summarize them", None).await?;
```

### External Task Handling

Route specific lanes to external handlers for multi-machine parallelization:

```rust
// Set Execute lane to External mode
session.set_lane_handler(
    SessionLane::Execute,
    LaneHandlerConfig {
        mode: TaskHandlerMode::External,
        timeout_ms: 30_000,
    },
).await;

// External tasks appear as events â€” complete them from your handler
let tasks = session.pending_external_tasks().await;
for task in tasks {
    let result = ExternalTaskResult {
        success: true,
        result: serde_json::json!({"output": "done"}),
        error: None,
    };
    session.complete_external_task(&task.task_id, result).await;
}
```

### Queue Observability

```rust
// Get queue statistics
let stats = session.queue_stats().await;
println!("Pending: {}, Active: {}", stats.total_pending, stats.total_active);

// Get metrics snapshot (if metrics enabled)
if let Some(metrics) = session.queue_metrics().await {
    println!("Metrics: {:?}", metrics);
}

// Get dead letters (if DLQ enabled)
let dead = session.dead_letters().await;
```

## Return Types

```rust
pub struct AgentResult {
    pub text: String,
    pub messages: Vec<Message>,       // Full conversation history
    pub usage: TokenUsage,
    pub tool_calls_count: usize,
}

pub struct TokenUsage {
    pub prompt_tokens: usize,
    pub completion_tokens: usize,
    pub total_tokens: usize,
    pub cache_read_tokens: Option<usize>,
    pub cache_write_tokens: Option<usize>,
}

pub struct ToolCallResult {
    pub name: String,
    pub output: String,
    pub exit_code: i32,
}

#[non_exhaustive]
pub enum AgentEvent {
    Start { prompt: String },
    TurnStart { turn: usize },
    TextDelta { text: String },
    ToolStart { id: String, name: String },
    ToolEnd { id: String, name: String, output: String, exit_code: i32 },
    ToolOutputDelta { id: String, name: String, delta: String },
    TurnEnd { turn: usize, usage: TokenUsage },
    End { text: String, usage: TokenUsage },
    ConfirmationRequired { tool_id: String, tool_name: String, args: Value, timeout_ms: u64 },
    ConfirmationReceived { tool_id: String, approved: bool, reason: Option<String> },
    ConfirmationTimeout { tool_id: String, action_taken: String },
    PermissionDenied { tool_id: String, tool_name: String, args: Value, reason: String },
    ContextResolving { providers: Vec<String> },
    ContextResolved { total_items: usize, total_tokens: usize },
    TaskUpdated { session_id: String, tasks: Vec<Task> },
    Error { message: String },
    // ... future variants may be added (use _ => {} in match)
}
```
