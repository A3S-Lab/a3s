---
title: Custom Tools
description: Define and register custom tools via Skills, MCP, Binary, HTTP, and Script backends
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Custom Tools

Beyond the 14 built-in tools, A3S Code supports four ways to add custom tools: Skill files, MCP servers, dynamic backends (Binary/HTTP/Script), and the Rust API.

## 1. Skill-Based Tools

Define tools in Markdown skill files with YAML frontmatter. This is the simplest way to add custom tools.

```markdown
# ~/.a3s/skills/my-tools.md
---
name: my-tools
description: Custom tools for my workflow
tools:
  - name: deploy
    description: Deploy the application to production
    backend:
      type: binary
      path: /usr/local/bin/deploy.sh
      args_template: "--env ${environment} --tag ${tag}"
    parameters:
      type: object
      properties:
        environment:
          type: string
          enum: [staging, production]
        tag:
          type: string
          description: Docker image tag
      required: [environment, tag]

  - name: check_status
    description: Check deployment status via API
    backend:
      type: http
      url: "https://api.example.com/status/${service}"
      method: GET
      headers:
        Authorization: "Bearer ${API_TOKEN}"
      timeout_ms: 5000
    parameters:
      type: object
      properties:
        service:
          type: string
      required: [service]

  - name: lint
    description: Run custom linter
    backend:
      type: script
      interpreter: python3
      script: |
        import sys, json
        args = json.loads(sys.argv[1])
        # ... linting logic
        print(json.dumps({"issues": []}))
    parameters:
      type: object
      properties:
        path:
          type: string
      required: [path]
---
Use these tools for deployment and monitoring tasks.
```

Skills are loaded automatically from directories specified in your config or session options:

```hcl
skill_dirs = ["./skills", "~/.a3s/skills"]
```

The agent can then use the custom tools in any session:

```rust
let session = agent.session("/my-project", None)?;
let result = session.send("Deploy the app to staging with tag v1.2.3").await?;
```

## 2. MCP Server Tools

Register external [Model Context Protocol](https://modelcontextprotocol.io/) servers in your agent config. All tools exposed by the server are automatically available to the agent.

```hcl
mcp_servers {
  name      = "github"
  transport = "stdio"
  command   = "npx"
  args      = ["-y", "@modelcontextprotocol/server-github"]
  enabled   = true
  env = {
    GITHUB_TOKEN = "ghp_..."
  }
}

mcp_servers {
  name      = "filesystem"
  transport = "stdio"
  command   = "npx"
  args      = ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
  enabled   = true
}
```

MCP tools are namespaced as `mcp__<server>__<tool>` to avoid name collisions. For example, tools from the GitHub MCP server are exposed as `mcp__github__create_issue`, `mcp__github__search_repos`, etc.

## 3. Tool Backend Types

Custom tools support three execution backends:

### Binary

Execute an external binary with templated arguments:

```yaml
backend:
  type: binary
  path: /usr/local/bin/my-tool    # Path to executable
  url: https://example.com/tool   # Or download URL (optional)
  args_template: "--input ${input} --format json"
```

The binary receives arguments via command-line flags. Stdout is captured as the tool output.

### HTTP

Make HTTP API calls with templated URL, headers, and body:

```yaml
backend:
  type: http
  url: "https://api.example.com/v1/${endpoint}"
  method: POST
  headers:
    Authorization: "Bearer ${API_KEY}"
    Content-Type: application/json
  body_template: '{"query": "${query}"}'
  timeout_ms: 10000
```

### Script

Run inline scripts with any interpreter:

```yaml
backend:
  type: script
  interpreter: python3
  interpreter_args: ["-u"]
  script: |
    import sys, json
    args = json.loads(sys.argv[1])
    result = process(args)
    print(json.dumps(result))
```

Supported interpreters: `python3`, `node`, `bash`, `ruby`, `deno`, or any executable.

## 4. Rust Tool Trait

A3S Code defines a `Tool` trait for all tools. Custom tools are currently registered via skill files or MCP servers (not programmatically at the `Agent` level). The trait is useful for understanding how built-in tools work:

```rust
use a3s_code_core::tools::{Tool, ToolContext, ToolOutput};
use async_trait::async_trait;

#[async_trait]
pub trait Tool: Send + Sync {
    /// Tool name (must be unique within registry)
    fn name(&self) -> &str;

    /// Human-readable description for LLM
    fn description(&self) -> &str;

    /// JSON Schema for tool parameters
    fn parameters(&self) -> serde_json::Value;

    /// Execute the tool with given arguments
    async fn execute(
        &self,
        args: &serde_json::Value,
        ctx: &ToolContext,
    ) -> Result<ToolOutput>;
}
```

`ToolOutput` is the return type for all tool executions:

```rust
pub struct ToolOutput {
    pub content: String,           // Output text
    pub success: bool,             // Whether execution succeeded
    pub metadata: Option<Value>,   // Optional metadata
}
```

> **Note:** In v0.7.1, custom tools are registered via skill files (`skill_dirs`) or MCP servers (`mcp_servers`), not via a Rust API on `CodeConfig`. Programmatic tool registration is planned for a future release.

## Tool Permissions

Custom tools respect the session's permission policy. You can restrict which tools a skill can use:

```markdown
---
name: deploy
allowed_tools: Bash(kubectl:*), Bash(docker:*)
---
```

This ensures the deploy skill can only run `kubectl` and `docker` commands, even if the session allows broader bash access.

## Summary

| Method | Registration | Best For |
|--------|-------------|----------|
| Skill files | `skill_dirs` in config | Declarative tools with prompt context |
| MCP servers | `mcp_servers` in config | External tool ecosystems |
