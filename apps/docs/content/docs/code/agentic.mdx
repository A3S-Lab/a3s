---
title: Agentic Loop
description: Server-side autonomous agent loop with tool execution, planning, and reflection
---

# Server-Side Agentic Loop

The agentic loop is the primary way to use A3S Code. Unlike raw [generation](/docs/code/generation), the agentic loop automatically executes tools, handles multi-step reasoning, and optionally plans before acting.

## Basic Usage

```typescript
// Unary ‚Äî wait for complete result
const result = await client.agenticGenerate(sessionId, {
  prompt: 'Refactor the auth module to use JWT',
  maxSteps: 30,
});

console.log(result.text);              // Final assistant output
console.log(result.steps.length);      // Number of steps taken
console.log(result.finishReason);      // 'stop' | 'max_steps' | 'cancelled' | 'error'
console.log(result.usage.totalTokens); // Total tokens used
```

```python
result = await client.agentic_generate(session_id, "Refactor the auth module to use JWT")
print(result["text"])
print(result["finish_reason"])
```

## Streaming

Stream events as the agent works ‚Äî text output, tool calls, results, and more.

```typescript
for await (const event of client.streamAgenticGenerate(sessionId, {
  prompt: 'Add unit tests for the user service',
  maxSteps: 50,
})) {
  switch (event.type) {
    case 'text':
      process.stdout.write(event.content);
      break;
    case 'tool_call':
      console.log(`\nüîß ${event.toolCall.name}(${event.toolCall.arguments})`);
      break;
    case 'tool_result':
      console.log(`   ‚Üí ${event.toolResult.output.slice(0, 200)}`);
      break;
    case 'step_finish':
      console.log(`\n--- Step ${event.stepIndex} complete (${event.usage.totalTokens} tokens) ---`);
      break;
    case 'plan':
      console.log(`\nüìã Plan: ${JSON.stringify(event.plan)}`);
      break;
    case 'reflection':
      console.log(`\nü§î Confidence: ${event.confidence}, Retry: ${event.shouldRetry}`);
      break;
    case 'confirmation_required':
      console.log(`\n‚ö†Ô∏è Confirm: ${event.toolName}(${event.toolArgs})`);
      break;
    case 'context_compact':
      console.log(`\nüì¶ Compacted: ${event.beforeTokens} ‚Üí ${event.afterTokens} tokens`);
      break;
    case 'done':
      console.log(`\n‚úÖ Done: ${event.finishReason}`);
      break;
  }
}
```

```python
async for event in client.stream_agentic_generate(session_id, "Add unit tests"):
    if event.get("type") == "text":
        print(event["content"], end="", flush=True)
    elif event.get("type") == "tool_call":
        print(f"\nTool: {event['tool_call']['name']}")
    elif event.get("type") == "done":
        print(f"\nDone: {event['finish_reason']}")
```

## Strategies

Control how the agent approaches the task.

| Strategy | Behavior |
|----------|----------|
| `AUTO` (default) | Agent decides the best approach |
| `DIRECT` | Single-pass generation, no planning |
| `PLANNED` | Create execution plan first, then execute step by step |
| `ITERATIVE` | Iteratively refine with tool calls until goal is met |
| `PARALLEL` | Execute independent steps in parallel |

```typescript
await client.agenticGenerate(sessionId, {
  prompt: 'Migrate database schema to v2',
  strategy: 'PLANNED',
  maxSteps: 100,
});
```

## Event Types

The streaming response emits these event types:

| Event | Fields | Description |
|-------|--------|-------------|
| `text` | `content` | Text delta from assistant |
| `tool_call` | `toolCall` | Tool execution request |
| `tool_result` | `toolResult` | Tool execution result |
| `step_finish` | `stepIndex`, `stepText`, `usage` | Step completed |
| `plan` | `plan` | Execution plan created |
| `reflection` | `confidence`, `shouldRetry`, `insight` | Agent self-reflection |
| `confirmation_required` | `confirmationId`, `toolName`, `toolArgs`, `timeoutMs` | HITL approval needed |
| `confirmation_received` | `confirmationId`, `approved` | HITL response received |
| `subagent_start` | `agentName`, `agentTask`, `agentSessionId` | Subagent spawned |
| `subagent_progress` | `agentSessionId`, `content` | Subagent progress |
| `subagent_end` | `agentSessionId`, `agentResult` | Subagent completed |
| `context_compact` | `beforeTokens`, `afterTokens` | Context was auto-compacted |
| `external_task_pending` | `externalTask` | External task created |
| `external_task_completed` | `externalTask` | External task completed |
| `error` | `errorMessage`, `recoverable` | Error occurred |
| `done` | `finishReason`, `usage` | Loop finished |

## Configuration

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `prompt` | string | required | The task for the agent |
| `strategy` | enum | `AUTO` | Execution strategy |
| `maxSteps` | number | 50 | Maximum tool execution steps |
| `reflection` | bool | true | Enable self-reflection |
| `planning` | bool | auto | Force planning on/off |

## RPCs

| RPC | Description |
|-----|-------------|
| `agenticGenerate(sessionId, prompt, strategy, maxSteps)` | Run full agentic loop (unary) |
| `streamAgenticGenerate(sessionId, prompt, strategy, maxSteps)` | Run full agentic loop (streaming) |
