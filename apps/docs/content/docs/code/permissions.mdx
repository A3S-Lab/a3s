---
title: Permissions & HITL
description: Fine-grained tool access control and human-in-the-loop confirmation
---

# Permissions & HITL

A3S Code provides two independent layers of access control: a rule-based permission system and a human-in-the-loop (HITL) confirmation system. They work together but are evaluated independently.

## Permission System

Permissions control which tools the agent can use. Rules are evaluated in order: Deny → Allow → Ask → Default.

### Rule Types

| Action | Behavior |
|--------|----------|
| `deny` | Block the tool call immediately |
| `allow` | Permit the tool call |
| `ask` | Prompt the user for confirmation |

### Rule Format

Rules use glob-style pattern matching on tool names and arguments:

```
Tool(pattern)
```

- `Bash(rm -rf:*)` — matches any bash command starting with `rm -rf`
- `Read(src/**)` — matches read operations on any file under `src/`
- `Write(*)` — matches all write operations
- MCP tools use prefix matching: `mcp__server` matches `mcp__server__tool`

### Configuration

```typescript
await session.setPermissions({
  defaultAction: 'ask',
  rules: [
    { tool: 'Bash', pattern: 'rm -rf:*', action: 'deny' },
    { tool: 'Read', pattern: 'src/**', action: 'allow' },
    { tool: 'Grep', pattern: 'src/**', action: 'allow' },
    { tool: 'Bash', pattern: '*', action: 'ask' },
    { tool: 'Write', pattern: '*', action: 'ask' },
  ],
});
```

```python
await session.set_permissions(
    default_action="ask",
    allow=["Read(src/**)", "Grep(src/**)"],
    deny=["Bash(rm -rf:*)"],
    ask=["Bash(*)", "Write(*)"],
)
```

## Human-in-the-Loop (HITL)

HITL is independent of the permission system. Even if a tool is `allow`-ed by permissions, it still goes through the HITL check. This provides defense-in-depth.

### Configuration

```typescript
await session.setConfirmation({
  autoApprove: ['read', 'grep', 'glob', 'ls'],
  requireConfirmation: ['bash', 'write', 'edit'],
  timeout: 30000,        // 30 seconds
  timeoutAction: 'reject', // reject on timeout (safer default)
});
```

```python
await session.set_confirmation(
    auto_approve=["read", "grep", "glob", "ls"],
    require_confirmation=["bash", "write", "edit"],
    timeout=30000,
    timeout_action="reject",
)
```

### Responding to Confirmation Requests

When a tool requires confirmation, the SDK client receives a confirmation event:

```typescript
// Listen for confirmation requests
for await (const event of session.stream('Deploy to production')) {
  if (event.confirmationRequest) {
    const { id, toolName, args } = event.confirmationRequest;
    console.log(`Tool ${toolName} wants to run with args:`, args);

    // Approve or reject
    await session.confirm(id, true, 'Approved by operator');
  }
}
```

```python
async for event in session.stream("Deploy to production"):
    if event.type == "confirmation_request":
        print(f"Tool {event.tool_name} wants to run: {event.args}")
        await session.confirm(event.id, True, "Approved by operator")
```

### Timeout Behavior

| Action | Behavior |
|--------|----------|
| `reject` | Reject the tool call on timeout (recommended) |
| `auto_approve` | Auto-approve on timeout (use with caution) |

## Evaluation Order

When the agent wants to execute a tool, the following checks happen in order:

1. **SecurityGuard hooks** (priority 1) — taint tracking, injection detection
2. **Permission policy** — Deny → Allow → Ask → Default
3. **HITL confirmation** — independent check, even if permissions say Allow
4. **Guard policy** — defense-in-depth check on ToolExecutor
5. **Skill tool filters** — per-skill `allowed_tools` restrictions

Any layer can block the tool call. All layers must pass for execution to proceed.
